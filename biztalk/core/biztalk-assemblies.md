---
title: BizTalk Server 中的組件的部署方式 |Microsoft 文件
description: 組件部署至 GAC 中，並啟用 BizTalk Server 中的組件的版本控制
ms.custom: ''
ms.date: 01/21/2016
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c7f99ed5-b64a-4a38-99d7-83070fb69030
caps.latest.revision: 13
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: bb6c787219855ca219808fc1e95c0caefbf12a9d
ms.sourcegitcommit: 3fc338e52d5dbca2c3ea1685a2faafc7582fe23a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/01/2017
ms.locfileid: "26006111"
---
# <a name="biztalk-assemblies"></a><span data-ttu-id="914cf-103">BizTalk 組件</span><span class="sxs-lookup"><span data-stu-id="914cf-103">BizTalk Assemblies</span></span>
<span data-ttu-id="914cf-104">Microsoft BizTalk Server 與 .NET Framework 最重要的部分是所有的 BizTalk Server 成品、對應、結構描述、協調流程以及管線都會編譯為 .NET 組件。</span><span class="sxs-lookup"><span data-stu-id="914cf-104">The most important aspect of Microsoft BizTalk Server and the .NET Framework is that all BizTalk Server artifacts; maps, schemas, orchestrations, and pipelines, get compiled into .NET assemblies.</span></span> <span data-ttu-id="914cf-105">此設計的兩個最重要含意是這些組件必須具有強式名稱，因此它們也遵循 .NET 版本管理規則。</span><span class="sxs-lookup"><span data-stu-id="914cf-105">The two most important implications of this design are that these assemblies must have strong names, and because of that, they also follow .NET versioning rules.</span></span> <span data-ttu-id="914cf-106">其主要含意為，一旦針對另一個 .NET 專案或組件 (包括 BizTalk 專案) 的特定版本建置 BizTalk 專案，該專案會繼續使用此版本，直到再針對較新的版本重新建置它為止。</span><span class="sxs-lookup"><span data-stu-id="914cf-106">The main implication of this is that a BizTalk project, once built against a particular version of another .NET project or assembly (including BizTalk projects), continues to use that version until it has been rebuilt against a newer version.</span></span>  
  
## <a name="net-versioning-and-assemblies"></a><span data-ttu-id="914cf-107">.NET 版本管理與組件</span><span class="sxs-lookup"><span data-stu-id="914cf-107">.NET Versioning and Assemblies</span></span>  
 <span data-ttu-id="914cf-108">在開發期間發生的一個與 .NET 版本管理相關之常見問題是，BizTalk 專案上的版本號碼未變更，而且在重新部署組件時，未停止後啟動載入類型的 BizTalk 主控件執行個體。</span><span class="sxs-lookup"><span data-stu-id="914cf-108">A common problem occurs during development related to .NET versioning when the version numbers on a BizTalk project are not changed and the assembly is redeployed without stopping and starting the BizTalk host instance that the types are loaded into.</span></span>  
  
 <span data-ttu-id="914cf-109">當再次執行程序時，變更不會生效。</span><span class="sxs-lookup"><span data-stu-id="914cf-109">When the process is run again, the changes do not take effect.</span></span> <span data-ttu-id="914cf-110">這是由於將 .NET 組件載入記憶體的方式所造成。</span><span class="sxs-lookup"><span data-stu-id="914cf-110">This is due to the way in which .NET assemblies are loaded into memory.</span></span> <span data-ttu-id="914cf-111">因為主控件已經具有組件的記憶體中複本，所以將新複本放入「全域組件快取」時，不會重新載入組件。</span><span class="sxs-lookup"><span data-stu-id="914cf-111">Because the host already has an in-memory copy of the assembly, it does not reload the assembly when a new copy is put into the Global Assembly Cache.</span></span> <span data-ttu-id="914cf-112">例如，若已部署和執行搭配協調流程之 1.0.0.0 版的組件，而協調流程已變更，但是版本號碼未變更，則變更不會生效。</span><span class="sxs-lookup"><span data-stu-id="914cf-112">For example, if version 1.0.0.0 of an assembly with an orchestration is deployed and running, and changes are made to the orchestration but the version number is not changed, then the changes do not take effect.</span></span> <span data-ttu-id="914cf-113">在主控件執行個體停止後，會釋放組件的記憶體中複本，當主控件執行個體再次啟動時，它會重新載入組件的新複本並取得變更。</span><span class="sxs-lookup"><span data-stu-id="914cf-113">After the host instance is stopped, the in-memory copy of the assembly is released and when the host instance starts again it reloads the new copy of the assembly and gets the changes.</span></span> <span data-ttu-id="914cf-114">若已部署新版本，例如 2.0.0.0 版，就會將它載入，然後變更也會生效。</span><span class="sxs-lookup"><span data-stu-id="914cf-114">If a new version was deployed, say version 2.0.0.0, and it was loaded, then the changes would have taken effect.</span></span>  
  
 <span data-ttu-id="914cf-115">部署組件到 BizTalk Server 是一個包含兩部分的程序。</span><span class="sxs-lookup"><span data-stu-id="914cf-115">Deploying assemblies to BizTalk Server is a two part process.</span></span> <span data-ttu-id="914cf-116">第一個部分是傳統的 .NET 組件部署，在此會將強式名稱的組件部署到使用組件的每個伺服器上的「全域組件快取」(GAC)。</span><span class="sxs-lookup"><span data-stu-id="914cf-116">The first part is traditional .NET assembly deployment in which the strong-named assembly is deployed to the Global Assembly Cache (GAC) on each server where the assembly will be used.</span></span> <span data-ttu-id="914cf-117">第二步是將組件的中繼資料及其類型部署到 BizTalk Server 管理資料庫。</span><span class="sxs-lookup"><span data-stu-id="914cf-117">The second step is to deploy metadata about the assemblies and their types to the BizTalk Server Management database.</span></span> <span data-ttu-id="914cf-118">當 BizTalk Server 載入 BizTalk Server 組件時，最常使用其強式名稱來載入它們，您可以在管理資料庫中找到這些名稱。</span><span class="sxs-lookup"><span data-stu-id="914cf-118">When BizTalk Server assemblies are loaded by BizTalk Server, they are most often loaded using their strong name, found in the Management database.</span></span>  
  
## <a name="deploying-biztalk-server-assemblies-to-the-gac"></a><span data-ttu-id="914cf-119">將 BizTalk Server 組件部署到 GAC</span><span class="sxs-lookup"><span data-stu-id="914cf-119">Deploying BizTalk Server Assemblies to the GAC</span></span>  
 <span data-ttu-id="914cf-120">開發人員建立的 BizTalk Server 成品會編譯為衍生自內建 BizTalk Server 類型的類別。</span><span class="sxs-lookup"><span data-stu-id="914cf-120">The BizTalk Server artifacts that a developer creates get compiled into classes which derive from built in BizTalk Server types.</span></span> <span data-ttu-id="914cf-121">例如，協調流程會變成衍生自 Microsoft.BizTalkXLANGs.BTXEngine.BTXService 類別的類別。</span><span class="sxs-lookup"><span data-stu-id="914cf-121">For example, an orchestration becomes a class which derives from the Microsoft.BizTalkXLANGs.BTXEngine.BTXService class.</span></span> <span data-ttu-id="914cf-122">這是因為組件中的這些基底類別已部署到「全域組件快取」，而這些組件對 GAC 中的其他組件有相依性，所以開發人員的組件也必須部署到 GAC。</span><span class="sxs-lookup"><span data-stu-id="914cf-122">It is because these base classes are deployed in assemblies to the Global Assembly Cache, and these assemblies have dependencies on other assemblies in the GAC, that a developer's assemblies must also get deployed to the GAC.</span></span>  
  
 <span data-ttu-id="914cf-123">部署到「全域組件快取」的 BizTalk Server 成品也因此必須使用強式名稱的另一個重要含意是，強式名稱的組件不能呼叫其他不是強式名稱的組件。</span><span class="sxs-lookup"><span data-stu-id="914cf-123">Another important implication of BizTalk Server artifacts being deployed to the Global Assembly Cache and therefore being strong named, is that strong named assemblies cannot call other assemblies that are not also strong named.</span></span> <span data-ttu-id="914cf-124">這表示由開發人員建立以供這些 BizTalk 組件使用的任何組件，也必須使用強式名稱。</span><span class="sxs-lookup"><span data-stu-id="914cf-124">This means that any assemblies a developer creates that are used by these BizTalk Server assemblies must also be strong named.</span></span> <span data-ttu-id="914cf-125">同樣的，部署到 GAC 的組件若未使用特定路徑載入其他組件，則必須從 GAC 載入這些組件。</span><span class="sxs-lookup"><span data-stu-id="914cf-125">Likewise, assemblies deployed to the GAC that load other assemblies without using a specific path, must load those assemblies from the GAC.</span></span>  
  
 <span data-ttu-id="914cf-126">會將管線元件新增至 [!INCLUDE[btsVStudioNoVersion](../includes/btsvstudionoversion-md.md)] 中的開發人員工具箱，讓它們可供拖曳至管線設計師上。</span><span class="sxs-lookup"><span data-stu-id="914cf-126">Pipeline components are added to a developer's toolbox in [!INCLUDE[btsVStudioNoVersion](../includes/btsvstudionoversion-md.md)] to make them available to be dragged onto the pipeline designer.</span></span> <span data-ttu-id="914cf-127">將 BizTalk Server 管線編譯為 .NET 組件時，會將管線各個階段中所有元件的資訊編譯為組件。</span><span class="sxs-lookup"><span data-stu-id="914cf-127">When a BizTalk Server pipeline is compiled into a .NET assembly, the information about all of the components in the various stages of the pipeline get compiled into the assembly.</span></span> <span data-ttu-id="914cf-128">此管線部署到 BizTalk Server 時, 的元件，包括其檔案名稱資訊插入 BizTalk 管理資料庫和管線組件部署到 GAC。</span><span class="sxs-lookup"><span data-stu-id="914cf-128">When this pipeline is deployed to BizTalk Server, the information about the components, including their file name, is inserted into the BizTalk Management database and the pipeline assembly is deployed into the GAC.</span></span> <span data-ttu-id="914cf-129">BizTalk 管線元件相依於任何其他組件也必須部署到 GAC 以便在執行階段找到。</span><span class="sxs-lookup"><span data-stu-id="914cf-129">Any additional assemblies that BizTalk pipeline components depend upon must also be deployed to the GAC in order to be found at runtime.</span></span> <span data-ttu-id="914cf-130">管線元件組件也必須複製到可存取 BizTalk Server\Pipeline 元件目錄中，但會由 BizTalk 管線在執行階段。</span><span class="sxs-lookup"><span data-stu-id="914cf-130">Pipeline component assemblies must also be copied to the BizTalk Server\Pipeline Components directory to be accessible by a BizTalk pipeline at runtime.</span></span> <span data-ttu-id="914cf-131">管線執行時會載入這些元件，並適時呼叫它們所實作的介面。</span><span class="sxs-lookup"><span data-stu-id="914cf-131">When the pipeline is executed, these components are loaded, and the interfaces they implement called as appropriate.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="914cf-132">請參閱</span><span class="sxs-lookup"><span data-stu-id="914cf-132">See Also</span></span>  
 [<span data-ttu-id="914cf-133">執行階段架構</span><span class="sxs-lookup"><span data-stu-id="914cf-133">Runtime Architecture</span></span>](../core/runtime-architecture.md)