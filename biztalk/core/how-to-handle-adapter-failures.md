---
title: 如何處理配接器失敗 |Microsoft 文件
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 94ce45dbf8fcc46c952ddd5ccf7ed45e633641a4
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
ms.locfileid: "22255926"
---
# <a name="how-to-handle-adapter-failures"></a><span data-ttu-id="e4451-102">如何處理配接器失敗</span><span class="sxs-lookup"><span data-stu-id="e4451-102">How to Handle Adapter Failures</span></span>
<span data-ttu-id="e4451-103">一般而言，配接器應該會擱置無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-103">In general, adapters should suspend messages that they cannot process.</span></span> <span data-ttu-id="e4451-104">舉例來說，雖然是否擱置訊息是依配接器的用途而定，但是發生提交失敗時，接收配接器通常會擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-104">For example, a receive adapter that experiences a submit failure should typically suspend the messages, although this decision depends upon the purpose of the adapter.</span></span> <span data-ttu-id="e4451-105">此外，在處理這類失敗時，還必須注意一些安全性考量。</span><span class="sxs-lookup"><span data-stu-id="e4451-105">There are also security considerations around handling failures.</span></span> <span data-ttu-id="e4451-106">例如，如果配接器自動擱置所有失敗的訊息，表示配接器可能容易受到拒絕服務攻擊，導致 BizTalk Server 擱置佇列被填滿。</span><span class="sxs-lookup"><span data-stu-id="e4451-106">For example, if an adapter automatically suspends all failed messages, the adapter might be open to a denial-of-service attack that causes the BizTalk Server Suspended queue to fill up.</span></span>  <span data-ttu-id="e4451-107">某些配接器 (例如 HTTP) 會傳回失敗碼給用戶端，指出要求已遭到拒絕。</span><span class="sxs-lookup"><span data-stu-id="e4451-107">Some adapters, such as HTTP, can return a failure code to the client indicating that the request has been rejected.</span></span> <span data-ttu-id="e4451-108">就這些配接器類型而言，傳回失敗碼通常會比擱置訊息來得有意義。</span><span class="sxs-lookup"><span data-stu-id="e4451-108">For these types of adapters it often makes sense to return a failure code rather than suspend the message.</span></span> <span data-ttu-id="e4451-109">一般來說，在用盡主要和次要傳輸的所有重試次數之後，傳送配接器只會擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-109">Typically send adapters only suspend messages after all of the retries have been exhausted for both primary and secondary transports.</span></span>  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a><span data-ttu-id="e4451-110">將錯誤處理與個別作業產生關聯，而不與包含作業的批次產生關聯</span><span class="sxs-lookup"><span data-stu-id="e4451-110">Associate Error Processing with an Individual Operation and Not with the Batch That Contains the Operation</span></span>  
 <span data-ttu-id="e4451-111">配接器的使用者應該看不到配接器內訊息的批次處理。</span><span class="sxs-lookup"><span data-stu-id="e4451-111">The batching of messages within an adapter should be invisible to the user of the adapter.</span></span> <span data-ttu-id="e4451-112">這表示，批次中一個作業的失敗不會在任何方面影響到任何其他作業。</span><span class="sxs-lookup"><span data-stu-id="e4451-112">This means that the failure of one operation in a batch should not affect any other operation in any way.</span></span> <span data-ttu-id="e4451-113">然而，批次是不可部分完成的，因此一個訊息的失敗會造成批次的錯誤，並且無法處理任何作業。</span><span class="sxs-lookup"><span data-stu-id="e4451-113">However, batches are atomic, so the failure of one message results in an error for the batch, and no operations are processed.</span></span>  
  
 <span data-ttu-id="e4451-114">您撰寫負責處理錯誤、重新提交成功訊息並擱置失敗訊息的程式碼。</span><span class="sxs-lookup"><span data-stu-id="e4451-114">You write the code that is responsible for handling the error, resubmitting the successful messages, and suspending the unsuccessful ones.</span></span> <span data-ttu-id="e4451-115">幸而 BizTalk Server 會提供詳細的錯誤結構，讓您的配接器可以判斷失敗的特定作業，</span><span class="sxs-lookup"><span data-stu-id="e4451-115">Fortunately, BizTalk Server provides a detailed error structure that enables your adapter to determine the specific operation that failed.</span></span> <span data-ttu-id="e4451-116">並且允許建構其他批次以重新提交成功作業並擱置失敗作業。</span><span class="sxs-lookup"><span data-stu-id="e4451-116">It permits construction of further batches in which the successful operations are resubmitted and the unsuccessful ones suspended.</span></span>  
  
 <span data-ttu-id="e4451-117">作業的最後狀態應該不會受到配接器內批次處理的影響。</span><span class="sxs-lookup"><span data-stu-id="e4451-117">The final state of the operation should not be affected by the batching within the adapter.</span></span>  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a><span data-ttu-id="e4451-118">使用 SetErrorInfo 回報失敗給 BizTalk Server</span><span class="sxs-lookup"><span data-stu-id="e4451-118">Use SetErrorInfo to Report Failure to BizTalk Server</span></span>  
 <span data-ttu-id="e4451-119">如果您要擱置訊息，必須將先前訊息內容中的失敗資訊提供給 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="e4451-119">If you are suspending a message, you must provide failure information to BizTalk Server from the previous message context.</span></span> <span data-ttu-id="e4451-120">BizTalk Server 提供的錯誤報告功能採用**SetErrorInfo**上兩個方法**IBaseMessage**和**Seterrorinfo**介面。</span><span class="sxs-lookup"><span data-stu-id="e4451-120">BizTalk Server provides error reporting capabilities using the **SetErrorInfo** method on both the **IBaseMessage** and **ITransportProxy** interfaces.</span></span> <span data-ttu-id="e4451-121">您可以使用下列方式報告錯誤：</span><span class="sxs-lookup"><span data-stu-id="e4451-121">You can report errors as follows:</span></span>  
  
-   <span data-ttu-id="e4451-122">發生失敗時處理訊息時，設定例外狀況使用**SetErrorInfo （例外電子）** 訊息 (**IBaseMessage**) 要暫止。</span><span class="sxs-lookup"><span data-stu-id="e4451-122">When a failure occurs while processing a message, set the exception using **SetErrorInfo(Exception e)** on the message (**IBaseMessage**) to be suspended.</span></span> <span data-ttu-id="e4451-123">這可讓引擎保存錯誤和訊息，以便日後進行診斷，並且將錯誤記錄到事件記錄檔中，以警告系統管理員。</span><span class="sxs-lookup"><span data-stu-id="e4451-123">This allows the engine to preserve the error with the message for later diagnosis and logs it to the event log to alert the administrator.</span></span>  
  
-   <span data-ttu-id="e4451-124">如果您在初始化或內部簿記期間遇到錯誤 （不會在訊息處理） 應該呼叫**SetErrorInfo （例外電子）** 上**Seterrorinfo**指標傳遞給您在初始化期間。</span><span class="sxs-lookup"><span data-stu-id="e4451-124">If you encounter an error during initialization or internal bookkeeping (not during message processing) you should call **SetErrorInfo(Exception e)** on the **ITransportProxy** pointer that was passed to you during initialization.</span></span> <span data-ttu-id="e4451-125">如果您的配接器以 BaseAdapter 實作為基礎，那麼您應該永遠擁有這個指標的存取權限。</span><span class="sxs-lookup"><span data-stu-id="e4451-125">If your adapter is based on the BaseAdapter implementation, you should always have access to this pointer.</span></span> <span data-ttu-id="e4451-126">否則，您應該可以快取這個指標。</span><span class="sxs-lookup"><span data-stu-id="e4451-126">Otherwise, you should be certain that you cache it.</span></span>  
  
 <span data-ttu-id="e4451-127">使用上述方法報告錯誤會導致錯誤訊息被寫入事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="e4451-127">Reporting an error with either of these methods results in the error message being written to the event log.</span></span> <span data-ttu-id="e4451-128">很重要，您將錯誤關聯相關的訊息。 如果您可以執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="e4451-128">It is important that you associate the error with the related message if you are able to do so.</span></span>  
  
## <a name="handle-a-database-offline-condition"></a><span data-ttu-id="e4451-129">處理資料庫離線的情況</span><span class="sxs-lookup"><span data-stu-id="e4451-129">Handle a Database-Offline Condition</span></span>  
 <span data-ttu-id="e4451-130">如果其中一個 BizTalk Server 資料庫離線，BizTalk 服務便會自行回收。</span><span class="sxs-lookup"><span data-stu-id="e4451-130">If one of the BizTalk Server databases goes offline, the BizTalk service recycles itself.</span></span> <span data-ttu-id="e4451-131">傳訊引擎會盡力在回收服務之前，關閉所有接收位置。</span><span class="sxs-lookup"><span data-stu-id="e4451-131">The Messaging Engine makes a best effort to shut down all of the receive locations before recycling the service.</span></span> <span data-ttu-id="e4451-132">如果此關閉程序花費 60 秒以上的時間，服務便會終止。</span><span class="sxs-lookup"><span data-stu-id="e4451-132">If this takes longer than 60 seconds, the service terminates.</span></span> <span data-ttu-id="e4451-133">由於引擎已交易，因此，這不會導致資料遺失。</span><span class="sxs-lookup"><span data-stu-id="e4451-133">Because the engine is transacted, this does not cause data loss.</span></span>  
  
 <span data-ttu-id="e4451-134">使用下列機碼，即可在登錄中調整這個逾時值：</span><span class="sxs-lookup"><span data-stu-id="e4451-134">This time-out can be tuned in the registry by using the key:</span></span>  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 <span data-ttu-id="e4451-135">如果是外掛式配接器，由於 BizTalk Server 沒有這種程序，因此當其中一個 BizTalk Server 資料庫離線時，會停用接收位置。</span><span class="sxs-lookup"><span data-stu-id="e4451-135">For isolated adapters, because BizTalk Server does not own the process, the receive locations are disabled when one of the BizTalk Server databases goes offline.</span></span> <span data-ttu-id="e4451-136">當資料庫再次上線後，那些接收位置也將重新啟用。</span><span class="sxs-lookup"><span data-stu-id="e4451-136">After the database comes back online those receive locations are re-enabled.</span></span>  
  
## <a name="write-to-the-event-log"></a><span data-ttu-id="e4451-137">寫入事件記錄檔</span><span class="sxs-lookup"><span data-stu-id="e4451-137">Write to the Event Log</span></span>  
 <span data-ttu-id="e4451-138">配接器可以寫入事件記錄檔項目使用**IBTTransportProxy**傳入例外狀況中的介面。</span><span class="sxs-lookup"><span data-stu-id="e4451-138">The adapter can write event log entries by using the **IBTTransportProxy** interface passing in an exception.</span></span> <span data-ttu-id="e4451-139">原生程式碼開發的配接器必須傳入**IErrorInfo**介面， **IBTTransportProxy.SetErrorInfo (例外狀況** `e` **)**。</span><span class="sxs-lookup"><span data-stu-id="e4451-139">Adapters developed in native code need to pass in an **IErrorInfo** interface, **IBTTransportProxy.SetErrorInfo( Exception** `e` **)**.</span></span>  
  
 <span data-ttu-id="e4451-140">傳訊引擎會代表配接器，將有關配接器在傳輸失敗後重試訊息、將訊息移到備份傳輸或擱置訊息等事件寫入事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="e4451-140">The Messaging Engine writes to the event log on behalf of the adapter for events such as when an adapter retries a message after transmission failure, moves a message to its backup transport, or suspends a message.</span></span> <span data-ttu-id="e4451-141">對於這些作業，配接器只需要在呼叫 API 之前，先在訊息上設定好例外狀況即可。</span><span class="sxs-lookup"><span data-stu-id="e4451-141">For operations such as these the adapter only needs to set the exception on the message before calling the API.</span></span> <span data-ttu-id="e4451-142">下列程式碼片段示範如何進行：</span><span class="sxs-lookup"><span data-stu-id="e4451-142">The following code fragment demonstrates this:</span></span>  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a><span data-ttu-id="e4451-143">處理接收特定批次錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-143">Handle Receive-Specific Batch Errors</span></span>  
  
### <a name="handle-receive-failures"></a><span data-ttu-id="e4451-144">處理接收失敗</span><span class="sxs-lookup"><span data-stu-id="e4451-144">Handle Receive Failures</span></span>  
 <span data-ttu-id="e4451-145">當配接器提交作業 (或作業批次) 給 BizTalk Server 時，可能會因各種不同的原因而造成失敗，</span><span class="sxs-lookup"><span data-stu-id="e4451-145">When an adapter submits an operation (or batch of operations) to BizTalk Server there can be various reasons for failure.</span></span> <span data-ttu-id="e4451-146">其中最重要的兩個原因為：</span><span class="sxs-lookup"><span data-stu-id="e4451-146">The two most significant are:</span></span>  
  
-   <span data-ttu-id="e4451-147">接收管線失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-147">The receive pipeline failed.</span></span>  
  
-   <span data-ttu-id="e4451-148">發佈訊息時，發生路由失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-148">A routing failure occurred while publishing a message.</span></span>  
  
 <span data-ttu-id="e4451-149">在收到接收管線失敗時，傳訊引擎會自動嘗試擱置訊息，</span><span class="sxs-lookup"><span data-stu-id="e4451-149">The Messaging Engine automatically tries to suspend the message when it gets a receive pipeline failure.</span></span> <span data-ttu-id="e4451-150">但是擱置作業不一定每次都會成功。</span><span class="sxs-lookup"><span data-stu-id="e4451-150">The suspend operation may not always be successful.</span></span> <span data-ttu-id="e4451-151">比方說，如果 「 傳訊引擎發佈訊息時，發生路由失敗，然後，引擎不會不甚至嘗試擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-151">For example, if the Messaging Engine hits a routing failure while publishing a message, then the engine does not even try to suspend the message.</span></span>  
  
 <span data-ttu-id="e4451-152">訊息隨時可能發生失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-152">It is always possible that a message will fail.</span></span> <span data-ttu-id="e4451-153">在這種情況下，配接器應該明確地呼叫**MoveToSuspendQ** API，應該嘗試擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-153">In such a situation, the adapter should explicitly call the **MoveToSuspendQ** API and should try to suspend the message.</span></span> <span data-ttu-id="e4451-154">當配接器嘗試擱置訊息時，下列其中一個情形應該會成立：</span><span class="sxs-lookup"><span data-stu-id="e4451-154">When an adapter tries to suspend a message, one of the following should be true:</span></span>  
  
-   <span data-ttu-id="e4451-155">配接器所提交 (建議) 的相同訊息物件應該會遭到擱置。</span><span class="sxs-lookup"><span data-stu-id="e4451-155">The same message object that the adapter submitted (recommended) should be suspended.</span></span>  
  
-   <span data-ttu-id="e4451-156">如果配接器必須建立新的訊息，則應該使用原先所提交之訊息內容的指標來設定新訊息的內容。</span><span class="sxs-lookup"><span data-stu-id="e4451-156">If the adapter has to create a new message, then it should set the message context of the new message with the pointer to the message context of the message that was originally submitted.</span></span> <span data-ttu-id="e4451-157">這是因為訊息的內容會包含許多有關訊息和失敗的有用資訊。</span><span class="sxs-lookup"><span data-stu-id="e4451-157">This is because the message context of a message has a lot of valuable information about the message and the failure.</span></span> <span data-ttu-id="e4451-158">在偵錯失敗的訊息時，必須使用這項資訊。</span><span class="sxs-lookup"><span data-stu-id="e4451-158">This information is required to debug the failed message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e4451-159">如果配接器建立新的訊息物件並加以擱置，則必須從舊訊息物件將錯誤資訊複製到新訊息物件。</span><span class="sxs-lookup"><span data-stu-id="e4451-159">If the adapter creates a new message object and suspends it, the adapter should copy the error information from the old message object to the new message object.</span></span>  
  
 <span data-ttu-id="e4451-160">有些配接器 (例如與 BizTalk Server 一起提供的 HTTP 配接器) 並不需要將訊息擱置。</span><span class="sxs-lookup"><span data-stu-id="e4451-160">Some adapters, such as the HTTP adapter provided with BizTalk Server, do not require that the message be suspended.</span></span> <span data-ttu-id="e4451-161">這些配接器會將錯誤傳回用戶端。</span><span class="sxs-lookup"><span data-stu-id="e4451-161">These adapters can return an error back to their client.</span></span>  
  
#### <a name="causes-of-failure"></a><span data-ttu-id="e4451-162">造成失敗的原因</span><span class="sxs-lookup"><span data-stu-id="e4451-162">Causes of failure</span></span>  
 <span data-ttu-id="e4451-163">簡單失敗的原因是因為建構批次或便會發生的錯誤**ibttransportbatch:: Done**呼叫。</span><span class="sxs-lookup"><span data-stu-id="e4451-163">Simple causes of failure are the errors that can occur as the batch is constructed or when **IBTTransportBatch::Done** is called.</span></span>  
  
-   <span data-ttu-id="e4451-164">**提交失敗。**</span><span class="sxs-lookup"><span data-stu-id="e4451-164">**Submit failure.**</span></span> <span data-ttu-id="e4451-165">**送出**呼叫失敗的有限數目的原因，並全部都是嚴重。</span><span class="sxs-lookup"><span data-stu-id="e4451-165">The **Submit** call can fail for a limited number of reasons, and all of them are fatal.</span></span> <span data-ttu-id="e4451-166">其中包括：</span><span class="sxs-lookup"><span data-stu-id="e4451-166">These reasons include:</span></span>  
  
-   <span data-ttu-id="e4451-167">BizTalk Server 程序空間發生記憶體不足錯誤。</span><span class="sxs-lookup"><span data-stu-id="e4451-167">Out-of-memory errors occurring in the BizTalk Server process space.</span></span>  
  
-   <span data-ttu-id="e4451-168">結構描述組件已從部署中捨棄。</span><span class="sxs-lookup"><span data-stu-id="e4451-168">The schema assembly has been dropped from the deployment.</span></span> <span data-ttu-id="e4451-169">在此情況下，**送出**隱密錯誤而失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-169">In this case, the **Submit** fails with a cryptic error.</span></span> <span data-ttu-id="e4451-170">在 MQSeries 配接器中，從 BizTalk Server 攔截到一般失敗例外狀況，並且在系統事件記錄檔中寫入擴充錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-170">In the MQSeries adapter, the generic failure exception from BizTalk Server is caught, and an extended error message is written in the system event log.</span></span> <span data-ttu-id="e4451-171">這個訊息指示造成此錯誤的其中一個可能原因是，部署已捨棄結構描述組件。</span><span class="sxs-lookup"><span data-stu-id="e4451-171">This message suggests that one of the possible causes of the error is that the schema assembly has somehow been dropped from the deployment.</span></span>  
  
     <span data-ttu-id="e4451-172">在一般情況下，如果**送出**失敗，您應該嘗試擱置訊息使用相同的交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-172">In general, if **Submit** fails you should try to suspend the message using the same transaction.</span></span>  
  
-   <span data-ttu-id="e4451-173">**Ibttransportbatch:: Done 失敗。**</span><span class="sxs-lookup"><span data-stu-id="e4451-173">**IBTTransportBatch::Done failure.**</span></span> <span data-ttu-id="e4451-174">**Ibttransportbatch:: Done**呼叫可以失敗幾個原因之一。</span><span class="sxs-lookup"><span data-stu-id="e4451-174">The **IBTTransportBatch::Done** call can fail for one of several reasons.</span></span> <span data-ttu-id="e4451-175">一般而言，您應該隨時嘗試執行一個擱置作業，並且只在交易失敗時，結束交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-175">In general, you should always attempt one suspend operation and end the transaction only if that fails.</span></span> <span data-ttu-id="e4451-176">您可能會從失敗的收到的錯誤代碼的其中一個**ibttransportbatch:: Done**是 BizTalk Server 嘗試關閉。</span><span class="sxs-lookup"><span data-stu-id="e4451-176">One of the error codes you might receive from the failure of **IBTTransportBatch::Done** is that BizTalk Server is trying to shut down.</span></span> <span data-ttu-id="e4451-177">在此情況下，您應該就結束交易並離開因為**Terminate**呼叫可能也會發生同時。</span><span class="sxs-lookup"><span data-stu-id="e4451-177">In this case, you should just end the transaction and leave it because the **Terminate** call is probably happening concurrently.</span></span> <span data-ttu-id="e4451-178">當您成功建構批次並順利執行，會發生其他實例**ibttransportbatch:: Done**。</span><span class="sxs-lookup"><span data-stu-id="e4451-178">Other scenarios occur when you have successfully constructed the batch and successfully executed **IBTTransportBatch::Done**.</span></span> <span data-ttu-id="e4451-179">在這些情況下，在傳回錯誤**BatchComplete**和配接器必須判斷該如何處理它們。</span><span class="sxs-lookup"><span data-stu-id="e4451-179">In these cases, the errors are returned in **BatchComplete** and the adapter must determine what to do with them.</span></span> <span data-ttu-id="e4451-180">本章節後面的部分將說明如何處理這個情況。</span><span class="sxs-lookup"><span data-stu-id="e4451-180">The rest of this section deals with this case.</span></span>  
  
#### <a name="processing-batchcomplete-errors"></a><span data-ttu-id="e4451-181">處理 BatchComplete 錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-181">Processing BatchComplete errors</span></span>  
 <span data-ttu-id="e4451-182">**BatchComplete**是指出批次作業的完成狀態的 BizTalk Server 所叫用配接器所提供的回呼。</span><span class="sxs-lookup"><span data-stu-id="e4451-182">**BatchComplete** is a callback provided by the adapter that is invoked by BizTalk Server to indicate the completion status of a batch operation.</span></span>  
  
 <span data-ttu-id="e4451-183">最重要的參數傳遞至**BatchComplete**是批次狀態`hResult`。</span><span class="sxs-lookup"><span data-stu-id="e4451-183">The most important parameter passed to **BatchComplete** is the batch status `hResult`.</span></span> <span data-ttu-id="e4451-184">這表示批次成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-184">This indicates success or failure for the batch.</span></span> <span data-ttu-id="e4451-185">如果批次失敗，即表示批次中的作業不成功。</span><span class="sxs-lookup"><span data-stu-id="e4451-185">If the batch failed, it means that none of the operations in the batch succeeded.</span></span> <span data-ttu-id="e4451-186">配接器會通過批次狀態結構，並決定哪些訊息失敗 (這稱為*篩選批次*)。</span><span class="sxs-lookup"><span data-stu-id="e4451-186">The adapter goes through the batch status structure and determines which messages failed (this is known as *filtering the batch*).</span></span>  
  
#### <a name="nontransactional-batchcomplete-errors"></a><span data-ttu-id="e4451-187">非交易式 BatchComplete 錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-187">Nontransactional BatchComplete errors</span></span>  
 <span data-ttu-id="e4451-188">對於非交易式配接器，您必須選擇您的回應若失敗發生**SubmitMessage**/**SubmitRequestMessage**或**SubmitResponseMessage**作業。</span><span class="sxs-lookup"><span data-stu-id="e4451-188">For nontransactional adapters, you must choose your response if a failure occurs for a **SubmitMessage**/**SubmitRequestMessage** or **SubmitResponseMessage** operation.</span></span> <span data-ttu-id="e4451-189">通常配接器會擱置訊息藉由呼叫**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="e4451-189">Typically adapters suspend the message by calling **MoveToSuspendQ**.</span></span>  
  
 <span data-ttu-id="e4451-190">下列作業預期一定會傳遞： **DeleteMessage**， **MoveToSuspendQ**， **ResubmitMessage**。</span><span class="sxs-lookup"><span data-stu-id="e4451-190">The following operations are always expected to pass: **DeleteMessage**, **MoveToSuspendQ**, **ResubmitMessage**.</span></span> <span data-ttu-id="e4451-191">如果這些作業發生失敗，通常代表配接器存在錯誤。</span><span class="sxs-lookup"><span data-stu-id="e4451-191">If these operations fail, it typically means that there is a bug in the adapter.</span></span> <span data-ttu-id="e4451-192">您不需要以撰寫程式碼方式處理這些情況中的失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-192">You do not have to write code to handle a failure in these cases.</span></span> <span data-ttu-id="e4451-193">不過，如果批次因為其他作業失敗而發生失敗，則必須在全新的批次中重新執行這些作業。</span><span class="sxs-lookup"><span data-stu-id="e4451-193">However if the batch failed because another operation failed, then these operations must be re-executed in a fresh batch.</span></span>  
  
 <span data-ttu-id="e4451-194">如果配接器會呼叫**MovetoBackupTransport**卻失敗 （因為沒有備份傳輸），那麼配接器應該呼叫**MoveToSuspendQ**來擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-194">If the adapter calls **MovetoBackupTransport** and that fails (because there was no backup transport), then the adapter should call **MoveToSuspendQ** to suspend the message.</span></span>  
  
#### <a name="transactional-batchcomplete-errors"></a><span data-ttu-id="e4451-195">交易式 BatchComplete 錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-195">Transactional BatchComplete errors</span></span>  
 <span data-ttu-id="e4451-196">當您使用配接器所建立的交易提交批次給 BizTalk Server 時，必須遵守下列其中一個實例：</span><span class="sxs-lookup"><span data-stu-id="e4451-196">When you submit batches to BizTalk Server using a transaction created by the adapter, you should follow one of these two scenarios:</span></span>  
  
-   <span data-ttu-id="e4451-197">**使用單一訊息批次。**</span><span class="sxs-lookup"><span data-stu-id="e4451-197">**Use single-message batches.**</span></span> <span data-ttu-id="e4451-198">傳送單一訊息的批次給 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="e4451-198">Send a single-message batch to BizTalk Server.</span></span> <span data-ttu-id="e4451-199">如果該單一訊息失敗，您就可以合法地在相同交易下傳送第二個批次給 BizTalk Server，但是您必須將違反的訊息移到擱置佇列，而不是重新提交該訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-199">If that single message fails, then you can legally send BizTalk Server a second batch under the same transaction, but you must move the offending message to the Suspended queue rather than resubmitting it.</span></span> <span data-ttu-id="e4451-200">移除失敗的訊息後，提交第二個批次應該會成功。</span><span class="sxs-lookup"><span data-stu-id="e4451-200">After the failed message is removed, the submission of the second batch should succeed.</span></span> <span data-ttu-id="e4451-201">之後，您就可以在 BizTalk Server 確認第二個批次提交成功時認可交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-201">After that occurs you can commit the transaction when BizTalk Server confirms that the second batch was successful.</span></span> <span data-ttu-id="e4451-202">如果第二個批次失敗，則配接器必須中止交易，或者將該訊息放置在其他位置。</span><span class="sxs-lookup"><span data-stu-id="e4451-202">If the second batch fails, the adapter must abort the transaction, or find somewhere else to place that message.</span></span> <span data-ttu-id="e4451-203">在這個實例中，您很快就會發現交易回呼處理對效能造成很明顯的影響。</span><span class="sxs-lookup"><span data-stu-id="e4451-203">In this scenario, you immediately take a significant performance hit due to transaction rollback processing.</span></span>  
  
     <span data-ttu-id="e4451-204">您可以利用一些技術來改善配接器的效能。</span><span class="sxs-lookup"><span data-stu-id="e4451-204">There are some techniques that you can use to improve the performance of the adapter.</span></span> <span data-ttu-id="e4451-205">例如，MQSeries 配接器會在執行階段動態調整它的方式。</span><span class="sxs-lookup"><span data-stu-id="e4451-205">For example, the MQSeries adapter adjusts its approach dynamically at run time.</span></span> <span data-ttu-id="e4451-206">此配接器能夠執行 100 個訊息的批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-206">It runs with 100-message batches.</span></span> <span data-ttu-id="e4451-207">如果發生錯誤，配接器必定會結束批次，但是當它取得以前的錯誤訊息時，便會切換成執行單一訊息批次，並以這樣的方式執行一段時間，</span><span class="sxs-lookup"><span data-stu-id="e4451-207">If it hits an error, it must end the batch, but it switches to single-message batches for a short time as it gets past the bad message.</span></span> <span data-ttu-id="e4451-208">之後再還原成執行 100 個訊息的批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-208">It then reverts to 100-message batches.</span></span> <span data-ttu-id="e4451-209">如果配接器再次發生錯誤，執行速度也會再次變慢。</span><span class="sxs-lookup"><span data-stu-id="e4451-209">If it hits the error again, it slows down again.</span></span>  
  
-   <span data-ttu-id="e4451-210">**使用先佔式擱置。**</span><span class="sxs-lookup"><span data-stu-id="e4451-210">**Use preemptive suspension.**</span></span> <span data-ttu-id="e4451-211">建構事先擱置錯誤訊息的多訊息批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-211">Construct a multi-message batch in which the erroneous messages are preemptively suspended.</span></span> <span data-ttu-id="e4451-212">批次包含混合的**送出**和**MoveToSuspendQ**作業，且為第一個，在交易下的批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-212">The batch contains a mix of **Submit** and **MoveToSuspendQ** operations, and is the first and only batch under the transaction.</span></span> <span data-ttu-id="e4451-213">由於已事先擱置錯誤的資料，因此批次應該會成功，而交易也能獲得認可 (等候接收 BizTalk Server 的確認訊息之後)。</span><span class="sxs-lookup"><span data-stu-id="e4451-213">It should succeed because the bad data was preemptively suspended, and the transaction can be committed (after waiting to receive the confirmation from BizTalk Server).</span></span>  
  
     <span data-ttu-id="e4451-214">未來可能需要再進行深入研究，不過，此技術已經運用到 MSMQ 配接器。</span><span class="sxs-lookup"><span data-stu-id="e4451-214">This might seem to require looking into the future, but this technique has been used in the MSMQ adapter.</span></span> <span data-ttu-id="e4451-215">這取決於是否具有確實唯一的訊息識別碼。</span><span class="sxs-lookup"><span data-stu-id="e4451-215">It depends on having reliably unique message IDs.</span></span> <span data-ttu-id="e4451-216">此配接器會建構訊息的批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-216">This adapter constructs a batch of messages.</span></span> <span data-ttu-id="e4451-217">如果發生任何失敗，配接器會回復交易 (以及批次)，並且會在暫存資料結構中記住訊息識別碼</span><span class="sxs-lookup"><span data-stu-id="e4451-217">If anything fails it rolls back the transaction (and therefore the batch), but remembers the message ID in a temporary data structure.</span></span> <span data-ttu-id="e4451-218">(為了避免這個結構無限地擴大，在經過一段固定時間延遲之後，其中的項目就會遭到移除)。每個批次提交出去之前，配接器都會先查看錯誤訊息識別碼的清單。</span><span class="sxs-lookup"><span data-stu-id="e4451-218">(To prevent this structure from growing indefinitely, items in it are removed after some fixed time delay.) Before each batch is submitted, the adapter checks the list of bad message IDs.</span></span> <span data-ttu-id="e4451-219">如果配接器在清單中查到錯誤的訊息識別碼，即得知該訊息將會失敗 (因為以前曾經失敗過)，並且會事先將訊息擱置，而不會嘗試提交批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-219">If it sees one, it knows that message will fail (because it failed once in the past), and preemptively suspends it rather than trying to submit it.</span></span>  
  
     <span data-ttu-id="e4451-220">並非所有配接器都具有確實唯一的訊息識別碼，而交易式儲存區也不太可能會有這樣的訊息識別碼。</span><span class="sxs-lookup"><span data-stu-id="e4451-220">Not every adapter has a reliably unique message ID, and a transactional store is less likely to have one.</span></span> <span data-ttu-id="e4451-221">基於這個原因，許多交易式配接器都已限制成無法傳送單一訊息的批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-221">Because of this, many transactional adapters are restricted to sending single-message batches.</span></span>  
  
#### <a name="processing-other-errors"></a><span data-ttu-id="e4451-222">處理其他錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-222">Processing other errors</span></span>  
 <span data-ttu-id="e4451-223">在所有其他情況下 (例如擱置訊息的失敗)，配接器都必須結束交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-223">In all other cases (such as failures in suspending messages), the adapter must end the transaction.</span></span> <span data-ttu-id="e4451-224">任何其他結果可能會產生重複或捨棄的訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-224">Any other outcome results in either duplicate or dropped messages.</span></span>  
  
 <span data-ttu-id="e4451-225">只要在可能的情況下，一旦批次發生失敗，配接器都應該中止交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-225">Whenever the adapter can, it should abort the transaction if a batch fails.</span></span> <span data-ttu-id="e4451-226">然而，還是有配接器無法中止交易的實例。</span><span class="sxs-lookup"><span data-stu-id="e4451-226">However there are scenarios where the adapter cannot abort the transaction.</span></span> <span data-ttu-id="e4451-227">在這樣的實例中，配接器應該利用相同的交易來擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-227">In such a scenario it should suspend the message using the same transaction.</span></span>  
  
#### <a name="processing-errors-on-transactional-receive"></a><span data-ttu-id="e4451-228">處理交易式接收上的錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-228">Processing errors on transactional receive</span></span>  
 <span data-ttu-id="e4451-229">常見的交易式處理模式，是在發生錯誤時結束交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-229">A common transactional processing pattern is to end a transaction when an error occurs.</span></span> <span data-ttu-id="e4451-230">在這個情況中，所有事物都會回復到先前的狀態，並且不會遺失任何資料。</span><span class="sxs-lookup"><span data-stu-id="e4451-230">In this case everything returns to its previous state and no data is lost.</span></span> <span data-ttu-id="e4451-231">然而，如果您要使用交易式摘要中的資料 (例如一次從資料庫中的臨時資料表提取一列，或者一次從 MQSeries 或 MSMQ 之類的佇列產品提取一個訊息)，這對您來說可能不太夠。</span><span class="sxs-lookup"><span data-stu-id="e4451-231">However, if you are consuming data from a transactional feed (for example, pulling a row at a time from a staging table in a database, or pulling one message at a time from a queuing product like MQSeries or MSMQ), then this might not be enough.</span></span> <span data-ttu-id="e4451-232">如果您只是結束交易，返回後再收取相同的資料，那麼可能會發生相同的錯誤，並且系統會變成困在重複迴圈中。</span><span class="sxs-lookup"><span data-stu-id="e4451-232">If you simply end the transaction and go back and pick up the same data again, the same error is likely to occur and the system becomes stuck in a repeated loop.</span></span>  
  
 <span data-ttu-id="e4451-233">舊版 BizTalk Server 中的 SQL 配接器有這個行為。</span><span class="sxs-lookup"><span data-stu-id="e4451-233">The SQL adapter in an earlier version of BizTalk Server shipped with this behavior.</span></span> <span data-ttu-id="e4451-234">不過，在隨後發行的版本中，配接器的行為已變更成嘗試擱置失敗的訊息並認可交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-234">However, soon after release the adapter behavior was changed to attempt to suspend a failed message and commit the transaction.</span></span> <span data-ttu-id="e4451-235">如果將訊息移到相同交易下的擱置佇列，然後再認可交易，即可將資料儲存起來，免於遺失，同時，還能讓配接器取得以前的錯誤資料。</span><span class="sxs-lookup"><span data-stu-id="e4451-235">Moving a message to the Suspended queue under the same transaction and then committing the transaction saves the data from being lost and also allows the adapter to get past bad data.</span></span>  
  
 <span data-ttu-id="e4451-236">配接器的接收部分傳遞時的錯誤訊息以回應**送出**訊息作業時，配接器應該處理該錯誤，並將訊息移到擱置佇列。</span><span class="sxs-lookup"><span data-stu-id="e4451-236">When the receive portion of an adapter is passed an error message in response to a **Submit** message operation, the adapter should process that error and move the message to the Suspended queue.</span></span>  
  
 <span data-ttu-id="e4451-237">就配接器已經在交易下建立交易物件並提交訊息的交易式批次而言，當發生失敗時，配接器應該以邏輯方式將訊息移到相同交易下的擱置佇列中。</span><span class="sxs-lookup"><span data-stu-id="e4451-237">In the case of transactional batches in which the adapter has created the transaction object and submits messages under the transaction, the adapter should logically move the message to the Suspended queue under the same transaction when failures occur.</span></span> <span data-ttu-id="e4451-238">此交易可確保資料不會被捨棄，甚至是造成錯誤的資料也不會遭到捨棄。</span><span class="sxs-lookup"><span data-stu-id="e4451-238">The transaction ensures that data is not dropped, and even data that is causing an error should never be dropped.</span></span>  
  
### <a name="handle-messages-without-subscriptions"></a><span data-ttu-id="e4451-239">在沒有訂閱的情況下處理訊息</span><span class="sxs-lookup"><span data-stu-id="e4451-239">Handle Messages without Subscriptions</span></span>  
 <span data-ttu-id="e4451-240">BizTalk Server 在沒有定義接受訊息的訂閱時，不接受將訊息發佈到它的 MessageBox 資料庫中。</span><span class="sxs-lookup"><span data-stu-id="e4451-240">BizTalk Server does not accept a message to be published in its MessageBox database if there are no subscriptions defined to accept it.</span></span> <span data-ttu-id="e4451-241">註冊訂閱的方式為協調流程或傳送埠。</span><span class="sxs-lookup"><span data-stu-id="e4451-241">Subscriptions are registered by either orchestrations or send ports.</span></span> <span data-ttu-id="e4451-242">多數訂閱都可以經過定義，而且訊息會傳送到多個目的地。</span><span class="sxs-lookup"><span data-stu-id="e4451-242">Multiple subscriptions can be defined, in which case the message is sent to multiple destinations.</span></span> <span data-ttu-id="e4451-243">如果沒有訂閱，BizTalk Server 便會拒絕訊息，而且不會嘗試擱置該訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-243">If there are no subscriptions, BizTalk Server rejects the message and does not attempt to suspend it.</span></span> <span data-ttu-id="e4451-244">如果配接器未處理這個錯誤並明確地擱置訊息，那麼訊息便會遭到捨棄，部分的資料可能也會遺失。</span><span class="sxs-lookup"><span data-stu-id="e4451-244">If the adapter does not handle this error and explicitly suspend the message, then the message is dropped and its data is potentially lost.</span></span> <span data-ttu-id="e4451-245">當然，交易式配接器可能會結束交易，並將訊息傳回它的目的地。</span><span class="sxs-lookup"><span data-stu-id="e4451-245">Of course a transactional adapter may end the transaction and return the message to its destination.</span></span>  
  
### <a name="support-seek-with-your-receive-stream"></a><span data-ttu-id="e4451-246">利用您的接收資料流支援 Seek</span><span class="sxs-lookup"><span data-stu-id="e4451-246">Support Seek with Your Receive Stream</span></span>  
 <span data-ttu-id="e4451-247">接收端資料流必須支援**搜尋**方法，以便讓 BizTalk Server 能夠管線失敗時擱置訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-247">The receive-side stream must support the **Seek** method for BizTalk Server to be able to suspend the message on a pipeline failure.</span></span> <span data-ttu-id="e4451-248">如果訊息資料流不是可搜尋，則 BizTalk Server 會嘗試執行時，會產生錯誤**搜尋**。</span><span class="sxs-lookup"><span data-stu-id="e4451-248">If the message stream is not seekable, then BizTalk Server generates an error when it tries to run **Seek**.</span></span>  
  
 <span data-ttu-id="e4451-249">在許多情況下支援**搜尋**並不容易。</span><span class="sxs-lookup"><span data-stu-id="e4451-249">In many cases supporting **Seek** is not easy.</span></span> <span data-ttu-id="e4451-250">舉例來說，資料流處理網路中的資料時，可能難以返回網路資源並再次要求資料。</span><span class="sxs-lookup"><span data-stu-id="e4451-250">When streaming data from a network, for example, it may be difficult to go back to the network resource and request the data again.</span></span>  
  
 <span data-ttu-id="e4451-251">數個隨附於 BizTalk Server 的配接器會在 BizTalk Server 讀取訊息資料的同時，將該資料多工緩衝處理到磁碟上的檔案。</span><span class="sxs-lookup"><span data-stu-id="e4451-251">Several adapters that ship with BizTalk Server spool the message data onto a file on disk at the same time as BizTalk Server reads the data.</span></span> <span data-ttu-id="e4451-252">這可讓配接器使用**搜尋**對該檔案，如果發生錯誤 （在管線處理訊息資料，例如）。</span><span class="sxs-lookup"><span data-stu-id="e4451-252">This allows the adapter to use **Seek** on that file if it encounters an error (in the pipeline processing of the message data, for example).</span></span> <span data-ttu-id="e4451-253">配接器會在內部使用**ReadOnlySeekableStream**類別來包裝內送的不可搜尋資料流並溢位到磁碟時閾值可設定的大小。</span><span class="sxs-lookup"><span data-stu-id="e4451-253">Internally the adapter uses the **ReadOnlySeekableStream** class that wraps an incoming non-seekable stream and overflows to disk when a configurable size threshold is reached.</span></span> <span data-ttu-id="e4451-254">對於小於閾值大小的訊息，則不會達到磁碟。</span><span class="sxs-lookup"><span data-stu-id="e4451-254">For messages smaller than the threshold size, the disk is never hit.</span></span>  
  
### <a name="consider-user-configurable-error-handling-options"></a><span data-ttu-id="e4451-255">考慮使用者可設定的錯誤處理選項</span><span class="sxs-lookup"><span data-stu-id="e4451-255">Consider User-Configurable Error-Handling Options</span></span>  
 <span data-ttu-id="e4451-256">有時候可能沒有一個適當的回應能夠回應錯誤。</span><span class="sxs-lookup"><span data-stu-id="e4451-256">Sometimes there is no one correct response to an error.</span></span> <span data-ttu-id="e4451-257">在這個情形中，您應該考慮採用使用者可設定的選項來選擇行為。</span><span class="sxs-lookup"><span data-stu-id="e4451-257">In this case, you should consider a user-configurable option to choose between behaviors.</span></span> <span data-ttu-id="e4451-258">MQSeries 配接器即是如此。</span><span class="sxs-lookup"><span data-stu-id="e4451-258">The MQSeries adapter does this.</span></span>  
  
 <span data-ttu-id="e4451-259">一旦發生錯誤則配接器就會擱置訊息，其原因在於 BizTalk Server 中的擱置佇列在某種方面而言就如同「黑洞」一般。</span><span class="sxs-lookup"><span data-stu-id="e4451-259">The problem with having the adapter suspend messages when it sees an error is that the Suspended queue in BizTalk Server is something of a "black hole."</span></span> <span data-ttu-id="e4451-260">將訊息移入佇列比再次收取出來容易。</span><span class="sxs-lookup"><span data-stu-id="e4451-260">It is relatively easy to get messages into the queue, but harder to get them out again.</span></span>  
  
 <span data-ttu-id="e4451-261">某些配接器使用者可能不希望擱置佇列中有任何東西。</span><span class="sxs-lookup"><span data-stu-id="e4451-261">Some users of the adapter might not want anything in the Suspended queue.</span></span> <span data-ttu-id="e4451-262">舉例來說，MQSeries 配接器所提供的設定選項可讓使用者執行下列其中一個操作：</span><span class="sxs-lookup"><span data-stu-id="e4451-262">For example, in the case of the MQSeries adapter, the user is offered a configuration option to do one of the following:</span></span>  
  
-   <span data-ttu-id="e4451-263">設定配接器在看到錯誤時結束當時的交易，並且自行停用。</span><span class="sxs-lookup"><span data-stu-id="e4451-263">Set the adapter to end the current transaction and disable itself when it sees an error.</span></span>  
  
-   <span data-ttu-id="e4451-264">擱置失敗的訊息並認可交易。</span><span class="sxs-lookup"><span data-stu-id="e4451-264">Suspend the failed message and commit the transaction.</span></span> <span data-ttu-id="e4451-265">配接器甚至會在 BizTalk Server 已經成功擱置訊息的情況下執行此操作。</span><span class="sxs-lookup"><span data-stu-id="e4451-265">The adapter does this even when BizTalk Server has successfully suspended the message.</span></span> <span data-ttu-id="e4451-266">即使會造成事件記錄並非完全正確，這個動作還是符合客戶的需求。</span><span class="sxs-lookup"><span data-stu-id="e4451-266">This action meets the requirements of the customer even if it causes the event log to not be strictly correct.</span></span>  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a><span data-ttu-id="e4451-267">使用單一執行緒並等候 BatchComplete 以實作接收排序</span><span class="sxs-lookup"><span data-stu-id="e4451-267">Implement Receive Ordering by Using a Single Thread and Waiting on BatchComplete</span></span>  
 <span data-ttu-id="e4451-268">BizTalk Server 的介面是用來支援並行存取所擴充的效能和功能。</span><span class="sxs-lookup"><span data-stu-id="e4451-268">The interface to BizTalk Server is designed for performance and the ability to scale out by supporting concurrency.</span></span> <span data-ttu-id="e4451-269">然而，如果您希望完全依序接收訊息 (有時必須從 MQSeries 或 MSMQ 之類的訊息佇列產品接收訊息時)，則必須在配接器中執行一些額外的作業，以停用該並行存取。</span><span class="sxs-lookup"><span data-stu-id="e4451-269">However, if you want a strictly ordered receive of messages (as is sometimes required when receiving messages from a message queue product like MQSeries or MSMQ), then you must do some additional work in the adapter to disable some of that concurrency.</span></span> <span data-ttu-id="e4451-270">執行兩個步驟即可完成這個作業：</span><span class="sxs-lookup"><span data-stu-id="e4451-270">This can be done in two steps:</span></span>  
  
1.  <span data-ttu-id="e4451-271">您必須針對配接器中的所有資料處理使用單一執行緒。</span><span class="sxs-lookup"><span data-stu-id="e4451-271">You must use a single thread for all the data processing in the adapter.</span></span>  
  
2.  <span data-ttu-id="e4451-272">您必須等候 BizTalk Server 徹底地處理完每個批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-272">You must wait for BizTalk Server to completely process each batch.</span></span> <span data-ttu-id="e4451-273">這項需求非常重要，可以利用 .NET 執行緒同步基本來達成。</span><span class="sxs-lookup"><span data-stu-id="e4451-273">This requirement is important and can be accomplished by using .NET thread synchronization primitives.</span></span> <span data-ttu-id="e4451-274">例如，使用**AutoResetEvent**，就像：</span><span class="sxs-lookup"><span data-stu-id="e4451-274">For example, using an **AutoResetEvent**, you would:</span></span>  
  
    -   <span data-ttu-id="e4451-275">宣告事件物件，其中由主工作者執行緒存取和**BatchComplete**回呼物件。</span><span class="sxs-lookup"><span data-stu-id="e4451-275">Declare the event object where it can be accessed by both the main worker thread and the **BatchComplete** callback object.</span></span>  
  
    -   <span data-ttu-id="e4451-276">主工作者執行緒上、 將訊息提交到批次像往常一樣，但接著呼叫**Ibttransportbatch**之前的批次呼叫在事件物件上**ibttransportbatch:: Done**。</span><span class="sxs-lookup"><span data-stu-id="e4451-276">On the main worker thread, submit the messages to the batch as usual but then call **AutoResetEvent.Reset** on the event object just before the call to the batch **IBTTransportBatch::Done**.</span></span>  
  
    -   <span data-ttu-id="e4451-277">呼叫**AutoResetEvent.WaitOne**從這個相同的執行緒在事件物件上。</span><span class="sxs-lookup"><span data-stu-id="e4451-277">Call **AutoResetEvent.WaitOne** on the event object from this same thread.</span></span> <span data-ttu-id="e4451-278">這會導致封鎖主工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="e4451-278">This causees the main worker thread to block.</span></span> <span data-ttu-id="e4451-279">在**BatchComplete**回呼從 BizTalk Server 接著您便呼叫**AutoResetEvent.Set**解除封鎖該工作者執行緒，讓它已準備好處理另一個訊息在相同事件物件上。</span><span class="sxs-lookup"><span data-stu-id="e4451-279">In the **BatchComplete** callback from BizTalk Server you then call **AutoResetEvent.Set** on the same event object to unblock the worker thread so it is ready to process another message.</span></span>  
  
 <span data-ttu-id="e4451-280">強烈建議，*接收排序*像這可設定因為這會導致效能大幅降低。</span><span class="sxs-lookup"><span data-stu-id="e4451-280">It is strongly suggested that *receive ordering* like this be made configurable because it causes significant performance degradation.</span></span> <span data-ttu-id="e4451-281">許多使用者實例 (並非大多數) 不需要排序訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-281">Many, if not most, user scenarios do not require ordering of messages.</span></span> <span data-ttu-id="e4451-282">此外，擱置訊息可能會破壞排序順序。</span><span class="sxs-lookup"><span data-stu-id="e4451-282">Suspending messages can also break ordering.</span></span> <span data-ttu-id="e4451-283">在這個情形中要做的就是應用程式相依，對配接器而言最好的做法是提供使用者設定點。</span><span class="sxs-lookup"><span data-stu-id="e4451-283">Exactly what to do in this case is application-dependent, so the best thing for your adapter to do is to offer the user a configuration point.</span></span>  
  
 <span data-ttu-id="e4451-284">在排序的實例中，有些客戶已經表明他們偏好停止處理 (亦即停用配接器)，而不是破壞排序。</span><span class="sxs-lookup"><span data-stu-id="e4451-284">In ordered scenarios, some customers have stated that they would prefer to stop the processing, that is, disable the adapter, rather than break ordering.</span></span> <span data-ttu-id="e4451-285">支援排序接收的 MQSeries 配接器提供使用者這個選項。</span><span class="sxs-lookup"><span data-stu-id="e4451-285">The MQSeries adapter, which supports ordered receive, provides this option to the user.</span></span>  
  
## <a name="handle-send-specific-batch-errors"></a><span data-ttu-id="e4451-286">處理傳送特定的批次錯誤</span><span class="sxs-lookup"><span data-stu-id="e4451-286">Handle Send-Specific Batch Errors</span></span>  
  
### <a name="handle-send-retry-and-batching"></a><span data-ttu-id="e4451-287">處理傳送重試和批次處理</span><span class="sxs-lookup"><span data-stu-id="e4451-287">Handle Send Retry and Batching</span></span>  
 <span data-ttu-id="e4451-288">以下是傳送端批次處理的常見範例：</span><span class="sxs-lookup"><span data-stu-id="e4451-288">Here is a typical example of send-side batching:</span></span>  
  
-   <span data-ttu-id="e4451-289">BizTalk Server 提供訊息的批次給配接器。</span><span class="sxs-lookup"><span data-stu-id="e4451-289">BizTalk Server gives a batch of messages to the adapter.</span></span>  
  
-   <span data-ttu-id="e4451-290">當配接器判斷它已經正確地將訊息傳送到目的地時，就會在 BizTalk Server 上執行向後刪除，表示操作已完成</span><span class="sxs-lookup"><span data-stu-id="e4451-290">When the adapter determines that it has given the message to its destination correctly, it executes delete back on BizTalk Server indicating that it is done.</span></span> <span data-ttu-id="e4451-291">(通常可以任意批次處理數個刪除訊息，以改善效能)。</span><span class="sxs-lookup"><span data-stu-id="e4451-291">(As usual, several delete messages can be arbitrarily batched up to improve performance.)</span></span>  
  
 <span data-ttu-id="e4451-292">如果傳送端配接器無法處理訊息，那麼配接器可以利用該訊息執行下列其中一個步驟：</span><span class="sxs-lookup"><span data-stu-id="e4451-292">If the send-side adapter fails to process a message, then it may do one of several things with that message:</span></span>  
  
-   <span data-ttu-id="e4451-293">配接器應該告知 BizTalk Server 它需要重試訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-293">The adapter should tell BizTalk Server that it wants a message retried.</span></span> <span data-ttu-id="e4451-294">BizTalk Server 不會自動重試訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-294">BizTalk Server does not automatically retry a message.</span></span> <span data-ttu-id="e4451-295">BizTalk Server 會保留重試計數，而這個計數會顯示在訊息內容中。</span><span class="sxs-lookup"><span data-stu-id="e4451-295">BizTalk Server keeps a count of the retries, and this count can be seen in the message context.</span></span>  
  
-   <span data-ttu-id="e4451-296">配接器可能會判斷出它無法處理訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-296">The adapter may determine that it cannot process a message.</span></span> <span data-ttu-id="e4451-297">在這個情形中，配接器可能會將訊息移到下一個傳輸。</span><span class="sxs-lookup"><span data-stu-id="e4451-297">In this case, the adapter might move the message to the next transport.</span></span> <span data-ttu-id="e4451-298">配接器會運用**MoveToNextTransport**上呼叫**批次**物件。</span><span class="sxs-lookup"><span data-stu-id="e4451-298">The adapter does this with the **MoveToNextTransport** call on the **Batch** object.</span></span>  
  
-   <span data-ttu-id="e4451-299">配接器可以將訊息移到擱置佇列。</span><span class="sxs-lookup"><span data-stu-id="e4451-299">The adapter may move the message to the Suspended queue.</span></span>  
  
 <span data-ttu-id="e4451-300">配接器會判斷訊息發生哪些狀況。</span><span class="sxs-lookup"><span data-stu-id="e4451-300">The adapter determines what happens to the message.</span></span> <span data-ttu-id="e4451-301">不過，建議您有一致的方式運作，因為這樣會讓 BizTalk Server 安裝容易支援的介面卡。</span><span class="sxs-lookup"><span data-stu-id="e4451-301">However, it is recommended that you have adapters behave in a consistent manner because this makes a BizTalk Server installation easier to support.</span></span>  
  
 <span data-ttu-id="e4451-302">強烈建議配接器最好依照下列所述的方式執行。</span><span class="sxs-lookup"><span data-stu-id="e4451-302">It is highly recommended that adapters behave as described below.</span></span> <span data-ttu-id="e4451-303">隨附於 BizTalk Server 的配接器便具有這樣的行為。</span><span class="sxs-lookup"><span data-stu-id="e4451-303">The adapters shipped with BizTalk Server behave like this.</span></span>  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a><span data-ttu-id="e4451-304">處理批次中傳送錯誤的建議行為</span><span class="sxs-lookup"><span data-stu-id="e4451-304">Recommended Behavior for Handling Send Errors in a Batch</span></span>  
 <span data-ttu-id="e4451-305">傳送配接器會接收到一些訊息，並將那些訊息提交到 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="e4451-305">The send adapter receives some messages and submits them to BizTalk Server.</span></span>  
  
 <span data-ttu-id="e4451-306">配接器應該在 BizTalk Server 上刪除每個成功的訊息。</span><span class="sxs-lookup"><span data-stu-id="e4451-306">For each successful message the adapter should delete that message on BizTalk Server.</span></span> <span data-ttu-id="e4451-307">所有返回 BizTalk Server 的通訊是透過批次完成的，並且可以批次處理刪除。</span><span class="sxs-lookup"><span data-stu-id="e4451-307">All communication back to BizTalk Server is done through batches, and the deletes can be batched up.</span></span> <span data-ttu-id="e4451-308">它們不一定要是 BizTalk Server 在配接器上建立的相同批次。</span><span class="sxs-lookup"><span data-stu-id="e4451-308">They do not have to be the same batch that BizTalk Server created on the adapter.</span></span> <span data-ttu-id="e4451-309">如果還有任何回應訊息 (就像 SolicitResponse 實例)，便應該與相關的刪除一起提交回 BizTalk Server (使用 SubmitResponse)。</span><span class="sxs-lookup"><span data-stu-id="e4451-309">If there are any response messages (as in a SolicitResponse scenario), then they should be submitted back to BizTalk Server (with SubmitResponse) along with the associated delete.</span></span>  
  
-   <span data-ttu-id="e4451-310">如果配接器中的訊息處理不成功，請檢查重試計數。</span><span class="sxs-lookup"><span data-stu-id="e4451-310">If the message processing in the adapter was unsuccessful, check the retry count.</span></span>  
  
    -   <span data-ttu-id="e4451-311">如果未超過重試計數，請重新將訊息提交到 BizTalk Server，請記得在訊息上設定重試次數。</span><span class="sxs-lookup"><span data-stu-id="e4451-311">If the retry count was not exceeded, resubmit the message to BizTalk Server, remembering to set the retry time on the message.</span></span> <span data-ttu-id="e4451-312">訊息內容會提供配接器可以使用的重試計數和重試間隔。</span><span class="sxs-lookup"><span data-stu-id="e4451-312">The message context provides the retry count and the retry interval the adapter should use.</span></span>  
  
    -   <span data-ttu-id="e4451-313">如果已超過重試計數，則配接器應該嘗試將訊息移出使用**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="e4451-313">If the retry count was exceeded, then the adapter should attempt to move the message by using **MoveToNextTransport**.</span></span> <span data-ttu-id="e4451-314">重新提交和**MoveToNextTransport**訊息可以混合回 BizTalk Server 相同的批次中的刪除。</span><span class="sxs-lookup"><span data-stu-id="e4451-314">The resubmit and **MoveToNextTransport** messages can be mixed with the deletes in the same batch back to BizTalk Server.</span></span> <span data-ttu-id="e4451-315">雖然這不是必要操作，但卻是有用的步驟。</span><span class="sxs-lookup"><span data-stu-id="e4451-315">This is not required, but can be a useful step.</span></span>  
  
-   <span data-ttu-id="e4451-316">重新提交和**MoveToNextTransport**配接器處理失敗的方式。</span><span class="sxs-lookup"><span data-stu-id="e4451-316">The resubmit and the **MoveToNextTransport** are ways for the adapter to deal with failures.</span></span> <span data-ttu-id="e4451-317">不過失敗的處理中可能存在失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-317">But there can be a failure within the processing of the failure.</span></span> <span data-ttu-id="e4451-318">在此情況下，在處理 BizTalk 伺服器的回應 (在**BatchComplete**方法) 的配接器必須建立另一個批次，針對 BizTalk 伺服器，表示要如何處理該失敗。</span><span class="sxs-lookup"><span data-stu-id="e4451-318">In this case, in processing the response from BizTalk Server (in the **BatchComplete** method) the adapter must create another batch against BizTalk Server to indicate what to do with that failure.</span></span>  
  
     <span data-ttu-id="e4451-319">在處理其他失敗的處理內所發生的失敗時，請依照下列步驟執行：</span><span class="sxs-lookup"><span data-stu-id="e4451-319">Follow these steps when processing a failure that occurs within the processing of another failure:</span></span>  
  
    -   <span data-ttu-id="e4451-320">如果重新提交失敗，使用**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="e4451-320">If the resubmit fails, use **MoveToNextTransport**.</span></span>  
  
    -   <span data-ttu-id="e4451-321">如果**MoveToNextTransport**失敗，使用**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="e4451-321">If the **MoveToNextTransport** fails, use **MoveToSuspendQ**.</span></span>  
  
 <span data-ttu-id="e4451-322">您必須持續在 BizTalk Server 上建立批次，直到從 BizTalk Server 接收成功動作為止。</span><span class="sxs-lookup"><span data-stu-id="e4451-322">You must keep creating batches on BizTalk Server until you receive a successful action back on BizTalk Server.</span></span>  
  
### <a name="serialization-of-message-context-property"></a><span data-ttu-id="e4451-323">訊息內容屬性的序列化</span><span class="sxs-lookup"><span data-stu-id="e4451-323">Serialization of Message Context Property</span></span>  
 <span data-ttu-id="e4451-324">所有指派給訊息內容屬性的物件必須是可序列化的，</span><span class="sxs-lookup"><span data-stu-id="e4451-324">All objects assigned to a message context property must be serializable.</span></span> <span data-ttu-id="e4451-325">否則，傳訊引擎將會擲回例外狀況型別的**E_NOINTERFACE**。</span><span class="sxs-lookup"><span data-stu-id="e4451-325">Otherwise the Messaging Engine will throw an exception of type **E_NOINTERFACE**.</span></span> <span data-ttu-id="e4451-326">這個傳回值模糊代表試圖要指派訊息內容的非可序列化物件。</span><span class="sxs-lookup"><span data-stu-id="e4451-326">This return value ambiguously represents a non-serializable object attempting to be assigned the message context.</span></span>