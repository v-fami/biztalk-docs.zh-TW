---
title: "如何調查瓶頸 |Microsoft 文件"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 7ca22d07-d5fe-4dfb-8b52-3be3a95b0d6f
caps.latest.revision: "4"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: a6a3cf4630bf3269516537439ed58b464589cf26
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
---
# <a name="how-to-investigate-bottlenecks"></a><span data-ttu-id="d65be-102">如何調查瓶頸</span><span class="sxs-lookup"><span data-stu-id="d65be-102">How to Investigate Bottlenecks</span></span>
<span data-ttu-id="d65be-103">本主題說明如何調查瓶頸的建議程序。</span><span class="sxs-lookup"><span data-stu-id="d65be-103">This topic describes a recommended process for how to investigate bottlenecks.</span></span>  
  
## <a name="what-is-the-source-of-the-problem"></a><span data-ttu-id="d65be-104">問題根源為何？</span><span class="sxs-lookup"><span data-stu-id="d65be-104">What is the Source of the Problem?</span></span>  
 <span data-ttu-id="d65be-105">問題根源可能與硬體或軟體相關。</span><span class="sxs-lookup"><span data-stu-id="d65be-105">The source of the problem could be hardware or software related.</span></span> <span data-ttu-id="d65be-106">未充分利用資源通常表示系統中某處發生瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d65be-106">When resources are underutilized it is usually an indication of a bottleneck somewhere in the system.</span></span> <span data-ttu-id="d65be-107">造成瓶頸的可能原因是硬體限制或無效率的軟體組態或兩者。</span><span class="sxs-lookup"><span data-stu-id="d65be-107">Bottlenecks can be caused either due to hardware limitations or due to inefficient software configurations or both.</span></span>  
  
 <span data-ttu-id="d65be-108">識別瓶頸是一項遞增程序，解決一個瓶頸，可能導致下一個瓶頸被發現。</span><span class="sxs-lookup"><span data-stu-id="d65be-108">Identifying bottlenecks is an incremental process whereby alleviating one bottleneck can lead to the discovery of the next one.</span></span> <span data-ttu-id="d65be-109">識別和解決瓶頸的技術是本主題的目標。</span><span class="sxs-lookup"><span data-stu-id="d65be-109">The science of identifying and alleviating these bottlenecks is the objective of this topic.</span></span> <span data-ttu-id="d65be-110">系統在短時間內處於尖峰執行狀態，這種情形有可能發生。</span><span class="sxs-lookup"><span data-stu-id="d65be-110">It is possible for a system to perform at peaks for short periods of time.</span></span> <span data-ttu-id="d65be-111">不過，對持續性輸送量來說，系統最快只能用其最慢執行元件的速度處理。</span><span class="sxs-lookup"><span data-stu-id="d65be-111">However, for sustainable throughput a system can only process as fast as its slowest performing component.</span></span>  
  
## <a name="using-a-serial-approach"></a><span data-ttu-id="d65be-112">使用循序方法</span><span class="sxs-lookup"><span data-stu-id="d65be-112">Using a Serial Approach</span></span>  
 <span data-ttu-id="d65be-113">瓶頸可能在系統端點 (進入點/結束點) 或中間某處 (協調流程/資料庫) 發生。</span><span class="sxs-lookup"><span data-stu-id="d65be-113">Bottlenecks can occur at the endpoints (entry/exit) of the system or somewhere in the middle (orchestration/database).</span></span> <span data-ttu-id="d65be-114">在分離出瓶頸位置之後，可以採取結構化方式識別問題根源。</span><span class="sxs-lookup"><span data-stu-id="d65be-114">After the location of the bottleneck has been isolated a structured approach can be undertaken to identify the source.</span></span> <span data-ttu-id="d65be-115">在解決瓶頸之後，請務必再次測量效能，確保系統後面的其他位置未傳入新瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d65be-115">After the bottlenecks have been alleviated it is essential to measure performance again to ensure that a new bottleneck has not been introduced elsewhere in the system further down the line.</span></span>  
  
 <span data-ttu-id="d65be-116">識別和解決瓶頸的程序應該是循序方法，即每次只應變動一個參數，接著測量效能，驗證該單一變更的影響。</span><span class="sxs-lookup"><span data-stu-id="d65be-116">The process of identifying and fixing bottlenecks should be done in a serial manner whereby only one parameter at a time should be varied and then performance measured to verify the impact of that single change.</span></span> <span data-ttu-id="d65be-117">同時變動多個參數可能會掩蓋此變更的作用。</span><span class="sxs-lookup"><span data-stu-id="d65be-117">Varying more than one parameter at a time could conceal the effect of the change.</span></span>  
  
 <span data-ttu-id="d65be-118">例如，變更參數 1 可能改進效能，但同時變更參數 1 和參數 2 可能會有否定變更參數 1 之結果的不利影響，因此導致淨效果為零。</span><span class="sxs-lookup"><span data-stu-id="d65be-118">For example, changing parameter 1 could improve performance however, changing parameter 2 in conjunction with changing parameter 1 could have a detrimental effect negating the benefits of changing parameter 1 thus leading to a net zero effect.</span></span> <span data-ttu-id="d65be-119">然而，其結果則為漏報 (False Negative) 變更參數 1 的影響，以及誤報 (False Positive) 變更參數 2 的影響。</span><span class="sxs-lookup"><span data-stu-id="d65be-119">However, this results in a false negative on the effect of varying parameter 1 and a false positive on the effect of varying parameter 2.</span></span>  
  
## <a name="testing-consistency"></a><span data-ttu-id="d65be-120">測試一致性</span><span class="sxs-lookup"><span data-stu-id="d65be-120">Testing Consistency</span></span>  
 <span data-ttu-id="d65be-121">在變更設定之後，請務必測量效能特性，驗證變更的影響。</span><span class="sxs-lookup"><span data-stu-id="d65be-121">Measuring performance characteristics after changing settings is imperative to validate the effect of the change.</span></span>  
  
-   <span data-ttu-id="d65be-122">硬體： 請務必的使用一致的硬體，因為變更硬體即可顯示產生誤導的結果，例如不一致的行為不會使用膝上型電腦。</span><span class="sxs-lookup"><span data-stu-id="d65be-122">Hardware: It is important to use consistent hardware as varying the hardware can display inconsistent behavior producing misleading results e.g. do not use a laptop.</span></span>  
  
-   <span data-ttu-id="d65be-123">測試回合持續期間： 也很重要，測量效能以確保結果會確實可維持固定的最小週期和不只是尖峰。</span><span class="sxs-lookup"><span data-stu-id="d65be-123">Test Run Duration: It is also important to measure performance for a fixed minimum period to ensure that the results are indeed sustainable and not simply peaks.</span></span> <span data-ttu-id="d65be-124">長時間執行測試的另一個原因，是為了確保系統經歷初始的暖機/突發量期間，所有快取都能填入、資料庫資料表達到預期計數、有充分時間可以啟動節流，並在達到預先設定的閾值時立即調整輸送量。</span><span class="sxs-lookup"><span data-stu-id="d65be-124">Another reason to run tests for longer periods is to ensure that the system has gone through the initial warm/ramp up period where all caches are populated, database tables have reached expected counts and throttling is given sufficient time to kick in and regulate throughput once predefined thresholds are hit.</span></span> <span data-ttu-id="d65be-125">這種方法有助於探索最佳、持續性輸送量。</span><span class="sxs-lookup"><span data-stu-id="d65be-125">This approach will help discover optimal sustainable throughput.</span></span>  
  
-   <span data-ttu-id="d65be-126">測試參數： 請務必也之間不變更的測試參數，從測試回合。</span><span class="sxs-lookup"><span data-stu-id="d65be-126">Test Parameters: It is also imperative to not vary test parameters from test run to test run.</span></span> <span data-ttu-id="d65be-127">例如，變更對應的複雜性和 (或) 文件大小，可能會產生不同的輸送量和延遲結果。</span><span class="sxs-lookup"><span data-stu-id="d65be-127">For example, varying map complexity and/or document sizes can produce different throughput and latency results.</span></span>  
  
-   <span data-ttu-id="d65be-128">初始狀態： 完成測試之後務必的清除所有的狀態，然後再執行下一個測試執行。</span><span class="sxs-lookup"><span data-stu-id="d65be-128">Clean State: Once a test is complete it is important to cleanup all state before running the next test run.</span></span> <span data-ttu-id="d65be-129">例如，歷程記錄資料可能會在資料庫中增加，因此影響執行階段的輸送量。</span><span class="sxs-lookup"><span data-stu-id="d65be-129">For example, historical data can buildup in the database impacting runtime throughput.</span></span> <span data-ttu-id="d65be-130">回收服務執行個體有助於釋出快取資源，如記憶體、資料庫連線和執行緒。</span><span class="sxs-lookup"><span data-stu-id="d65be-130">Recycling the service instances help to release cached resources like memory, database connections and threads.</span></span>  
  
## <a name="expectations-throughput-versus-latency"></a><span data-ttu-id="d65be-131">期望： 輸送量和延遲的比較</span><span class="sxs-lookup"><span data-stu-id="d65be-131">Expectations: Throughput versus Latency</span></span>  
 <span data-ttu-id="d65be-132">部署的系統有特定輸送量和 (或) 延遲是合理預期。</span><span class="sxs-lookup"><span data-stu-id="d65be-132">It is reasonable to expect a certain amount of throughput and/or latency from the deployed system.</span></span> <span data-ttu-id="d65be-133">嘗試產生高輸送量和低延遲就像是往兩個不同方向拉扯。</span><span class="sxs-lookup"><span data-stu-id="d65be-133">Attempting to have both high throughput & low latency is like pulling in two different directions.</span></span> <span data-ttu-id="d65be-134">然而，最佳輸送量和合理延遲是比較符合現實的預期。</span><span class="sxs-lookup"><span data-stu-id="d65be-134">However it is realistic to expect optimal throughput with reasonable latency.</span></span> <span data-ttu-id="d65be-135">當輸送量提高時，會對系統造成更大的壓力 (CPU 高使用量、磁碟 IO 高爭用量、記憶體壓力、高鎖定爭用量)，因此對延遲造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="d65be-135">As throughput improves increased stress (higher CPU consumption, higher disk-IO contention, memory pressure, greater lock contention) is placed on the system which can have a negative impact on latency.</span></span> <span data-ttu-id="d65be-136">若要探索系統的最佳容量，一定要識別和解決所有瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d65be-136">To discover optimal capacity of a system it is imperative to identify and alleviate any and all bottlenecks.</span></span>  
  
 <span data-ttu-id="d65be-137">瓶頸可能由於資料庫中未清除的舊資料 (已完成的執行個體) 所導致。發生此狀況時效能會降低。</span><span class="sxs-lookup"><span data-stu-id="d65be-137">Bottlenecks can be caused by legacy data (completed instances) residing in the database not cleaned out. When this occurs performance can degrade.</span></span> <span data-ttu-id="d65be-138">讓系統有充分時間來清除，有助於減輕問題。</span><span class="sxs-lookup"><span data-stu-id="d65be-138">Giving the system sufficient time to drain can help alleviate the problem.</span></span> <span data-ttu-id="d65be-139">但是，探索積存增加的原因並解決問題則更為重要。</span><span class="sxs-lookup"><span data-stu-id="d65be-139">However, discovering the cause of the backlog buildup and helping alleviate the issue is important.</span></span>  
  
 <span data-ttu-id="d65be-140">若要探索積存的原因，請務必分析歷程記錄資料、監控「效能監視器」計數器 (以便探索使用模式並診斷積存的原因)。</span><span class="sxs-lookup"><span data-stu-id="d65be-140">To discover the cause of the backlog, it is important to analyze historical data, monitor Performance Monitor counters (to discover usage patterns, and diagnose the source of the backlog).</span></span> <span data-ttu-id="d65be-141">在一般狀況下，每晚都會以批次方式處理大量資料。</span><span class="sxs-lookup"><span data-stu-id="d65be-141">This is a common situation where large volumes of data are processed in a batched manner on a nightly basis.</span></span> <span data-ttu-id="d65be-142">探索系統的容量及其從積存復原的能力，有助於評估硬體需求以處理過度負載的狀況，以及系統內配合處理輸送量中非預期尖峰的緩衝區數量。</span><span class="sxs-lookup"><span data-stu-id="d65be-142">Discovering the capacity of the system and its ability to recover from a backlog can be useful in estimating hardware requirements for handling overdrive scenarios and the amount of buffer room to accommodate within a system to handle unforeseen spikes in throughput.</span></span>  
  
 <span data-ttu-id="d65be-143">若要微調系統以產生最佳、具持續性的輸送量，便需要深入了解部署的應用程式、在特定實例中系統和使用模式的強弱項。</span><span class="sxs-lookup"><span data-stu-id="d65be-143">Tuning the system for optimal sustainable throughput requires an in depth understanding of the application being deployed, the strengths and weaknesses of the system and usage patterns of the specific scenario.</span></span> <span data-ttu-id="d65be-144">探索瓶頸並可靠預測最佳、具持續性輸送量的唯一方法，是透過在最符合實際執行的拓撲上進行完整測試。</span><span class="sxs-lookup"><span data-stu-id="d65be-144">The only way to discover bottlenecks and predict optimal sustainable throughput with certainty is through thorough testing on a topology that closely matches what will be used in production.</span></span>  
  
 <span data-ttu-id="d65be-145">本節的其他主題將引導您執行定義該拓撲的程序，並提供有關如何解決瓶頸的指導，希望有助於預先避免瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d65be-145">Other topics in this section guides you through the process of defining that topology, and provides guidance on how to alleviate bottlenecks and hopefully help to avoid bottlenecks in the first place.</span></span>  
  
## <a name="scaling"></a><span data-ttu-id="d65be-146">擴充</span><span class="sxs-lookup"><span data-stu-id="d65be-146">Scaling</span></span>  
 <span data-ttu-id="d65be-147">在部署拓撲的各個階段都可能會發生瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d65be-147">Bottlenecks can occur at various stages of the deployed topology.</span></span> <span data-ttu-id="d65be-148">有些瓶頸可藉由升級硬體來解決問題。</span><span class="sxs-lookup"><span data-stu-id="d65be-148">Some bottlenecks can be addressed by upgrading hardware.</span></span> <span data-ttu-id="d65be-149">硬體升級有兩種方式：向上擴充 (更多 CPU、記憶體或快取) 和向外擴充 (更多的伺服器)。</span><span class="sxs-lookup"><span data-stu-id="d65be-149">Hardware can be upgraded either by scaling-up (more CPU’s, memory or cache) or by scaling-out (additional servers).</span></span> <span data-ttu-id="d65be-150">要向上/向外擴充取決於遇到的瓶頸類型和設定的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d65be-150">The decision to scale up/out depends on the type of bottleneck encountered and the application being configured.</span></span> <span data-ttu-id="d65be-151">以下將指示如何根據遇到的瓶頸來變更硬體部署拓撲。</span><span class="sxs-lookup"><span data-stu-id="d65be-151">The following will help with guidance on how to change hardware deployment topologies based on bottlenecks encountered.</span></span> <span data-ttu-id="d65be-152">應用程式必須根據這個定義建置，利用向上/向外擴充的優勢。例如：</span><span class="sxs-lookup"><span data-stu-id="d65be-152">An application needs to be built from the ground up to be capable of taking advantage of scaling up/out. For example:</span></span>  
  
-   <span data-ttu-id="d65be-153">如果應用程式已經序列化並且相依於單一執行緒，則增加 CPU 和 (或) 記憶體將伺服器向上擴充便無助於解決問題。</span><span class="sxs-lookup"><span data-stu-id="d65be-153">Scaling up a server with additional CPU’s and/or memory may not help alleviate the problem if the application is serialized and dependent on a single thread of execution.</span></span>  
  
-   <span data-ttu-id="d65be-154">如果更多的伺服器只不過是對無法擴充的一般資源增加爭用，則增加伺服器的向外擴充也沒有幫助。</span><span class="sxs-lookup"><span data-stu-id="d65be-154">Scaling out a system with additional servers may not help if the additional servers simply add contention on a common resource that cannot be scaled.</span></span> <span data-ttu-id="d65be-155">不過，向外擴充具有其他優點。</span><span class="sxs-lookup"><span data-stu-id="d65be-155">However, scaling-out provides additional benefits.</span></span> <span data-ttu-id="d65be-156">相較於一個四處理器伺服器，部署兩個雙處理器伺服器有助於提供備援伺服器，它可提供兩個用途：擴充處理額外的輸送量以及提供高可用性的拓撲。</span><span class="sxs-lookup"><span data-stu-id="d65be-156">Deploying two dual-proc servers instead of one quad-proc server helps provide a redundant server that serves the dual purpose of scaling to handle additional throughput and provides a highly available topology.</span></span>