---
title: "批次處理的訊息傳送處理 |Microsoft 文件"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 7d9115ec-13bc-41a8-8928-57b168c95af4
caps.latest.revision: "6"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e87600bec54679688fae5084af3b4a1bde9ca807
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
---
# <a name="batching-messages-for-send-processing"></a><span data-ttu-id="90788-102">批次處理傳送訊息</span><span class="sxs-lookup"><span data-stu-id="90788-102">Batching Messages for Send Processing</span></span>
## <a name="send-adapter-batch-management"></a><span data-ttu-id="90788-103">傳送配接器批次管理</span><span class="sxs-lookup"><span data-stu-id="90788-103">Send Adapter Batch Management</span></span>  
 <span data-ttu-id="90788-104">在傳送端使用交易時，由 BizTalk Server 建立用來傳送至目標系統的相同交易，會在成功傳送時用於刪除對應的訊息。</span><span class="sxs-lookup"><span data-stu-id="90788-104">When using transactions on the send side, the same transaction created by BizTalk Server and used for sending to the target system is used for the corresponding message deletion once it has been sent successfully.</span></span> <span data-ttu-id="90788-105">如果發生失敗，則會結束交易 (在此情況下會中止刪除訊息)，並且資料是保留在 BizTalk Server 而非目標系統。</span><span class="sxs-lookup"><span data-stu-id="90788-105">If anything fails, the transaction can be ended, in which case the deletion is aborted, and the data remains in BizTalk Server and not in the target system.</span></span> <span data-ttu-id="90788-106">這可防止訊息重複的情形。</span><span class="sxs-lookup"><span data-stu-id="90788-106">This prevents duplication of messages.</span></span> <span data-ttu-id="90788-107">只有非同步傳送配接器才支援交易，</span><span class="sxs-lookup"><span data-stu-id="90788-107">Transactions are only supported for asynchronous send adapters.</span></span> <span data-ttu-id="90788-108">您不應搭配同步傳送配接器使用交易。</span><span class="sxs-lookup"><span data-stu-id="90788-108">You should not use transactions with synchronous send adapters.</span></span>  
  
 <span data-ttu-id="90788-109">配接器不僅要結束交易，也必須正確處理所接收訊息的狀態。</span><span class="sxs-lookup"><span data-stu-id="90788-109">But the adapter cannot just end the transaction; it must also handle correctly the state of the messages it was given.</span></span> <span data-ttu-id="90788-110">具體來說，配接器應該呼叫方法**重新提交**， **MoveToNextTransport**，和**MoveToSuspendQ**根據重試計數以及是否使用備份傳輸。</span><span class="sxs-lookup"><span data-stu-id="90788-110">Specifically, the adapter should call the methods **Resubmit**, **MoveToNextTransport**, and **MoveToSuspendQ** appropriately depending upon the retry count and whether a backup transport is available.</span></span>  
  
 <span data-ttu-id="90788-111">請務必將**刪除**和**SubmitResponse**一起放在使用相同交易的批次作業。</span><span class="sxs-lookup"><span data-stu-id="90788-111">It is important to place the **Delete** and **SubmitResponse** operations together in a batch that uses the same transaction.</span></span> <span data-ttu-id="90788-112">失敗的處理方式是結束交易 (確定只提交一次資料給外部系統)。</span><span class="sxs-lookup"><span data-stu-id="90788-112">Failure is handled by ending the transaction (to ensure that data is only submitted once to an external system).</span></span> <span data-ttu-id="90788-113">但您仍然想要重新提交或呼叫**MoveToNextTransport**回 BizTalk Server 上的訊息。</span><span class="sxs-lookup"><span data-stu-id="90788-113">But you still want to resubmit or call **MoveToNextTransport** for the message back on BizTalk Server.</span></span> <span data-ttu-id="90788-114">若要執行此動作，請針對這些類型的作業使用個別的一般 (非交易式) 批次。</span><span class="sxs-lookup"><span data-stu-id="90788-114">To do this, use a separate normal (non-transactional) batch for these types of operations.</span></span>  
  
 <span data-ttu-id="90788-115">下圖顯示針對回應訊息使用個別批次。</span><span class="sxs-lookup"><span data-stu-id="90788-115">The following figure shows the use of separate batches for response messages.</span></span>  
  
 <span data-ttu-id="90788-116">![回應訊息使用個別的批次](../core/media/eawp-seperatebatch.gif "EAWP_SeperateBatch")</span><span class="sxs-lookup"><span data-stu-id="90788-116">![Using a seperate batch for response messages](../core/media/eawp-seperatebatch.gif "EAWP_SeperateBatch")</span></span>  
  
## <a name="sorting-the-send-side-transactional-batches-by-endpoint"></a><span data-ttu-id="90788-117">依端點來排序傳送端交易批次</span><span class="sxs-lookup"><span data-stu-id="90788-117">Sorting the Send-Side Transactional Batches by Endpoint</span></span>  
 <span data-ttu-id="90788-118">由 BizTalk Server 傳送至配接器的訊息批次可以跨越多個傳送埠 (或端點)。</span><span class="sxs-lookup"><span data-stu-id="90788-118">Batches of messages sent by BizTalk Server to the adapter can span multiple send ports (or endpoints).</span></span> <span data-ttu-id="90788-119">配接器通常會想要的單一端點進行交易，因為配接器必須排序依據傳送埠的訊息 (**SPName**或**OutboundTransportLocation**)。</span><span class="sxs-lookup"><span data-stu-id="90788-119">Because the adapter typically wants to have a transaction to a single endpoint, the adapter must sort the messages based on send port (**SPName** or **OutboundTransportLocation**).</span></span> <span data-ttu-id="90788-120">透過這個方式，配接器可以建立只跨越一個特定傳送埠的交易。</span><span class="sxs-lookup"><span data-stu-id="90788-120">By doing this, the adapter can create a transaction that spans only a particular send port.</span></span>  
  
 <span data-ttu-id="90788-121">例如，當 FTP 傳送配接器從 BizTalk Server 接收一批訊息時，它取得的是一批混合訊息，其中包含目前所有作用中 FTP 傳送埠的訊息。</span><span class="sxs-lookup"><span data-stu-id="90788-121">For example, when an FTP send adapter receives a batch of messages from BizTalk Server, it gets a mixed batch of messages for all the currently active FTP send ports.</span></span> <span data-ttu-id="90788-122">這是因為 API 是以單一項目為單位，這表示只會載入一個 FTP 配接器，而不是每個傳送埠各載入一個 FTP 配接器。</span><span class="sxs-lookup"><span data-stu-id="90788-122">This happens because the API is singleton based, meaning that only a single FTP adapter is loaded, not one per send port.</span></span>  
  
 <span data-ttu-id="90788-123">配接器必須先將 BizTalk Server 提供的該批訊息排序為個別批次，每個端點一個批次。</span><span class="sxs-lookup"><span data-stu-id="90788-123">The adapter must first sort the batch of messages it was given by BizTalk Server into separate batches, one for each endpoint.</span></span> <span data-ttu-id="90788-124">接著輪流處理每個端點，而且可能針對每個端點建構刪除批次。</span><span class="sxs-lookup"><span data-stu-id="90788-124">Then it can deal with each endpoint in turn and will probably construct delete batches for each endpoint.</span></span> <span data-ttu-id="90788-125">SDK 範例程式碼中的 BaseAdapter 可重複使用泛型類別就是以相同方式運作。</span><span class="sxs-lookup"><span data-stu-id="90788-125">The BaseAdapter generic reusable classes in the SDK sample code work in the same way.</span></span>  
  
## <a name="sorting-for-dynamic-send"></a><span data-ttu-id="90788-126">動態傳送的排序</span><span class="sxs-lookup"><span data-stu-id="90788-126">Sorting for Dynamic Send</span></span>  
 <span data-ttu-id="90788-127">只要訊息標頭和 URL 本身提供充分的組態詳細資料，BizTalk Server 協調流程就會將訊息傳送至未設定的連接埠。</span><span class="sxs-lookup"><span data-stu-id="90788-127">A BizTalk Server orchestration can send a message to a port that has not been configured as long as it provides sufficient configuration details in the message header and in the URL itself.</span></span> <span data-ttu-id="90788-128">BizTalk Server 必須識別 URL 的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="90788-128">BizTalk Server must recognize the protocol of the URL.</span></span>  
  
 <span data-ttu-id="90788-129">排序訊息時，您應謹慎建立端點的定義。</span><span class="sxs-lookup"><span data-stu-id="90788-129">When sorting messages, you should take care to establish what defines an endpoint.</span></span> <span data-ttu-id="90788-130">尤其在動態傳送時，更是如此。</span><span class="sxs-lookup"><span data-stu-id="90788-130">This is especially true in the case of a dynamic send.</span></span> <span data-ttu-id="90788-131">如果只有 URI 定義端點，情況便很簡單。</span><span class="sxs-lookup"><span data-stu-id="90788-131">If only the URI defines the endpoint, then things are simple.</span></span> <span data-ttu-id="90788-132">但在 FTP 工作階段中，FTP 伺服器可能會使用使用者名稱登入詳細資料，來定義真正的端點。</span><span class="sxs-lookup"><span data-stu-id="90788-132">However, in an FTP session the user name logon details might be used by the FTP server to define the true endpoint.</span></span> <span data-ttu-id="90788-133">在此情況下，如果配接器登入為不同帳戶，便可能會連接到不同目錄。</span><span class="sxs-lookup"><span data-stu-id="90788-133">In this case, if the adapter logs in as a different account, it may be connected to a different directory.</span></span>  
  
 <span data-ttu-id="90788-134">在某些情況下，真正的端點不知道您的企業單一登入 (SSO) 命令執行之前**ValidateAndRedeemTicket**。</span><span class="sxs-lookup"><span data-stu-id="90788-134">In some cases, the true endpoint is not known until you have run the Enterprise Single Sign-On (SSO) command **ValidateAndRedeemTicket**.</span></span>  
  
 <span data-ttu-id="90788-135">在 MQSeries 的情況中，判斷是否要使用交易是可設定的。</span><span class="sxs-lookup"><span data-stu-id="90788-135">In the case of MQSeries, the determination of whether to use transactions is configurable.</span></span> <span data-ttu-id="90788-136">有鑑於架構和遠端 COM+ 物件的使用，最好將交易式端點和非交易式端點視為不同。</span><span class="sxs-lookup"><span data-stu-id="90788-136">Given the architecture and the use of a remote COM+ object, it is best to regard a transactional endpoint as distinct from a non-transactional endpoint.</span></span>  
  
 <span data-ttu-id="90788-137">總而言之，有時將訊息排序為單一端點的批次是項重要工作，而且可能牽涉到額外的步驟，例如考慮內容值，甚至還要考慮 SSO 呼叫後的結果。</span><span class="sxs-lookup"><span data-stu-id="90788-137">To summarize, sorting messages into their single endpoint batches is sometimes a nontrivial task and may involve such extra steps as considering the context values and even the result of a call to SSO.</span></span>  
  
## <a name="sorting-for-static-send"></a><span data-ttu-id="90788-138">靜態傳送的排序</span><span class="sxs-lookup"><span data-stu-id="90788-138">Sorting for Static Send</span></span>  
 <span data-ttu-id="90788-139">如果是靜態設定的端點，訊息內容有唯一的 GUID，稱為靜態連接埠識別碼 (SPID)。</span><span class="sxs-lookup"><span data-stu-id="90788-139">If the endpoint is a statically configured endpoint there is a unique GUID on the message context called the static port ID (SPID).</span></span> <span data-ttu-id="90788-140">此值可用於排序端點。</span><span class="sxs-lookup"><span data-stu-id="90788-140">This value can be used for sorting the endpoint.</span></span> <span data-ttu-id="90788-141">下列程式碼可用來擷取它：</span><span class="sxs-lookup"><span data-stu-id="90788-141">The following code can be used to retrieve it:</span></span>  
  
```  
string spid = (string)message.Context.Read("SPID", "http://schemas.microsoft.com/BizTalk/2003/system-properties");  
```  
  
 <span data-ttu-id="90788-142">當您正視以「XML 結構描述定義」(XSD) 為基礎的組態架構引入的問題時，這將有所幫助。</span><span class="sxs-lookup"><span data-stu-id="90788-142">This is helpful when you consider the problems introduced by the XML Schema Definition (XSD)-based configuration framework.</span></span> <span data-ttu-id="90788-143">在這個架構中，屬性可能是埋在單一內容屬性之 XML 中端點索引鍵的一部分。</span><span class="sxs-lookup"><span data-stu-id="90788-143">With this framework, you have a property that might be part of the endpoint key buried inside XML in a single context property.</span></span> <span data-ttu-id="90788-144">如果您的內容有 SPID，可用它來排序批次。</span><span class="sxs-lookup"><span data-stu-id="90788-144">If you have a SPID on the context, you can use that as a way to sort the batch.</span></span> <span data-ttu-id="90788-145">否則，您執行的就是動態傳送，並且必須建構替代索引鍵，用它來排序批次。</span><span class="sxs-lookup"><span data-stu-id="90788-145">Otherwise you are doing a dynamic send and you need to construct an alternative key with which to sort the batch.</span></span>  
  
 <span data-ttu-id="90788-146">下圖顯示依端點的訊息排序。</span><span class="sxs-lookup"><span data-stu-id="90788-146">The following figure shows message sorting by endpoint.</span></span>  
  
 <span data-ttu-id="90788-147">![端點所排序的訊息](../core/media/eawp-sortbatch.gif "EAWP_SortBatch")</span><span class="sxs-lookup"><span data-stu-id="90788-147">![Sorting messages by endpoint](../core/media/eawp-sortbatch.gif "EAWP_SortBatch")</span></span>  
  
 <span data-ttu-id="90788-148">請記住，訊息的重試計數不知道批次是成功還是失敗。</span><span class="sxs-lookup"><span data-stu-id="90788-148">Remember that the retry count of a message is not aware of the success or failure of a batch.</span></span> <span data-ttu-id="90788-149">在傳送端，訊息批次可能因為批次中的少數訊息失敗而造成失敗。</span><span class="sxs-lookup"><span data-stu-id="90788-149">On the send side, a batch of messages may fail because a few messages in the batch have failed.</span></span> <span data-ttu-id="90788-150">配接器必須判斷它所接收每個訊息的狀態。</span><span class="sxs-lookup"><span data-stu-id="90788-150">The adapter must make a determination for every message that it receives.</span></span> <span data-ttu-id="90788-151">在失敗批次的案例中，您可能假設每個訊息都要重新提交。</span><span class="sxs-lookup"><span data-stu-id="90788-151">In the failed batch scenario, you might assume that every message is resubmitted.</span></span> <span data-ttu-id="90788-152">不過，如果重新提交失敗批次中的所有訊息，因為成功訊息和失敗訊息在相同批次中，即使針對成功訊息，重試計數 (由 BizTalk Server 引擎維護) 都會不正確地遞增。</span><span class="sxs-lookup"><span data-stu-id="90788-152">However, if all the messages in a failing batch are resubmitted, the retry count (which is maintained by the BizTalk Server engine) is incorrectly incremented even for the successful messages because they happen to be in the same batch as the failed messages.</span></span> <span data-ttu-id="90788-153">在此情況下，配接器可能會重新形成輸出批次，並且對外部系統重試成功訊息。</span><span class="sxs-lookup"><span data-stu-id="90788-153">In this case, an adapter could reform the outbound batch and retry the successful messages against the external system.</span></span>