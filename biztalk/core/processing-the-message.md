---
title: "處理訊息 |Microsoft 文件"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- processing
- messages, pipelines
- routing, about routing
- adapters, about adapters
- routing, message types
- processing, messages
- messages, processing
- routing
- messages, routing
- pipelines, about pipelines
- message types
- messages, message types
- messages, adapters
ms.assetid: e6d1f969-20c9-41f6-85cb-46cf92656348
caps.latest.revision: "13"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 829fffc773bfc19100ad03448baf68b5846996f7
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
---
# <a name="processing-the-message"></a><span data-ttu-id="d0155-102">處理訊息</span><span class="sxs-lookup"><span data-stu-id="d0155-102">Processing the Message</span></span>
<span data-ttu-id="d0155-103">到目前為止所描述的所有元件，都會負責在訊息流過 BizTalk Server 時處理訊息。</span><span class="sxs-lookup"><span data-stu-id="d0155-103">All of the components described so far play a part in the processing of messages as they flow through BizTalk Server.</span></span> <span data-ttu-id="d0155-104">本節提供這些元件從接收訊息開始，在功能上如何互動的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d0155-104">This section provides more detail about how these components interact functionally, beginning with receiving a message.</span></span> <span data-ttu-id="d0155-105">下圖說明接收埠的組成方式，以及透過接收程序的訊息流程。</span><span class="sxs-lookup"><span data-stu-id="d0155-105">The following figure shows the make-up of a receive port and the flow of a message through the receive process.</span></span>  
  
 <span data-ttu-id="d0155-106">*接收埠* 包含一或多個接收位置，以及零或多個對應。</span><span class="sxs-lookup"><span data-stu-id="d0155-106">A *receive port* consists of one or more receive locations and zero or more maps.</span></span> <span data-ttu-id="d0155-107">對應是「可延伸樣式表語言轉換」(XSLT) 樣式表，用來將 XML 訊息從一個結構或格式轉換成另一個，並且經常用於接收程序中，以便將訊息正規化為內部格式。</span><span class="sxs-lookup"><span data-stu-id="d0155-107">Maps are Extensible Stylesheet Language Transformations (XSLT) style sheets used to transform XML messages from one structure or format to another and are often used in the receive process to normalize messages into an internal format.</span></span> <span data-ttu-id="d0155-108">接收位置會控制接收訊息的結束點。</span><span class="sxs-lookup"><span data-stu-id="d0155-108">Receive locations control the endpoints that receive the messages.</span></span> <span data-ttu-id="d0155-109">接收位置包含接收配接器和接收管線之結束點的組態。</span><span class="sxs-lookup"><span data-stu-id="d0155-109">A receive location consists of the configuration of an endpoint for a receive adapter, and a receive pipeline.</span></span>  
  
 <span data-ttu-id="d0155-110">![接收埠結構和處理](../core/media/arch-message-processing.gif "arch_message_processing")</span><span class="sxs-lookup"><span data-stu-id="d0155-110">![Receive port structure and processing](../core/media/arch-message-processing.gif "arch_message_processing")</span></span>  
  
## <a name="the-role-of-the-adapter"></a><span data-ttu-id="d0155-111">配接器的角色</span><span class="sxs-lookup"><span data-stu-id="d0155-111">The Role of the Adapter</span></span>  
 <span data-ttu-id="d0155-112">接收配接器藉由讀取資料流和建立訊息，來初始化接收訊息的程序。</span><span class="sxs-lookup"><span data-stu-id="d0155-112">The receive adapter initiates the process of receiving messages by reading a stream of data and creating a message.</span></span> <span data-ttu-id="d0155-113">例如，檔案配接器會查看已放置於其設定位置中的檔案，並於資料流中讀取該檔案。</span><span class="sxs-lookup"><span data-stu-id="d0155-113">For example, the file adapter sees that a file has been placed in its configured location and reads that file in a stream.</span></span> <span data-ttu-id="d0155-114">配接器會建立一個訊息 (Microsoft.BizTalk.Message.Interop.IBaseMessage 介面的實作)、新增一部分到其中 (Microsoft.BizTalk.Message.Interop.IBasePart 介面的實作)，並提供資料流做為部分內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-114">The adapter creates a message (an implementation of the Microsoft.BizTalk.Message.Interop.IBaseMessage interface), adds a part to it (an implementation of the Microsoft.BizTalk.Message.Interop.IBasePart interface), and provides the stream of data as the part content.</span></span>  
  
 <span data-ttu-id="d0155-115">此外，配接器會寫入並升級到與位置、配接器類型及與配接器相關之其他資訊相關的訊息內容屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-115">In addition, the adapter writes and promotes into the message context properties related to the location, adapter type, and others related to the adapter.</span></span> <span data-ttu-id="d0155-116">在訊息與其內容建立之後，配接器會將訊息傳遞到「結束點管理員」。</span><span class="sxs-lookup"><span data-stu-id="d0155-116">After the message and its context have been created, the adapter passes the message to the Endpoint Manager.</span></span> <span data-ttu-id="d0155-117">接著會透過已針對接收位置設定的接收管線來處理訊息。</span><span class="sxs-lookup"><span data-stu-id="d0155-117">The message is then processed through the receive pipeline, which has been configured for the receive location.</span></span> <span data-ttu-id="d0155-118">管線處理訊息之後，可以在「結束點管理員」使用「訊息代理程式」發佈訊息之前，先使用對應將訊息轉換成所需的格式。</span><span class="sxs-lookup"><span data-stu-id="d0155-118">After the message has been processed by the pipeline, a map may be used to transform the message into the format desired before the Endpoint Manager publishes the message with the Message Agent.</span></span>  
  
## <a name="the-role-of-the-pipeline"></a><span data-ttu-id="d0155-119">管線的角色</span><span class="sxs-lookup"><span data-stu-id="d0155-119">The Role of the Pipeline</span></span>  
 <span data-ttu-id="d0155-120">雖然這是建立初始訊息的配接器，但在已接收之訊息上進行的大部分處理，都是發生在接收管線中。</span><span class="sxs-lookup"><span data-stu-id="d0155-120">While it is the adapter that creates the initial message, most of the processing that occurs on a received message happens in the receive pipeline.</span></span> <span data-ttu-id="d0155-121">管線會處理訊息內文及訊息內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-121">Pipeline processing deals with message content as well as message context.</span></span> <span data-ttu-id="d0155-122">訊息內文 (Message Content) 一般會在解碼、解譯和驗證階段中處理，而訊息內容 (Message Context) 則可以在所有階段中處理。</span><span class="sxs-lookup"><span data-stu-id="d0155-122">Message content is generally handled in the decoding, disassembling, and validating stages, while message context can be handled in all stages.</span></span> <span data-ttu-id="d0155-123">不過，管線不一定會在內文或內容中發揮作用。</span><span class="sxs-lookup"><span data-stu-id="d0155-123">A pipeline, however, does not necessarily act on either the content or the context.</span></span> <span data-ttu-id="d0155-124">例如，預設的通過管線沒有設定任何元件，且不會在訊息內文或內容上執行任何處理。</span><span class="sxs-lookup"><span data-stu-id="d0155-124">For example, the default pass-through pipeline has no components configured and performs no processing on the message content or context.</span></span> <span data-ttu-id="d0155-125">為了簡化起見，本文件會著重於解譯元件，因為它們通常對於訊息路由會有最大的影響。</span><span class="sxs-lookup"><span data-stu-id="d0155-125">For simplicity, this document focuses on the disassembling components as they generally have the greatest impact on message routing.</span></span>  
  
 <span data-ttu-id="d0155-126">*解譯器* 的工作是處理來自配接器的內送訊息，並將訊息解譯成許多訊息，並剖析訊息資料。</span><span class="sxs-lookup"><span data-stu-id="d0155-126">The job of the *disassembler* is to process an incoming message from an adapter and to disassemble it into many messages, and parse the message data.</span></span> <span data-ttu-id="d0155-127">當內送訊息擁有很多較小的訊息時，這就是所謂的 *交換*。</span><span class="sxs-lookup"><span data-stu-id="d0155-127">When an incoming message has many smaller messages, this is known as an *interchange*.</span></span> <span data-ttu-id="d0155-128">一般檔案解譯器和 XML 解譯器處理交換，讓開發人員設定 （也就是標頭和結尾一般檔案解譯器結構描述和信封結構描述之 XML 的換行內容的相關資訊解譯器） 和 （可能會重複） 的本文內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-128">Both the flat file disassembler and the XML disassembler handle interchanges by enabling a developer to configure information about the wrapping content (that is, a header and trailing schema for the flat file disassembler and an envelope schema for the XML disassembler) and the (potentially repeating) body content.</span></span> <span data-ttu-id="d0155-129">此外，這些解譯器都會將原始訊息剖析為 XML 內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-129">In addition, both of these disassemblers parse the original message into XML content.</span></span> <span data-ttu-id="d0155-130">若不需要在 BizTalk Server 中進一步處理 XML，自訂解譯器不一定要將內容剖析為 XML。</span><span class="sxs-lookup"><span data-stu-id="d0155-130">A custom disassembler does not necessarily parse the content into XML if further XML processing in BizTalk Server is not required.</span></span> <span data-ttu-id="d0155-131">範例實例可能包括一個簡單路由狀況，也就是在特定接收位置進入系統的訊息，會傳送到沒有對應或其他以 XML 為基礎之處理的特定傳送埠。</span><span class="sxs-lookup"><span data-stu-id="d0155-131">An example scenario might include a simple routing situation in which messages entering the system at a particular receive location are sent to a specific send port with no mapping or other XML-based processing.</span></span>  
  
## <a name="routing-with-the-message-type"></a><span data-ttu-id="d0155-132">具有訊息類型的路由</span><span class="sxs-lookup"><span data-stu-id="d0155-132">Routing with the Message Type</span></span>  
 <span data-ttu-id="d0155-133">路由中所用的最常見訊息屬性之一是訊息類型。</span><span class="sxs-lookup"><span data-stu-id="d0155-133">One of the most common message properties used in routing is the message type.</span></span> <span data-ttu-id="d0155-134">當開發人員建立結構描述來定義訊息結構時，這個結構描述會定義該訊息的訊息類型。</span><span class="sxs-lookup"><span data-stu-id="d0155-134">When a developer creates a schema to define the structure of messages, this schema defines the message type for that message.</span></span> <span data-ttu-id="d0155-135">類型是由根節點和命名空間在結構描述定義中所決定。</span><span class="sxs-lookup"><span data-stu-id="d0155-135">The type is determined by the root node and namespace in the schema definition.</span></span> <span data-ttu-id="d0155-136">例如，如下所示的 XML 文件將擁有 http://tempuri.org/samples/MessageType#Message 的訊息類型</span><span class="sxs-lookup"><span data-stu-id="d0155-136">For example, an XML document that looks like the following would have a message type of http://tempuri.org/samples/MessageType#Message</span></span>  
  
```  
<Message xmlns=http://tempuri.org/samples/MessageType>  
<SomeOtherElement type="sample"/>  
</Message>  
```  
  
 <span data-ttu-id="d0155-137">若要在路由中使用訊息類型，它必須升級到內容中。</span><span class="sxs-lookup"><span data-stu-id="d0155-137">To use message type in routing, it must be promoted into the context.</span></span> <span data-ttu-id="d0155-138">解譯器是用來將這個值升級到訊息內容，以及具有訊息結構最適用資訊的管線元件。</span><span class="sxs-lookup"><span data-stu-id="d0155-138">Disassemblers are used to promote this value into the message context as well as the pipeline components with the most specific knowledge of message structure.</span></span> <span data-ttu-id="d0155-139">XML 和一般檔案解譯器在處理訊息時會升級訊息類型，而所有的自訂解譯器也應該升級這個屬性，以確保正確的路由。</span><span class="sxs-lookup"><span data-stu-id="d0155-139">The XML and Flat File disassemblers promote the message type as they are processing messages, and any custom disassembler should also promote this property to ensure proper routing.</span></span>  
  
 <span data-ttu-id="d0155-140">請務必注意，訊息不一定要有一個類型。</span><span class="sxs-lookup"><span data-stu-id="d0155-140">It is important to note that a message is not required to have a type.</span></span> <span data-ttu-id="d0155-141">如先前所提及，訊息的部分可以是任何的二進位資料，而且不需要有定義其結構的結構描述。</span><span class="sxs-lookup"><span data-stu-id="d0155-141">As mentioned previously, the parts of a message can be any binary data and need not have a schema that defines their structure.</span></span> <span data-ttu-id="d0155-142">這類型的訊息部分一般會通過 BizTalk Server 而不會讓 BizTalk Server 本身進行太多 (如果有的話) 處理，雖然自訂管線元件、配接器或從協調流程呼叫的程式碼可能會與這些部分互動。</span><span class="sxs-lookup"><span data-stu-id="d0155-142">This type of message part is generally passed through BizTalk Server without much, if any, processing done on it by BizTalk Server itself, though custom pipeline components, adapters, or code called from orchestrations may interact with these parts.</span></span>  
  
 <span data-ttu-id="d0155-143">配接器這類的管線元件也會寫入並升級屬性為訊息內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-143">Pipeline components, like adapters, also write and promote properties into the message context.</span></span> <span data-ttu-id="d0155-144">事實上，管線元件是大部分開發人員最常用來將屬性放入訊息內容的機制。</span><span class="sxs-lookup"><span data-stu-id="d0155-144">In fact, pipeline components are the most common mechanism most developers use to get properties into the message context.</span></span> <span data-ttu-id="d0155-145">開發人員會建立結構描述，並可在結構描述中升級屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-145">Developers create schemas and can promote properties in the schema.</span></span> <span data-ttu-id="d0155-146">這個資訊會儲存在結構描述中做為註解，屆時可供管線元件使用。</span><span class="sxs-lookup"><span data-stu-id="d0155-146">This information is stored in the schema as annotations which can then be used by pipeline components.</span></span> <span data-ttu-id="d0155-147">所有內建解譯器和組合器元件 (FlatFile、XML 和 BizTalk Framework)，都會使用文件結構描述，來擷取即將升級之屬性的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d0155-147">All of the built-in disassembler and assembler components - FlatFile, XML, and BizTalk Framework - use the document schema to retrieve information about the properties that are to be promoted.</span></span> <span data-ttu-id="d0155-148">使用註解中的 XML 路徑語言 (XPath) 陳述式，解譯器即可知道要升級之項目文件的位置。</span><span class="sxs-lookup"><span data-stu-id="d0155-148">Using the XML Path Language (XPath) statement from the annotations, the disassembler knows the location in the document of elements to be promoted.</span></span> <span data-ttu-id="d0155-149">在處理透過文件的資料流期間，解譯器會尋找符合其中一個 XPath 陳述式的這些項目，然後在適當的時候將這個值升級或寫入內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-149">During the process of streaming through the document, the disassembler finds those elements that match one of the XPath statements and promotes or writes the value into the context as appropriate.</span></span>  
  
 <span data-ttu-id="d0155-150">自訂管線元件，則也可以寫入處理已接收或傳送的訊息中的任意資料的內容取得的屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-150">Custom pipeline components can also be written to handle getting properties into the context for arbitrary data in a received or sent message.</span></span> <span data-ttu-id="d0155-151">為了將屬性升級到內容，並讓它用於路由 (這可能是要將值升級的原因)，應該建立具有屬性定義的屬性結構描述，並部署到 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="d0155-151">In order to promote a property into the context and have it be useful for routing, which is presumably why the value is being promoted, a property schema with a definition for the property should be created and deployed to BizTalk Server.</span></span> <span data-ttu-id="d0155-152">在您定義屬性結構描述以用於自訂元件之前，應該先瞭解不同類型的升級屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-152">Before you define a property schema to be used by custom components, you should understand the different types of promoted properties.</span></span> <span data-ttu-id="d0155-153">在屬性結構描述中定義的升級屬性可以有下列其中一種基底類型：</span><span class="sxs-lookup"><span data-stu-id="d0155-153">Promoted properties defined in a property schema can have one of two base types:</span></span>  
  
-   <span data-ttu-id="d0155-154">[Microsoft.XLANGs.BaseTypes.MessageContextPropertyBase](http://msdn.microsoft.com/library/microsoft.xlangs.basetypes.messagecontextpropertybase.aspx) 或</span><span class="sxs-lookup"><span data-stu-id="d0155-154">[Microsoft.XLANGs.BaseTypes.MessageContextPropertyBase](http://msdn.microsoft.com/library/microsoft.xlangs.basetypes.messagecontextpropertybase.aspx) or</span></span>  
  
-   [<span data-ttu-id="d0155-155">Microsoft.XLANGs.BaseTypes.MessageDataPropertyBase</span><span class="sxs-lookup"><span data-stu-id="d0155-155">Microsoft.XLANGs.BaseTypes.MessageDataPropertyBase</span></span>](http://msdn.microsoft.com/library/microsoft.xlangs.basetypes.messagedatapropertybase.messagedatapropertybase.aspx)  
  
 <span data-ttu-id="d0155-156">具有基底類型 MessageDataPropertyBase 的屬性表示這個屬性的值來自訊息內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-156">A property with a base type of MessageDataPropertyBase indicates that the value for this property comes from the content of the message.</span></span> <span data-ttu-id="d0155-157">這是在屬性結構描述中定義的屬性預設值，並且是最常見的用法。</span><span class="sxs-lookup"><span data-stu-id="d0155-157">This is the default value for properties defined in a property schema and is the most common usage.</span></span> <span data-ttu-id="d0155-158">MessageContextPropertyBase 表示屬性是用來做為訊息內容的一部分，但不一定是直接來自訊息資料。</span><span class="sxs-lookup"><span data-stu-id="d0155-158">MessageContextPropertyBase indicates a property that is intended to be part of the message context but does not necessarily come from the message data directly.</span></span> <span data-ttu-id="d0155-159">具有 MessageContextPropertyBase 做為其基底類型的屬性經常是由配接器和解譯器所升級，並包含訊息類型和配接器類型這類的通用屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-159">Properties with MessageContextPropertyBase as their base type are often promoted by adapters and disassemblers and include common properties such as message type and adapter type.</span></span>  
  
 <span data-ttu-id="d0155-160">瞭解不同類型，並在定義屬性時適當地加以使用，是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="d0155-160">It is important to understand the different types and use them appropriately when defining properties.</span></span> <span data-ttu-id="d0155-161">一個最為明顯的暗示會發生於在協調流程中存取訊息的內容屬性時。</span><span class="sxs-lookup"><span data-stu-id="d0155-161">One of the most significant implications occurs when accessing context properties for a message in an orchestration.</span></span> <span data-ttu-id="d0155-162">若屬性識別為 MessageDataPropertyBase，「協調流程設計師」會檢查正在接收之訊息的結構描述，並確保它會定義符合的升級屬性。</span><span class="sxs-lookup"><span data-stu-id="d0155-162">If a property is identified as a MessageDataPropertyBase, the Orchestration Designer examines the schema of the message being received and ensures that it defines a matching promoted property.</span></span> <span data-ttu-id="d0155-163">若結構描述中找不到繫結至要存取之升級屬性的屬性，那麼「設計師」將不允許您進行存取。</span><span class="sxs-lookup"><span data-stu-id="d0155-163">If no property is found in the schema tied to the promoted property being accessed, then the Designer does not allow you to access it.</span></span> <span data-ttu-id="d0155-164">另一方面，若屬性是定義為 MessageContextPropertyBase，訊息類型就不重要，而屬性便可存取。</span><span class="sxs-lookup"><span data-stu-id="d0155-164">On the other hand, if the property is defined as being a MessageContextPropertyBase, the message type does not matter and the property can be accessed.</span></span>  
  
 <span data-ttu-id="d0155-165">在自訂管線中，將屬性升級或寫入到內容的機制是非常相似的。</span><span class="sxs-lookup"><span data-stu-id="d0155-165">In custom pipelines, the mechanism for promoting or writing properties to the context is very similar.</span></span> <span data-ttu-id="d0155-166">對於寫入屬性，您可以使用 IBaseMessageContext Write 方法的呼叫，將值放入內容中。</span><span class="sxs-lookup"><span data-stu-id="d0155-166">For writing properties, you use a call to the IBaseMessageContext Write method to place the value in the context.</span></span> <span data-ttu-id="d0155-167">對於升級屬性，您只需改用 IBaseMessageContext Promote 方法即可。</span><span class="sxs-lookup"><span data-stu-id="d0155-167">For promoted properties, you simply use the IBaseMessageContext Promote method instead.</span></span> <span data-ttu-id="d0155-168">這些方法的每一個都會採用一個屬性名稱、命名空間及值。</span><span class="sxs-lookup"><span data-stu-id="d0155-168">Each of these methods takes a property name, a namespace, and value.</span></span> <span data-ttu-id="d0155-169">對於升級屬性，名稱與命名空間是在屬性結構描述中定義的那些屬性，藉由參考屬性結構描述組件，並使用針對該屬性所建立之類別上的屬性，就能夠以最輕鬆的方式來存取。</span><span class="sxs-lookup"><span data-stu-id="d0155-169">For the promoted properties, the name and namespace are those of the property defined in the property schema and are most easily accessed by referencing the property schema assembly and using the properties on the class created for the property.</span></span> <span data-ttu-id="d0155-170">辨別欄位會使用通用的命名空間 http://schemas.microsoft.com/BizTalk/2003/btsDistinguishedFields，而用來擷取值的 XPath 運算式通常會當做名稱來使用。</span><span class="sxs-lookup"><span data-stu-id="d0155-170">Distinguished fields use a common namespace, http://schemas.microsoft.com/BizTalk/2003/btsDistinguishedFields, and the XPath expression used to retrieve the value is usually used as the name.</span></span>  
  
 <span data-ttu-id="d0155-171">下列程式碼顯示升級屬性並將其寫入內容的範例。</span><span class="sxs-lookup"><span data-stu-id="d0155-171">The code below shows an example of both promoting and writing properties into the context.</span></span> <span data-ttu-id="d0155-172">請注意，在這個範例中，識別欄位正在寫入內容中。</span><span class="sxs-lookup"><span data-stu-id="d0155-172">Note that in this example, a distinguished field is being written into the context.</span></span> <span data-ttu-id="d0155-173">這只對訊息結構描述識別辨別欄位的協調流程有用，如此一來「協調流程設計師」就會知道這個欄位。</span><span class="sxs-lookup"><span data-stu-id="d0155-173">This is only useful for orchestrations in which the message schema identifies the distinguished field so that the Orchestration Designer knows about the field.</span></span> <span data-ttu-id="d0155-174">將屬性寫入內容，以供其他管線元件在接收與傳送端使用，可能會很有用。</span><span class="sxs-lookup"><span data-stu-id="d0155-174">It may be useful to write properties into the context for use by other pipeline components on the receiving or sending side.</span></span>  
  
```  
//create an instance of the property to be promoted  
SOAP.MethodName methodName = new SOAP.MethodName();  
  
//call the promote method on the context using the property class for name   
//and namespace  
pInMsg.Context.Promote(methodName.Name.Name, methodName.Name.Namespace,   
"theSOAPMethodName");  
  
//write a distinguished field to the context  
pInMsg.Context.Write("theDistinguishedProperty",   
"http://schemas.microsoft.com/BizTalk/2003/btsDistinguishedFields",   
"theDistinguishedValue");  
```  
  
 <span data-ttu-id="d0155-175">在寫入或升級值到內容時，請務必記住下列事項：</span><span class="sxs-lookup"><span data-stu-id="d0155-175">Keep the following facts in mind when writing or promoting values into the context:</span></span>  
  
-   <span data-ttu-id="d0155-176">將值寫入具有先前用來升級屬性之相同名稱與命名空間的內容，會導致該屬性不再被升級。</span><span class="sxs-lookup"><span data-stu-id="d0155-176">Writing a value into the context with the same name and namespace that were used previously to promote the property causes that property to no longer be promoted.</span></span> <span data-ttu-id="d0155-177">寫入基本上會覆寫升級。</span><span class="sxs-lookup"><span data-stu-id="d0155-177">The write essentially overwrites the promotion.</span></span>  
  
-   <span data-ttu-id="d0155-178">將空值寫入內容會刪除值，因為空值屬性是不被允許的。</span><span class="sxs-lookup"><span data-stu-id="d0155-178">Writing a value of null into the context deletes the value, because null-valued properties are not permitted.</span></span>  
  
-   <span data-ttu-id="d0155-179">升級屬性的長度有 256 個字元的限制，但是寫入屬性並無長度限制。</span><span class="sxs-lookup"><span data-stu-id="d0155-179">Promoted properties are limited to 256 characters in length while written properties have no length limitation.</span></span>  
  
 <span data-ttu-id="d0155-180">升級屬性是用於訊息路由中，且基於比較與儲存效率的原因，所以在大小上會有所限制。</span><span class="sxs-lookup"><span data-stu-id="d0155-180">Promoted properties are used in message routing and are limited in size for reasons of efficiency in comparison and storage.</span></span> <span data-ttu-id="d0155-181">雖然寫入屬性在大小上並無嚴格限制，在內容中使用過大的值會影響效能，因為這些值仍會被處理並與訊息一起傳遞。</span><span class="sxs-lookup"><span data-stu-id="d0155-181">While written properties have no hard limits on size, using excessively large values in the context will have an impact on performance, because those values must still be processed and passed with the message.</span></span>  
  
 <span data-ttu-id="d0155-182">當訊息已經可以從 BizTalk Server 傳送時，它會在傳送埠中進行互補程序。</span><span class="sxs-lookup"><span data-stu-id="d0155-182">When a message is ready to be sent from BizTalk Server, it undergoes a complementary process in the send port.</span></span> <span data-ttu-id="d0155-183">在執行傳送管線之前，對應已先套用至訊息，讓訊息在管線處理並透過配接器傳送以前，可以先轉換為客戶或應用程式專用的格式。</span><span class="sxs-lookup"><span data-stu-id="d0155-183">Maps are applied to messages before the send pipeline is executed, allowing a message to be transformed to a customer or application-specific format before being processed by the pipeline and sent through the adapter.</span></span> <span data-ttu-id="d0155-184">在傳送管線中，屬性會從內容降級為訊息，以取代將屬性升級為訊息內容。</span><span class="sxs-lookup"><span data-stu-id="d0155-184">In the send pipeline, instead of promoting properties into the message context, properties are demoted from the context into the message.</span></span>  
  
 <span data-ttu-id="d0155-185">![傳送埠和傳送管線處理程序](../core/media/arch-message-processing-2.gif "arch_message_processing 2")</span><span class="sxs-lookup"><span data-stu-id="d0155-185">![Send port, and send pipeline process](../core/media/arch-message-processing-2.gif "arch_message_processing-2")</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d0155-186">另請參閱</span><span class="sxs-lookup"><span data-stu-id="d0155-186">See Also</span></span>  
 <span data-ttu-id="d0155-187">[執行階段架構](../core/runtime-architecture.md) </span><span class="sxs-lookup"><span data-stu-id="d0155-187">[Runtime Architecture](../core/runtime-architecture.md) </span></span>  
 [<span data-ttu-id="d0155-188">BizTalk Server 如何處理大型訊息</span><span class="sxs-lookup"><span data-stu-id="d0155-188">How BizTalk Server Processes Large Messages</span></span>](../core/how-biztalk-server-processes-large-messages.md)