---
title: 配接器如何處理大型訊息 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c48671fd-b6cf-4507-92b4-35a4cd135714
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 7a0d4260274354ce68992ddf30e07dcc74991b8e
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/27/2018
ms.locfileid: "36987343"
---
# <a name="how-adapters-handle-large-messages"></a><span data-ttu-id="28624-102">配接器如何處理大型訊息</span><span class="sxs-lookup"><span data-stu-id="28624-102">How Adapters Handle Large Messages</span></span>
<span data-ttu-id="28624-103">「BizTalk 傳訊引擎」可處理非常大型的訊息，且不會限制訊息的最大大小。</span><span class="sxs-lookup"><span data-stu-id="28624-103">The BizTalk Messaging Engine can process very large messages and imposes no restriction on the maximum size of a message.</span></span> <span data-ttu-id="28624-104">但是，您應考慮限制訊息的大小，以維護最佳效能及資源管理。</span><span class="sxs-lookup"><span data-stu-id="28624-104">However, you should consider limits to message size to maintain optimum performance and resource management.</span></span> <span data-ttu-id="28624-105">隨著訊息大小的增加，每秒鐘可處理的訊息數量會跟著減少。</span><span class="sxs-lookup"><span data-stu-id="28624-105">As message size increases the number of messages processed per second decreases.</span></span> <span data-ttu-id="28624-106">在設計您的案例及規劃容量時，請考慮 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 所處理的平均訊息大小、訊息類型以及訊息數量。</span><span class="sxs-lookup"><span data-stu-id="28624-106">Consider the average message size, message type, and number of messages being processed by [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] when designing your scenario and planning for capacity.</span></span>  
  
## <a name="stream-based-processing"></a><span data-ttu-id="28624-107">以資料流為基礎的處理</span><span class="sxs-lookup"><span data-stu-id="28624-107">Stream-Based Processing</span></span>  
 <span data-ttu-id="28624-108">請注意在開發配接器時，大型訊息的處理是很重要的。</span><span class="sxs-lookup"><span data-stu-id="28624-108">It is important to keep large message handling in mind when developing adapters.</span></span> <span data-ttu-id="28624-109">Microsoft 強烈建議您將整個資料流載入記憶體中時，務必考慮資料流的大小，否則這可能會停止 BizTalk Server 程序。</span><span class="sxs-lookup"><span data-stu-id="28624-109">Loading the entire data stream into memory regardless of its size is strongly discouraged because this could potentially stop the BizTalk Server process.</span></span> <span data-ttu-id="28624-110">視在指定時間引擎所處理的訊息大小和數量而定，虛擬記憶體很低時可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="28624-110">Depending on the size and number of messages that the engine is processing at any given time, low virtual memory could become a problem.</span></span> <span data-ttu-id="28624-111">訊息應以下列資料流處理方式進行處理：</span><span class="sxs-lookup"><span data-stu-id="28624-111">Instead, messages should be processed in a streaming fashion as follows:</span></span>  
  
- <span data-ttu-id="28624-112">**輸入的訊息。**</span><span class="sxs-lookup"><span data-stu-id="28624-112">**Inbound messages.**</span></span> <span data-ttu-id="28624-113">對於輸入訊息，接收配接器會將資料流的「提取」動作保留給「BizTalk 傳訊引擎」，將網路資料流附加至 BizTalk 訊息。</span><span class="sxs-lookup"><span data-stu-id="28624-113">For inbound messages the network stream is attached to the BizTalk message by the receive adapter leaving the "pulling" of the stream to the BizTalk Messaging Engine.</span></span>  
  
- <span data-ttu-id="28624-114">**輸出訊息。**</span><span class="sxs-lookup"><span data-stu-id="28624-114">**Outbound messages.**</span></span> <span data-ttu-id="28624-115">對於輸出訊息，配接器會負責提取資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-115">For outbound messages the adapter is responsible for pulling the stream.</span></span> <span data-ttu-id="28624-116">這可有效地從 MessageBox 資料庫和透過傳送管線提取資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-116">This effectively pulls the stream from the MessageBox database and though the send pipeline.</span></span> <span data-ttu-id="28624-117">配接器應透過連線以資料流處理方式傳送資料。</span><span class="sxs-lookup"><span data-stu-id="28624-117">The adapter should send the data over the wire in a streaming fashion.</span></span>  
  
  <span data-ttu-id="28624-118">下圖顯示在「傳訊引擎」接收端上，以資料流為基礎的處理。</span><span class="sxs-lookup"><span data-stu-id="28624-118">The following figure shows stream-based processing on the receive side of the Messaging Engine.</span></span>  
  
  <span data-ttu-id="28624-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span><span class="sxs-lookup"><span data-stu-id="28624-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span></span>  
  
  <span data-ttu-id="28624-120">配接器在提交訊息到引擎時，應會將其資料流附加到 BizTalk 訊息。</span><span class="sxs-lookup"><span data-stu-id="28624-120">When an adapter submits a message to the engine it should attach its data stream to the BizTalk message.</span></span> <span data-ttu-id="28624-121">對某些配接器而言，這可能表示實作網路資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-121">For some adapters this may mean implementing a network stream.</span></span> <span data-ttu-id="28624-122">訊息提交之後，引擎就會執行接收管線。</span><span class="sxs-lookup"><span data-stu-id="28624-122">When the message is submitted, the engine executes the receive pipeline.</span></span> <span data-ttu-id="28624-123">在管線執行時，想要變更資料的管線元件會複製該資料，將資料流從新訊息連線到上一個訊息上的資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-123">During pipeline execution, the pipeline components that want to change the data clone the message, wiring up the stream from the new message to the stream on the previous message.</span></span> <span data-ttu-id="28624-124">管線執行之後，「傳訊引擎」會從管線取出訊息，並執行迴圈，讀取該訊息上的資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-124">After the pipeline has been executed, the Messaging Engine takes a message out of the pipeline and executes a loop reading the stream on that message.</span></span> <span data-ttu-id="28624-125">這個讀取資料流的動作會在上一個資料流上叫用讀取，接著又在上一個資料流叫用讀取，依此類推，一直回到網路資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-125">This reading of the stream invokes a read on the previous stream, which in turn invokes a read on the previous stream, and so on back to the network stream.</span></span> <span data-ttu-id="28624-126">引擎會定期排清資料到 MessageBox，以維護一般記憶體模型。</span><span class="sxs-lookup"><span data-stu-id="28624-126">The engine periodically flushes the data to the MessageBox to maintain a flat memory model.</span></span>  
  
  <span data-ttu-id="28624-127">**疑難排解秘訣：** 在傳送端，配接器會負責讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-127">**Troubleshooting Tip:** On the send side, the adapter is responsible for reading the stream.</span></span> <span data-ttu-id="28624-128">如果傳送配接器想要讀取任何在傳送管線中升級或寫入的訊息內容屬性，在讀取整個資料流之前，這些屬性可能不會被寫入。</span><span class="sxs-lookup"><span data-stu-id="28624-128">If the send adapter wants to read any message context properties that are promoted or written in the send pipeline, these properties may not be written until the entire stream is read.</span></span> <span data-ttu-id="28624-129">只有當資料流已完全讀取時，配接器才可確定所有管線元件都已完成執行。</span><span class="sxs-lookup"><span data-stu-id="28624-129">Only when the stream has been completely read can the adapter be sure that all of the pipeline components have finished executing.</span></span>  
  
## <a name="locating-a-specific-byte-in-the-stream"></a><span data-ttu-id="28624-130">找出資料流中的特定位元組</span><span class="sxs-lookup"><span data-stu-id="28624-130">Locating a Specific Byte in the Stream</span></span>  
 <span data-ttu-id="28624-131">在某些案例中，配接器可能需要從頭找回資料流，處理需要擱置的失敗訊息。</span><span class="sxs-lookup"><span data-stu-id="28624-131">There are scenarios in which an adapter may need to locate the stream back to the beginning to handle failed messages that need to be suspended.</span></span> <span data-ttu-id="28624-132">舉例來說，HTTP 配接器會使用區塊編碼接收資料，提交請求-回應組中的回應訊息。</span><span class="sxs-lookup"><span data-stu-id="28624-132">An example of this is an HTTP adapter that is receiving data using chunked encoding to submit the response message in a solicit-response pair.</span></span>  
  
 <span data-ttu-id="28624-133">但是，在許多案例中您可能無法追蹤資料流。</span><span class="sxs-lookup"><span data-stu-id="28624-133">However, in many scenarios you may not be able to trace the data stream.</span></span> <span data-ttu-id="28624-134">例如，請考慮使用區塊編碼接收資料的 HTTP 配接器。</span><span class="sxs-lookup"><span data-stu-id="28624-134">For example, consider an HTTP adapter receiving data using chunked encoding.</span></span> <span data-ttu-id="28624-135">如果要進行設計的資料流讓您尋找失敗的訊息，則配接器在讀取資料的同時，必須將其快取到記憶體或磁碟中。</span><span class="sxs-lookup"><span data-stu-id="28624-135">For the data stream to be designed so you can find the messages that failed, the adapter would need to cache the data as it is read, either in memory or onto disk.</span></span> <span data-ttu-id="28624-136">很明顯的，這無法達到最佳效果，且需要額外的資源。</span><span class="sxs-lookup"><span data-stu-id="28624-136">Clearly this is not optimal and requires additional resources.</span></span> <span data-ttu-id="28624-137">此外，許多現成的管線元件都是以 Forward-Only 資料流處理方式運作。</span><span class="sxs-lookup"><span data-stu-id="28624-137">Further, many of the out-of-the-box pipeline components operate in a forward-only streaming fashion.</span></span> <span data-ttu-id="28624-138">針對這些案例在 SDK 中的 BaseAdapter 會使用協助程式類別，稱為**VirtualStream**。</span><span class="sxs-lookup"><span data-stu-id="28624-138">For these scenarios the BaseAdapter in the SDK uses a helper class called **VirtualStream**.</span></span> <span data-ttu-id="28624-139">包含此功能的檔案稱為 VirtualStream.cs。</span><span class="sxs-lookup"><span data-stu-id="28624-139">The file that contains this functionality is named VirtualStream.cs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28624-140">VirtualStream.cs 檔案位於「管線 SDK 範例」下的兩個位置中 — SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler 和 SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm。</span><span class="sxs-lookup"><span data-stu-id="28624-140">The VirtualStream.cs file is located in two locations under the Pipelines SDK Samples—SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler and SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm.</span></span>  
  
 <span data-ttu-id="28624-141">虛擬資料流背後的概念就是資料流中的資料在到達閾值之前，會快取在記憶體資料流中，超過閾值時，資料會溢位到磁碟的安全位置。</span><span class="sxs-lookup"><span data-stu-id="28624-141">The idea behind a virtual stream is that the data in the stream is cached in a memory stream until it reaches a threshold, over which the data is overflowed to a secure location on disk.</span></span> <span data-ttu-id="28624-142">資料流關閉之後，就會自動刪除磁碟檔案。</span><span class="sxs-lookup"><span data-stu-id="28624-142">After the stream is closed the disk file is automatically deleted.</span></span> <span data-ttu-id="28624-143">Forward-Only 資料流可使用這種方式設計。</span><span class="sxs-lookup"><span data-stu-id="28624-143">Forward-only streams can be designed in this way.</span></span>