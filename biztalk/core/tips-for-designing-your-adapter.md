---
title: 設計您的配接器的秘訣 |Microsoft 文件
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 93c59efc2ae811827cd0cb1cf4763485b675f4ea
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
ms.locfileid: "22279862"
---
# <a name="tips-for-designing-your-adapter"></a><span data-ttu-id="0a2e0-102">設計配接器的秘訣</span><span class="sxs-lookup"><span data-stu-id="0a2e0-102">Tips for Designing Your Adapter</span></span>
<span data-ttu-id="0a2e0-103">本節包含配接器開發人員在設計配接器時所學習到的提示及秘訣。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-103">This section contains hints and tips that adapter developers have learned while designing adapters.</span></span>  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a><span data-ttu-id="0a2e0-104">處理常式屬性在當做預設組態使用時必須是字串</span><span class="sxs-lookup"><span data-stu-id="0a2e0-104">Handler Properties Should Be Strings if Used as Default Configurations</span></span>  
 <span data-ttu-id="0a2e0-105">它似乎很討喜 XSD 產生的處理常式屬性工作表上使用屬性的預設值為其**位置**屬性因為如果未設定值**位置**執行階段自動會使用處理常式中設定的值。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-105">It seems attractive to use the properties on the XSD-generated handler property sheet as defaults for their **Location** properties because if the value is not set in **Location** the runtime automatically uses the value set in the handler.</span></span> <span data-ttu-id="0a2e0-106">但這會產生幾個問題，使得這種做法不是那麼好用。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-106">But there are several issues that make this less useful.</span></span>  
  
 <span data-ttu-id="0a2e0-107">問題在於我們不知道是否應該覆寫這個提供給執行階段的值。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-107">The problem comes with not knowing whether the value presented to the runtime is to be overridden or not.</span></span> <span data-ttu-id="0a2e0-108">這麼做的方法，通常是先瞭解定義這個值的 NULL，然後再對該值執行測試。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-108">The typical way of doing this is to have some notion of NULL defined for values and then run a test against that value.</span></span> <span data-ttu-id="0a2e0-109">在 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中使用 XSD 屬性工作表時，之所以產生問題，是因為只有字串才支援 NULL。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-109">The problem when using the XSD-based property sheets in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is that NULL is only supported for strings.</span></span> <span data-ttu-id="0a2e0-110">即使您希望透過使用這種 NULL 測試，將配接器設定為預設設定，而且願意將配接器限制為字串類型，這還是會在使用者介面上，讓人有格格不入的感覺。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-110">Even if you want your adapter to have default settings through the use of this NULL test and are willing to restrict the adapter to string types, it is still exposed to a very odd piece of user interface.</span></span>  
  
 <span data-ttu-id="0a2e0-111">XSD 產生的屬性工作表只支援 NULL 屬性的設定，以滑鼠右鍵按一下屬性，此時**使合約失效？** 就會出現內容功能表，這個屬性可以設定為 NULL。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-111">The XSD-generated property sheets only support the setting of a property back to NULL by right-clicking the property, at which point a **nullify?** context menu appears and the property can be set to NULL.</span></span> <span data-ttu-id="0a2e0-112">至於該屬性是否為 NULL，並沒有視覺回應可供參考。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-112">There is no visual feedback as to whether a property is NULL.</span></span>  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a><span data-ttu-id="0a2e0-113">實作結構描述產生精靈的考量</span><span class="sxs-lookup"><span data-stu-id="0a2e0-113">Considerations for Implementing Schema Generation Wizards</span></span>  
 <span data-ttu-id="0a2e0-114">程式設計人員還是喜歡針對強型別 (Strongly Typed) 物件模型撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-114">Programmers like to code against strongly typed object models.</span></span> <span data-ttu-id="0a2e0-115">在程式碼中操作 XML，起初可能很麻煩，而且容易出錯。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-115">Manipulating XML in code can at first seem awkward and prone to error.</span></span> <span data-ttu-id="0a2e0-116">但是藉助一些訣竅並巧妙運用 .NET Framework 提供的支援，事情可以在大幅簡化之後迎刃而解。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-116">But some tricks and smart use of the support offered by the .NET Framework can dramatically simplify matters.</span></span>  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a><span data-ttu-id="0a2e0-117">不要使用字串串連方式建立 XML 文件</span><span class="sxs-lookup"><span data-stu-id="0a2e0-117">Do not create XML documents with string concatenation</span></span>  
 <span data-ttu-id="0a2e0-118">嘗試透過字串串連及列印陳述式，在記憶體中產生 XML，是在處理 XML 時會犯的其中一個最糟糕的錯誤。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-118">One of the worst mistakes to make with XML is to try and generate it from string concatenation and print statements in memory.</span></span> <span data-ttu-id="0a2e0-119">這會消耗大量的 CPU 時間和記憶體。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-119">This consumes large amounts of CPU time and memory.</span></span> <span data-ttu-id="0a2e0-120">即使是微不足道的 XML 片段，使用如 XmlWriter 或「文件物件模型」(DOM) 等工具，都會比使用上述方法來得容易。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-120">Even for the most trivial XML snippet, it is easier to use a tool like XmlWriter or the Document Object Model (DOM).</span></span> <span data-ttu-id="0a2e0-121">如果您要使用 XmlWriter，請勿使用原始資料寫入功能，因為這個寫入器會丟失文件的狀態。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-121">If you are using XmlWriter, do not use the raw write capability, because the writer loses the state of the document.</span></span>  
  
 <span data-ttu-id="0a2e0-122">在執行階段中，使用 XmlWriter 勝過使用 XML DOM，因為與 DOM 大量消耗記憶體的問題有關。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-122">At run time, XmlWriter is preferred over the XML DOM because of high memory consumption issues associated with the DOM.</span></span> <span data-ttu-id="0a2e0-123">然而，這在設定階段或設計階段中，多半不成問題。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-123">However, at configuration or design time this will most likely not be an issue.</span></span> <span data-ttu-id="0a2e0-124">使用 DOM 有助於使用 XPATH 查詢，而後者將會是另一項好用的工具。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-124">Using the DOM facilitates the use of XPATH queries, which can be a useful additional tool.</span></span>  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a><span data-ttu-id="0a2e0-125">考慮將 XML 文件架構定義為資源</span><span class="sxs-lookup"><span data-stu-id="0a2e0-125">Consider defining the skeleton of your XML document as a resource</span></span>  
 <span data-ttu-id="0a2e0-126">如果您要透過設計工具製作大型 XML 文件，而產生的這份文件一律遵循相同的基本結構，請考慮將整個 XML 架構檔案當做資源置於專案中，以便您在需要編輯它時進行變更。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-126">If you are generating a large XML document from a design tool and that generated document always follows the same basic structure, consider placing the whole skeletal XML file as a resource in the project to allow making changes when you need to edit it.</span></span>  
  
 <span data-ttu-id="0a2e0-127">將程式碼載入 DOM 中，然後使用 XPATH 挑出您要加入的節點，在文件的架構上添增必要的具體內容。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-127">Load the code into a DOM and then add the necessary flesh to the bones of the document by using XPATH to pick out the node you want to add it to.</span></span> <span data-ttu-id="0a2e0-128">此時，您是在建立 Web 服務描述語言 (WSDL) 檔案。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-128">In this case, you are creating a Web Services Description Language (WSDL) file.</span></span> <span data-ttu-id="0a2e0-129">精靈將 WSDL 架構檔案儲存在資源中，並加入產生的 XML 結構描述定義 (XSD) 子組件。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-129">The wizard stores the skeletal WSDL file in a resource and adds the generated XML Schema Definition (XSD) child parts.</span></span> <span data-ttu-id="0a2e0-130">它會搭配 XPath 使用 selectNode 來尋找正確的父代。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-130">It uses selectNode with an xpath to find the right parent.</span></span> <span data-ttu-id="0a2e0-131">由於這是使用者介面程式碼，所以沒有效能上的問題，而產生的實作非常明瞭、穩固且易於維護。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-131">This is user interface code, so performance is not an issue, and the resulting implementation is clean, robust, and maintainable.</span></span>  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a><span data-ttu-id="0a2e0-132">考慮將處理步驟置於 BizTalk 管線中</span><span class="sxs-lookup"><span data-stu-id="0a2e0-132">Consider Placing Processing Steps in the BizTalk Pipeline</span></span>  
 <span data-ttu-id="0a2e0-133">一般而言，Microsoft 建立的配接器會將基於訊息格式的處理移出配接器並置入 BizTalk 管線。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-133">In general the adapters built at Microsoft move message format-based processing out of the adapter and into the BizTalk pipeline.</span></span> <span data-ttu-id="0a2e0-134">結構化的非 XML 資料來源配接器就是最好的範例。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-134">A good example is an adapter to a structured but non-XML data source.</span></span>  
  
 <span data-ttu-id="0a2e0-135">在這種情況下，配接器只負責取得資料，而 BizTalk 管線則用來剖析資料，並將它轉換成相對的 XML。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-135">In this case, the adapter only gets the data and the BizTalk pipeline is used to parse it and convert it into an XML equivalent.</span></span> <span data-ttu-id="0a2e0-136">這麼做的好處是，管線元件本身會成為架構中可重複使用的項目。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-136">The benefit is that the pipeline component itself becomes a reusable piece of the architecture.</span></span>  
  
## <a name="make-adapter-behavior-configurable"></a><span data-ttu-id="0a2e0-137">讓配接器行為變得可設定</span><span class="sxs-lookup"><span data-stu-id="0a2e0-137">Make Adapter Behavior Configurable</span></span>  
 <span data-ttu-id="0a2e0-138">我們從 MQSeries 配接器 Beta 程式中學到了一個教訓，那就是並非所有的客戶都對相同的行為方式感到滿意。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-138">One of the lessons learned from the MQSeries adapter beta program was that not all customers were happy with the same behavior.</span></span> <span data-ttu-id="0a2e0-139">這在處理錯誤和排序時，更是如此。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-139">This was especially true when it came to handling errors and ordering.</span></span> <span data-ttu-id="0a2e0-140">藉由讓客戶可以設定配接器的行為模式，我們解決了這個問題。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-140">The solution was to make the behavior configurable.</span></span> <span data-ttu-id="0a2e0-141">您可以指定配接器是否要支援排序、要將失敗狀況移至擱置的佇列，或者要讓失敗造成配接器本身停止處理並停用。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-141">You can specify whether the adapter is to support ordering, whether failures are moved to the Suspended queue, or whether they cause the adapter to stop processing and disable itself.</span></span> <span data-ttu-id="0a2e0-142">當客戶必須為 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 撰寫外部的複雜協調流程或指令碼來達到相同效果時，讓這類行為變得可設定，將可以明顯簡化客戶經歷的過程。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-142">Making such behaviors configurable can significantly simplify customers' lives when they would need to write complex orchestrations or scripts external to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to achieve the same result.</span></span>  
  
## <a name="support-correlation-with-message-queues"></a><span data-ttu-id="0a2e0-143">支援與訊息佇列的相互關聯</span><span class="sxs-lookup"><span data-stu-id="0a2e0-143">Support Correlation with Message Queues</span></span>  
 <span data-ttu-id="0a2e0-144">許多傳訊平台都支援訊息標頭中的相互關聯識別碼概念，以便支援應用程式層級要求-回應實例。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-144">Many messaging platforms support the notion of a correlation ID in the message header to support an application-level request-response scenario.</span></span> <span data-ttu-id="0a2e0-145">例如，MQSeries、MSMQ 和 SQL Service Broker。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-145">Examples include MQSeries, MSMQ, and SQL Service Broker.</span></span> <span data-ttu-id="0a2e0-146">將外部傳訊系統的要求-回應模式，與 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中的傳送-回應配接器相提並論，似乎頗具說服力。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-146">It would seem attractive to map the request-response pattern of the external messaging system to a send-response adapter in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="0a2e0-147">但這並不合理，因為沒有考慮到交易所在的位置。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-147">However this does not make sense because of where the transactions live.</span></span> <span data-ttu-id="0a2e0-148">說得明白些，對外部傳訊系統進行的傳送作業必須先完成交易式認可，佇列的另一端才看得到資料。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-148">Specifically, a send to the external messaging system requires a transactional commit before the other end of the queue sees the data.</span></span> <span data-ttu-id="0a2e0-149">此外，接收作業也必須是不同的交易。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-149">The receive must also be a separate transaction.</span></span>  
  
 <span data-ttu-id="0a2e0-150">在 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中，解決的方法如下：</span><span class="sxs-lookup"><span data-stu-id="0a2e0-150">The solution in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is to:</span></span>  
  
-   <span data-ttu-id="0a2e0-151">使用協調流程中的相互關聯集</span><span class="sxs-lookup"><span data-stu-id="0a2e0-151">Use correlation sets in orchestration</span></span>  
  
-   <span data-ttu-id="0a2e0-152">設定兩個不同的連接埠： 一個用於傳送，一個用於接收</span><span class="sxs-lookup"><span data-stu-id="0a2e0-152">Configure two separate ports: one for the send and one for the receive</span></span>  
  
 <span data-ttu-id="0a2e0-153">在簡單的情況下，協調流程會依據配接器指定與訊息有關的相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-153">In a simple case the orchestration specifies the correlation ID that is associated with the message by the adapter.</span></span> <span data-ttu-id="0a2e0-154">這個識別碼會傳遞給配接器做為訊息上的內容屬性。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-154">This is passed to the adapter as a context property on the message.</span></span> <span data-ttu-id="0a2e0-155">在更複雜的情況下，這個實例會要求外部傳訊系統配置識別碼。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-155">In a more complex case, the scenario calls for the external messaging system to allocate the ID.</span></span> <span data-ttu-id="0a2e0-156">在此情況下它可以傳遞回從傳送埠至協調流程將回應訊息。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-156">In this case it can be passed back from the send port to the orchestration with a response message.</span></span> <span data-ttu-id="0a2e0-157">此回應訊息只是將識別碼傳回，並不是真正的訊息回應。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-157">This response message is just to pass back the ID and is not the true message response.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a2e0-158">在協調流程引擎中會發生競爭情形，以致真正的訊息回應可能搶先傳送作業中的識別碼回應。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-158">There is a race condition in the orchestration engine such that the true response to the message could win against the ID response from the send.</span></span> <span data-ttu-id="0a2e0-159">這種競爭情形必須在協調流程內部自行處理。</span><span class="sxs-lookup"><span data-stu-id="0a2e0-159">This race condition must be handled in the orchestration itself.</span></span>