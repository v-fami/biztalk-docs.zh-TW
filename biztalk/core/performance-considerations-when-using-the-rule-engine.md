---
title: "使用規則引擎時的效能考量 |Microsoft 文件"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: "7"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: c24a1c6ffb278d257e16c192e5fc7d827df70e24
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
---
# <a name="performance-considerations-when-using-the-rule-engine"></a><span data-ttu-id="3a247-102">使用規則引擎時的效能考量</span><span class="sxs-lookup"><span data-stu-id="3a247-102">Performance Considerations When Using the Rule Engine</span></span>
<span data-ttu-id="3a247-103">本主題討論規則引擎如何在各種情況下執行，以及使用各種不同的組態/調整參數值來執行。</span><span class="sxs-lookup"><span data-stu-id="3a247-103">This topic discusses how the rule engine performs in various scenarios and with different values for the configuration/tuning parameters.</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="3a247-104">事實類型</span><span class="sxs-lookup"><span data-stu-id="3a247-104">Fact Types</span></span>  
 <span data-ttu-id="3a247-105">規則引擎存取 .NET 事實所需的時間，少於存取 XML 和資料庫事實所需的時間。</span><span class="sxs-lookup"><span data-stu-id="3a247-105">The rule engine takes less time to access .NET facts than it does to access XML and database facts.</span></span> <span data-ttu-id="3a247-106">如果您可選擇在原則中使用 .NET、XML 或資料庫事實，您應該考慮使用 .NET 事實，以取得更好的效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-106">If you have a choice of using .NET, XML, or database facts in a policy, you should consider using .NET facts for better performance.</span></span>  
  
## <a name="data-table-vs-data-connection-binding"></a><span data-ttu-id="3a247-107">資料表與。資料連接繫結</span><span class="sxs-lookup"><span data-stu-id="3a247-107">Data Table vs. Data Connection Binding</span></span>  
 <span data-ttu-id="3a247-108">當資料集的大小很小 （少於約 10 個資料列） **TypedDataTable**繫結的執行效能比**DataConnection**繫結。</span><span class="sxs-lookup"><span data-stu-id="3a247-108">When the size of the data set is small (fewer than approximately 10 rows), the **TypedDataTable** binding performs better than the **DataConnection** binding.</span></span> <span data-ttu-id="3a247-109">當資料集很大 （大於或等於約 10 個資料列） **DataConnection**繫結的執行效能比**TypedDataTable**繫結。</span><span class="sxs-lookup"><span data-stu-id="3a247-109">When the data set is large (greater than or equal to approximately 10 rows), the **DataConnection** binding performs better than the **TypedDataTable** binding.</span></span> <span data-ttu-id="3a247-110">因此，您應該決定是否要使用**DataConnection**繫結或**TypedDataTable**繫結會根據資料集的估計大小。</span><span class="sxs-lookup"><span data-stu-id="3a247-110">Therefore, you should decide whether to use the **DataConnection** binding or the **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="3a247-111">事實擷取器</span><span class="sxs-lookup"><span data-stu-id="3a247-111">Fact Retrievers</span></span>  
 <span data-ttu-id="3a247-112">您可以撰寫事實擷取器，它是實作標準方法的物件，而且通常會在執行原則之前，使用這些方法將長期與緩慢變化的事實提供給規則引擎。</span><span class="sxs-lookup"><span data-stu-id="3a247-112">You can write a fact retriever—an object that implements standard methods and typically uses them to supply long-term and slowly changing facts to the rule engine before the policy is executed.</span></span> <span data-ttu-id="3a247-113">此引擎會快取這些事實，並透過多個執行循環來使用這些事實。</span><span class="sxs-lookup"><span data-stu-id="3a247-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="3a247-114">您應該在第一次叫用規則引擎時建立事實擷取器來提交事實，然後只有在需要時才更新記憶體中的事實，而不要在每次叫用規則引擎時都提交靜態或相當靜態的事實。</span><span class="sxs-lookup"><span data-stu-id="3a247-114">Instead of submitting a static or fairly static fact each time you invoke the rule engine, you should create a fact retriever that submits the fact the first time, and then updates the fact in memory only when it is needed.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="3a247-115">規則優先順序</span><span class="sxs-lookup"><span data-stu-id="3a247-115">Rule Priority</span></span>  
 <span data-ttu-id="3a247-116">優先順序設定規則的任一端的範圍可以**0**，數目越大則優先順序愈高。</span><span class="sxs-lookup"><span data-stu-id="3a247-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="3a247-117">會依照最高優先順序到最低優先順序的順序來執行動作。</span><span class="sxs-lookup"><span data-stu-id="3a247-117">Actions are executed in order from highest priority to lowest priority.</span></span> <span data-ttu-id="3a247-118">當原則正向鏈結行為會藉由實作使用**Assert/Update**呼叫，鏈結 可最佳化使用的優先權設定。</span><span class="sxs-lookup"><span data-stu-id="3a247-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="3a247-119">例如，假設**Rule2**具有相依性由所設定的值**Rule1**。</span><span class="sxs-lookup"><span data-stu-id="3a247-119">For example, suppose that **Rule2** has a dependency on a value that is set by **Rule1**.</span></span> <span data-ttu-id="3a247-120">提供**Rule1**較高的優先順序表示**Rule2**之後才會執行**Rule1**引發及更新的值。</span><span class="sxs-lookup"><span data-stu-id="3a247-120">Giving **Rule1** a higher priority means that **Rule2** will execute only after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="3a247-121">相反地，如果**Rule2**會提供更高的優先權，它可以引發一次，並再一次之後，會引發**Rule1**引發及更新事實的**Rule2**條件中使用。</span><span class="sxs-lookup"><span data-stu-id="3a247-121">Conversely, if **Rule2** is given a higher priority, it can fire once, and then fire again after **Rule1** fires and updates the fact that **Rule2** is using in a condition.</span></span> <span data-ttu-id="3a247-122">這樣不一定會產生正確的結果，但清楚的一點是，引發兩次與只引發一次相較之下，會有效能上的影響。</span><span class="sxs-lookup"><span data-stu-id="3a247-122">This may or may not produce the correct results, but clearly firing twice has a performance impact versus firing only once.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="3a247-123">Update 呼叫</span><span class="sxs-lookup"><span data-stu-id="3a247-123">Update Calls</span></span>  
 <span data-ttu-id="3a247-124">**更新**函式會更新事實的規則引擎工作記憶體中存在，而且會導致重新評估在條件中使用已更新的事實的所有規則。</span><span class="sxs-lookup"><span data-stu-id="3a247-124">The **Update** function updates a fact that exists in the working memory of the rule engine, and causes all the rules that use the updated fact in conditions to be reevaluated.</span></span> <span data-ttu-id="3a247-125">**更新**函式呼叫可能會耗費資源，尤其是許多規則需要重新評估，因為更新事實。</span><span class="sxs-lookup"><span data-stu-id="3a247-125">**Update** function calls can be expensive, especially if many rules need to be reevaluated because of updating the facts.</span></span> <span data-ttu-id="3a247-126">有一些情況可避免必須重新評估規則，</span><span class="sxs-lookup"><span data-stu-id="3a247-126">There are situations where you can avoid having to reevaluate the rules.</span></span> <span data-ttu-id="3a247-127">例如，假設下列規則：</span><span class="sxs-lookup"><span data-stu-id="3a247-127">For example, consider the following rules:</span></span>  
  
 <span data-ttu-id="3a247-128">**Rule1:**</span><span class="sxs-lookup"><span data-stu-id="3a247-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="3a247-129">**Rule2:**</span><span class="sxs-lookup"><span data-stu-id="3a247-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="3a247-130">原則使用的所有其餘規則**StatusObj.Flag**在其條件中。</span><span class="sxs-lookup"><span data-stu-id="3a247-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="3a247-131">因此，當**更新**上呼叫**StatusObj**物件，將會重新評估所有規則。</span><span class="sxs-lookup"><span data-stu-id="3a247-131">Therefore, when **Update** is called on the **StatusObj** object, all the rules will be reevaluated.</span></span> <span data-ttu-id="3a247-132">任何值**量**欄位時，所有的規則都**Rule1**和**Rule2**會評估兩次，一次之前**更新**呼叫和之後的一次**更新**呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a247-132">Whatever the value of the **Amount** field is, all the rules except **Rule1** and **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="3a247-133">相反地，您可以設定的值**旗標**欄位設為**false**叫用原則，則只使用之前**Rule1**中的原則設定的旗標。</span><span class="sxs-lookup"><span data-stu-id="3a247-133">Instead, you could set the value of the **flag** field to **false** before you invoke the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="3a247-134">在此情況下，**更新**才會呼叫的值**量**欄位值大於 5，和**更新**若數量小於或等於 5，不會呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a247-134">In this case, **Update** is called only if the value of the **Amount** field is greater than 5, and **Update** is not called if the amount is less than or equal to 5.</span></span> <span data-ttu-id="3a247-135">因此，所有的規則都**Rule1**和**Rule2**會評估兩次才值**量**欄位值大於 5。</span><span class="sxs-lookup"><span data-stu-id="3a247-135">Therefore, all the rules except **Rule1** and **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="use-of-logical-or-operators"></a><span data-ttu-id="3a247-136">使用邏輯 OR 運算子</span><span class="sxs-lookup"><span data-stu-id="3a247-136">Use of Logical OR Operators</span></span>  
 <span data-ttu-id="3a247-137">規則引擎最適合用於執行邏輯**AND**運算子和其重新建構所剖析的規則中以 disjunctive normal form 因此的**或**只在最上層使用運算子。</span><span class="sxs-lookup"><span data-stu-id="3a247-137">The rule engine is optimized for executing logical **AND** operators and it reconstructs the rule it parsed in a disjunctive normal form so that **OR** operator is used only at the top level.</span></span> <span data-ttu-id="3a247-138">使用遞增的邏輯**或**中條件運算子會建立其他的排列，以擴充規則引擎的分析網路，而且可能需要很長的時間來標準化此規則的規則引擎。</span><span class="sxs-lookup"><span data-stu-id="3a247-138">Using an increasing number of logical **OR** operators in conditions creates additional permutations that expand the analysis network of the rule engine, and It may take long time for the rule engine to normalize the rule.</span></span> <span data-ttu-id="3a247-139">下列清單包含這個問題的可能因應措施。</span><span class="sxs-lookup"><span data-stu-id="3a247-139">The following list contains possible workarounds for this issue.</span></span>  
  
-   <span data-ttu-id="3a247-140">會修改規則，是以分離的一般形式因此**或**運算子是只在最上層。</span><span class="sxs-lookup"><span data-stu-id="3a247-140">Modify the rule to be in disjunctive normal form so that the **OR** operator is only at the top level.</span></span> <span data-ttu-id="3a247-141">請注意，在商務規則編輯器中以 Disjunctive Normal Form (DNF) 開發規則可能需要一些訣竅。</span><span class="sxs-lookup"><span data-stu-id="3a247-141">Note that developing a rule in disjunctive normal form in Business Rule Composer can be tricky.</span></span> <span data-ttu-id="3a247-142">您可以考慮以程式設計方式建立規則。</span><span class="sxs-lookup"><span data-stu-id="3a247-142">You may want to consider creating the rule programmatically.</span></span>  
  
-   <span data-ttu-id="3a247-143">開發協助程式元件，以執行**或**作業會傳回布林值，並使用規則中的元件。</span><span class="sxs-lookup"><span data-stu-id="3a247-143">Develop a helper component that performs the **OR** operations and returns a Boolean value, and use the component in the rule.</span></span>  
  
-   <span data-ttu-id="3a247-144">考慮將規則分割為多個規則，讓下一個規則檢查上一個執行過的規則所設定的旗標，或使用上一個執行過的規則所判斷提示的物件，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="3a247-144">Consider splitting the rule into multiple rules and have the rules check for a flag set by a previously executed rule or use an object that is asserted by a previously executed rule as shown in the following examples:</span></span>  
  
    -   <span data-ttu-id="3a247-145">規則 1： 如果 (= = 1 或 3 = =) 然後 b = true</span><span class="sxs-lookup"><span data-stu-id="3a247-145">Rule 1: IF (a == 1 OR a == 3) THEN b = true</span></span>  
  
         <span data-ttu-id="3a247-146">規則 2： 如果 (b = = true) 然後...</span><span class="sxs-lookup"><span data-stu-id="3a247-146">Rule 2: if (b == true) THEN …</span></span>  
  
    -   <span data-ttu-id="3a247-147">規則 1： 如果 (= = 1 或 3 = =) 然後判斷提示 (新 c())</span><span class="sxs-lookup"><span data-stu-id="3a247-147">Rule 1: IF (a == 1 OR a == 3) THEN assert(new c())</span></span>  
  
         <span data-ttu-id="3a247-148">規則 2: IF (c.flag = = true) 然後...</span><span class="sxs-lookup"><span data-stu-id="3a247-148">Rule 2: IF (c.flag == true) THEN …</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="3a247-149">快取設定</span><span class="sxs-lookup"><span data-stu-id="3a247-149">Caching Settings</span></span>  
 <span data-ttu-id="3a247-150">規則引擎會使用兩個快取，</span><span class="sxs-lookup"><span data-stu-id="3a247-150">The rule engine uses two caches.</span></span> <span data-ttu-id="3a247-151">第一個是在更新服務中，第二個是在每一個 BizTalk 處理序中。</span><span class="sxs-lookup"><span data-stu-id="3a247-151">The first one is in the Update service and the second one is in each BizTalk process.</span></span> <span data-ttu-id="3a247-152">當第一次使用原則時，BizTalk 處理序會從更新服務要求原則資訊。</span><span class="sxs-lookup"><span data-stu-id="3a247-152">The first time a policy is used, the BizTalk process requests the policy information from the Update service.</span></span> <span data-ttu-id="3a247-153">更新服務會從規則引擎資料庫擷取原則資訊、快取該資訊，並將該資訊傳回到 BizTalk 處理序。</span><span class="sxs-lookup"><span data-stu-id="3a247-153">The Update service retrieves the policy information from the Rule Engine database, caches it, and returns the information to the BizTalk process.</span></span> <span data-ttu-id="3a247-154">BizTalk 處理序會根據該資訊來建立原則物件，並在關聯的規則引擎執行個體完成原則的執行時，將該原則物件儲存在快取中。</span><span class="sxs-lookup"><span data-stu-id="3a247-154">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes executing the policy.</span></span> <span data-ttu-id="3a247-155">當再次叫用相同的原則時，如果快取中有可用的原則物件，則 BizTalk 處理序會重複使用快取中的原則物件。</span><span class="sxs-lookup"><span data-stu-id="3a247-155">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available in the cache.</span></span>  
  
 <span data-ttu-id="3a247-156">同樣地，如果 BizTalk 處理序從更新服務要求與原則有關的資訊，則更新服務會先在快取中尋找原則資訊。</span><span class="sxs-lookup"><span data-stu-id="3a247-156">Similarly, if the BizTalk process requests the information about a policy from the Update service, the Update service first looks for the policy information in its cache.</span></span> <span data-ttu-id="3a247-157">更新服務也會每隔 60 秒鐘 (1 分鐘) 檢查一次，看看資料庫中的原則是否有任何更新。</span><span class="sxs-lookup"><span data-stu-id="3a247-157">The Update service also checks every 60 seconds (one minute) to see if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="3a247-158">如果有任何更新，更新服務會擷取資訊，並快取更新的資訊。</span><span class="sxs-lookup"><span data-stu-id="3a247-158">If there are any updates, the Update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="3a247-159">有三個調整參數，與這些快取相關的規則引擎： **CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="3a247-159">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="3a247-160">您可以在登錄或組態檔中，為這些參數指定值。</span><span class="sxs-lookup"><span data-stu-id="3a247-160">You can specify the values for these parameters either in the registry or in a configuration file.</span></span>  
  
 <span data-ttu-id="3a247-161">值**CacheEntries**是快取中的項目數目上限。</span><span class="sxs-lookup"><span data-stu-id="3a247-161">The value of **CacheEntries** is the maximum number of entries in the cache.</span></span> <span data-ttu-id="3a247-162">預設值**CacheEntries**為 32。</span><span class="sxs-lookup"><span data-stu-id="3a247-162">The default value of **CacheEntries** is 32.</span></span> <span data-ttu-id="3a247-163">您可能想要增加的值**CacheEntries**參數，在某些情況下改善效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-163">You may want to increase the value of the **CacheEntries** parameter to improve performance in some cases.</span></span> <span data-ttu-id="3a247-164">例如，假設您重複使用 40 個原則，</span><span class="sxs-lookup"><span data-stu-id="3a247-164">For example, suppose you are using 40 policies repeatedly.</span></span> <span data-ttu-id="3a247-165">在此情況下您可能想要增加的值**CacheEntries**到 40，以改善效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-165">In this case you may want to increase the value of **CacheEntries** to 40 to improve performance.</span></span> <span data-ttu-id="3a247-166">如此可讓更新服務在記憶體中快取多達 40 個原則的詳細資料，</span><span class="sxs-lookup"><span data-stu-id="3a247-166">This would allow the Update service to cache details of up to 40 policies in memory.</span></span> <span data-ttu-id="3a247-167">也可讓 BizTalk 服務在記憶體中快取多達 40 個原則執行個體。</span><span class="sxs-lookup"><span data-stu-id="3a247-167">It would also cause the BizTalk service to cache up to 40 policy instances in memory.</span></span> <span data-ttu-id="3a247-168">在 BizTalk 服務的快取中，可能會有一個以上的原則執行個體。</span><span class="sxs-lookup"><span data-stu-id="3a247-168">There may be more than one instance of a policy in the cache of the BizTalk service.</span></span>  
  
 <span data-ttu-id="3a247-169">值**CacheTimeout**為項目超過更新服務快取的時間 （以秒為單位）。</span><span class="sxs-lookup"><span data-stu-id="3a247-169">The value of **CacheTimeout** is the time (in seconds) for entries to age out of the Update service cache.</span></span> <span data-ttu-id="3a247-170">換句話說， **CacheTimeout**值是指原則的快取項目保留多久快取中是否有任何參考。</span><span class="sxs-lookup"><span data-stu-id="3a247-170">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is kept in the cache if there are no references to it.</span></span> <span data-ttu-id="3a247-171">預設值**CacheTimeout**為 3600 秒 （1 小時）。</span><span class="sxs-lookup"><span data-stu-id="3a247-171">The default value of **CacheTimeout** is 3600 seconds (one hour).</span></span> <span data-ttu-id="3a247-172">這表示，如果在一個小時內未參考此快取項目，就會將它刪除。</span><span class="sxs-lookup"><span data-stu-id="3a247-172">This means that, if the cache entry is not referenced within an hour, it is deleted.</span></span> <span data-ttu-id="3a247-173">在某些情況下，您可能想要增加**CacheTimeout**值來提升效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-173">In some cases, you may want to increase the **CacheTimeout** value to improve performance.</span></span> <span data-ttu-id="3a247-174">例如，假設每隔兩個小時叫用此原則一次，</span><span class="sxs-lookup"><span data-stu-id="3a247-174">For example, suppose the policy is invoked every two hours.</span></span> <span data-ttu-id="3a247-175">增加的值即可改善效能的原則執行**CacheTimeout**參數大於兩個小時的值。</span><span class="sxs-lookup"><span data-stu-id="3a247-175">You could improve the performance of the policy execution by increasing the value of the **CacheTimeout** parameter to a value greater than two hours.</span></span>  
  
 <span data-ttu-id="3a247-176">**PollingInterval**參數的規則引擎更新服務會檢查規則引擎資料庫更新的間隔 （秒） 定義的時間。</span><span class="sxs-lookup"><span data-stu-id="3a247-176">The **PollingInterval** parameter for the rule engine defines the time in seconds for the interval at which the Update service checks the Rule Engine database for updates.</span></span> <span data-ttu-id="3a247-177">預設值為**PollingInterval**參數為 60 秒 （一分鐘）。</span><span class="sxs-lookup"><span data-stu-id="3a247-177">The default value for the **PollingInterval** parameter is 60 seconds (one minute).</span></span> <span data-ttu-id="3a247-178">如果您知道原則根本不會更新或是很少更新，您可以增加這個值來提升效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-178">If you know that the policies do not get updated at all or are updated rarely, you could increase this value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="3a247-179">SideEffects 屬性</span><span class="sxs-lookup"><span data-stu-id="3a247-179">SideEffects Property</span></span>  
 <span data-ttu-id="3a247-180">**ClassMemberBinding**， **Xmldocumentfieldbinding**，和**XmlDocumentFieldBinding**類別有一個名為屬性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="3a247-180">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="3a247-181">這個屬性可決定是否會快取繫結欄位、成員或資料行的值。</span><span class="sxs-lookup"><span data-stu-id="3a247-181">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="3a247-182">預設值**SideEffects**屬性**Xmldocumentfieldbinding**和**XmlDocumentFieldBinding**類別**false**.</span><span class="sxs-lookup"><span data-stu-id="3a247-182">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="3a247-183">預設值**SideEffects**屬性**ClassMemberBinding**類別是**true**。</span><span class="sxs-lookup"><span data-stu-id="3a247-183">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="3a247-184">因此，當第二次以後在原則中存取 XML 文件的欄位或資料庫資料表的資料行時，則會從快取中擷取其值。</span><span class="sxs-lookup"><span data-stu-id="3a247-184">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="3a247-185">但是，當第二次以後存取 .NET 物件的成員時，就會從此 .NET 物件擷取該值，而不是從快取中擷取。</span><span class="sxs-lookup"><span data-stu-id="3a247-185">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="3a247-186">設定**SideEffects** .NET 屬性**ClassMemberBinding**至**false**會改善效能，因為從快取中擷取欄位的值第二次以後。</span><span class="sxs-lookup"><span data-stu-id="3a247-186">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="3a247-187">您只能透過程式設計的方式進行這項處理。</span><span class="sxs-lookup"><span data-stu-id="3a247-187">You can only do this programmatically.</span></span> <span data-ttu-id="3a247-188">「 商務規則編輯器 」 工具不會公開**SideEffects**屬性。</span><span class="sxs-lookup"><span data-stu-id="3a247-188">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="3a247-189">執行個體與選擇性</span><span class="sxs-lookup"><span data-stu-id="3a247-189">Instances and Selectivity</span></span>  
 <span data-ttu-id="3a247-190">**XmlDocumentBinding**， **ClassBinding**，和**DatabaseBinding**類別有兩個屬性：**執行個體**和**選擇性**。</span><span class="sxs-lookup"><span data-stu-id="3a247-190">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="3a247-191">值**執行個體**是預期的工作記憶體中類別的執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="3a247-191">The value of **Instances** is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="3a247-192">值**選擇性**是將會成功通過規則條件的類別執行個體的百分比。</span><span class="sxs-lookup"><span data-stu-id="3a247-192">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="3a247-193">規則引擎會使用這些值來最佳化條件評估，以便先在條件評估中使用可能的最少執行個體，然後再使用剩餘的執行個體。</span><span class="sxs-lookup"><span data-stu-id="3a247-193">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="3a247-194">如果您事先知道物件的執行個體的數目，設定**執行個體**屬性設為該值將會提升效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-194">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="3a247-195">同樣地，如果您事先知道這些物件通過條件的百分比，設定**選擇性**屬性設為該值將會提升效能。</span><span class="sxs-lookup"><span data-stu-id="3a247-195">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="3a247-196">您只能以程式設計方式設定這些參數的值。</span><span class="sxs-lookup"><span data-stu-id="3a247-196">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="3a247-197">「商務規則編輯器」工具不會公開這些參數。</span><span class="sxs-lookup"><span data-stu-id="3a247-197">The Business Rule Composer tool does not expose them.</span></span>