---
title: 如何設計高效能的配接器 |Microsoft 文件
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e7958968809dc224a3446ac81f3f89d08f6128a0
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
ms.locfileid: "22250534"
---
# <a name="how-to-design-a-performant-adapter"></a><span data-ttu-id="ae3ab-102">如何設計更具效能的配接器</span><span class="sxs-lookup"><span data-stu-id="ae3ab-102">How to Design a Performant Adapter</span></span>
<span data-ttu-id="ae3ab-103">基於效能的目的，所有配接器在對於提交訊息批次、傳輸批次及在各批次的訊息上執行一般性作業等方面，都應該具備批次感知的能力。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-103">For performance purposes all adapters should be batch-aware with regard to submitting batches of messages, transmitting batches, and generally performing operations on messages in batches.</span></span> <span data-ttu-id="ae3ab-104">配接器應該嘗試公開可設定的效能相關屬性，例如，批次的大小或批次中的位元組數目 (這些屬性可從配接器的設計階段使用者介面進行設定)。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-104">Adapters should try to expose configurable performance-related attributes, such as the size of batches or the number of bytes in a batch, that are configurable from the adapter's design-time user interface.</span></span>  
  
 <span data-ttu-id="ae3ab-105">如同之前所提過，傳送配接器一定要執行未封鎖的傳送，以免降低傳送主控件的效能。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-105">As mentioned earlier, send adapters should always perform non-blocking sends to avoid degrading the performance of the send host.</span></span> <span data-ttu-id="ae3ab-106">不建議採用傳訊引擎 API 的進一步封鎖。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-106">Further blocking of Messaging Engine APIs is not recommended.</span></span>  
  
 <span data-ttu-id="ae3ab-107">訊息內容的讀取和寫入都會影響執行階段效能。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-107">Writing to and reading from the message context affects run-time performance.</span></span> <span data-ttu-id="ae3ab-108">一般來說，配接器應該避免讀取、寫入和升級過多數目的訊息內容屬性。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-108">In general, adapters should avoid reading, writing, and promoting excessive numbers of message-context properties.</span></span> <span data-ttu-id="ae3ab-109">升級屬性會產生額外的效能耗損，因為在執行階段會針對每一個升級的屬性進行訂閱評估。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-109">Promoting properties creates an additional performance drain because of the subscription evaluation that occurs on each promoted property at run time.</span></span> <span data-ttu-id="ae3ab-110">但是，配接器需要升級極大量的屬性，才會對效能造成顯著的影響。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-110">However, an adapter would need to promote a huge number of properties to noticeably impact performance.</span></span> <span data-ttu-id="ae3ab-111">因此，只升級那些需要升級的屬性是一個很好的作法。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-111">Still it is a good practice to promote only those properties that are required to be promoted.</span></span>  
  
## <a name="throttle-send-and-receive"></a><span data-ttu-id="ae3ab-112">節流傳送和接收</span><span class="sxs-lookup"><span data-stu-id="ae3ab-112">Throttle Send and Receive</span></span>  
 <span data-ttu-id="ae3ab-113">當 BizTalk 引擎上的負載超過了所設定的閾值時，引擎會節流配接器和協調流程，以確保能夠有最佳的效能。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-113">When the load on the BizTalk engine exceeds the configured threshold, the engine throttles adapters and orchestrations to ensure optimum performance.</span></span> <span data-ttu-id="ae3ab-114">在接收端，當引擎上的工作負載超過給定的臨界值，配接器的呼叫**IBTTransportBatch.Done**會封鎖，直到負載。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-114">On the receive side, when the workload on the engine exceeds a given threshold, the adapter's call to **IBTTransportBatch.Done** is blocked until the load has decreased sufficiently.</span></span> <span data-ttu-id="ae3ab-115">這樣會強制配接器只在引擎可用時才將新的工作提交給引擎。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-115">This forces the adapter to submit new work into the engine only when the engine is available.</span></span> <span data-ttu-id="ae3ab-116">另一方面，當引擎正在節流配接器傳送的輸出訊息時，引擎在負載降低以前，不會傳遞要傳輸的新訊息。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-116">On the send side, when the engine is throttling adapters sending outbound messages, the engine does not deliver new messages to be transmitted until its load is reduced.</span></span>  
  
 <span data-ttu-id="ae3ab-117">基於這些理由，除非必要 (例如，為了限制後端系統的連接數目)，否則配接器不需要考慮節流。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-117">For these reasons, the adapter does not need to be concerned with throttling unless it is required, for example, to limit the number of connections to a back-end system.</span></span> <span data-ttu-id="ae3ab-118">在這些類型的案例中，引擎和配接器架構都不提供任何支援。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-118">For these types of scenarios, neither the engine nor the Adapter Framework provides any support.</span></span>  
  
 <span data-ttu-id="ae3ab-119">您可以透過數種方式 (根據您是否控制配接器的原始程式碼而定) 來處理從自訂傳送配接器傳送之許多訊息的節流。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-119">You can handle throttling the number of messages sent from a custom send adapter in several ways depending on whether you control the source code for the adapter.</span></span>  
  
### <a name="send-side-throttling-improves-performance"></a><span data-ttu-id="ae3ab-120">傳送端節流會提升效能</span><span class="sxs-lookup"><span data-stu-id="ae3ab-120">Send-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="ae3ab-121">如果您控制配接器的原始程式碼，您可以從嘗試錯誤的方法來決定您希望佇列中隨時可傳送的最大訊息數目。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-121">If you control the source code for the adapter, you can determine from heuristics the maximum number of messages that you want to have in the queue to send at any time.</span></span> <span data-ttu-id="ae3ab-122">當傳訊引擎呼叫`TransmitMessage`方法，並傳遞傳送配接器的新訊息，您可以選擇封鎖執行緒或查看佇列中的訊息數目是否大於您之前決定的最大值。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-122">When the Messaging Engine calls the `TransmitMessage` method and passes the send adapter a new message, you can choose to either block the thread or check to see if the number of messages in the queue is larger than the maximum value you determined previously.</span></span> <span data-ttu-id="ae3ab-123">如果已超過最大訊息數，您可以使用`Resubmit`方法來重新提交給傳訊引擎的訊息。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-123">If the maximum number of messages has been exceeded, you can use the `Resubmit` method to resubmit the message to the Messaging Engine.</span></span> <span data-ttu-id="ae3ab-124">請注意，如果配接器是同步的，就表示訊息已經封鎖。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-124">Note that if the adapter is synchronous, the message would already be blocked.</span></span>  
  
 <span data-ttu-id="ae3ab-125">如果您未控制配接器的原始程式碼，您可以變更排入佇列的訊息數目，藉由變更**Highwatermark** BizTalk 管理資料庫中 Adm_serviceclass 資料表中的值。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-125">If you do not control the source code for the adapter, you can change the number of queued messages by changing the **Highwatermark** value in the Adm_serviceclass table in the BizTalk Management database.</span></span> <span data-ttu-id="ae3ab-126">最大值**Highwatermark**屬性為 200。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-126">The maximum value for the **Highwatermark** property is 200.</span></span> <span data-ttu-id="ae3ab-127">您也可以變更的值**的下限標準**屬性設為較小的值。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-127">You can also change the value for the **Lowwatermark** property to a smaller value.</span></span>  
  
 <span data-ttu-id="ae3ab-128">請記住，值**Highwatermark**傳訊引擎提供給配接器的訊息數目的非同步配接器帳戶的屬性。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-128">Remember that the value of the **Highwatermark** property for asynchronous adapters accounts for the number of messages that the Messaging Engine has given to the adapter.</span></span> <span data-ttu-id="ae3ab-129">「 傳訊引擎將其傳遞至配接器透過`TransmitMessage`方法，這些訊息可以尚未完成傳輸 — 比方說，如果配接器尚未進行對應呼叫`DeleteMessage`， `Resubmit`， `MoveToNextTransport`或[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-129">The Messaging Engine passes them to the adapter through the `TransmitMessage` method, These messages can be still outstanding in their transmission—for example, if the adapter has not made a corresponding call to the `DeleteMessage`, `Resubmit`, `MoveToNextTransport`, or [Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx) methods.</span></span> <span data-ttu-id="ae3ab-130">同步配接器， **Highwatermark**屬性作業僅佔 「 傳訊引擎已傳遞至配接器所使用的訊息數目的**TransmitMessage**方法因為這個呼叫封鎖呼叫的傳訊引擎執行緒同步處理。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-130">For synchronous adapters, the **Highwatermark** property only accounts for the number of messages the Messaging Engine has passed to the adapter by using the **TransmitMessage** method because this call processes synchronously, blocking the calling Messaging Engine thread.</span></span>  
  
 <span data-ttu-id="ae3ab-131">如果您要針對本質緩慢的通訊協定 (如 HTTP、FTP 或雙向 SOAP) 來撰寫傳送配接器，請考慮以下事項：</span><span class="sxs-lookup"><span data-stu-id="ae3ab-131">If you are writing a send adapter for a protocol that is inherently slow in nature (such as HTTP, FTP, or two-way SOAP), consider the following:</span></span>  
  
-   <span data-ttu-id="ae3ab-132">這類配接器從 BizTalk 傳訊引擎接收要傳輸之訊息的速度，可能會比可以傳輸訊息的速度還要快。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-132">Such an adapter might receive messages for transmission from the BizTalk Messaging Engine faster than it can transmit them.</span></span> <span data-ttu-id="ae3ab-133">這項差異會造成各種層級的問題，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-133">This discrepancy causes problems at various levels.</span></span> <span data-ttu-id="ae3ab-134">傳輸底下的訊息會留在記憶體中，並佔用虛擬記憶體，因而讓整個系統變得緩慢。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-134">The messages under transmission remain in memory and take up the virtual memory, slowing down the entire system.</span></span>  
  
-   <span data-ttu-id="ae3ab-135">此配接器可能會佔用通訊協定特有的資源。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-135">The adapter might take up protocol-specific resources.</span></span> <span data-ttu-id="ae3ab-136">例如，它可能會開放太多的伺服器並行連接，這樣可能會中斷遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-136">For example, it might open too many concurrent connections to the server, which could disrupt the remote server.</span></span>  
  
-   <span data-ttu-id="ae3ab-137">此配接器可能會影響其他配接器。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-137">The adapter might affect other adapters.</span></span> <span data-ttu-id="ae3ab-138">例如，如果有太多的訊息排入特定配接器的佇列，傳訊引擎會在該處理序中停止發出要求給其他傳送配接器。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-138">For example, if too many messages queue up for a particular adapter, the Messaging Engine stops issuing requests to other send adapters in that process.</span></span>  
  
 <span data-ttu-id="ae3ab-139">有一個解決方法是將緩慢和快速的配接器放在個別的 BizTalk 主控件中，並使用「配額上限」和「配額下限」設定來控制訊息數目。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-139">A solution is to put the slow and fast adapters in separate BizTalk Hosts and control the number of messages by using the "High Watermark" and "Low Watermark" settings.</span></span>  
  
### <a name="receive-side-throttling-improves-performance"></a><span data-ttu-id="ae3ab-140">接收端節流會提升效能</span><span class="sxs-lookup"><span data-stu-id="ae3ab-140">Receive-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="ae3ab-141">在許多情況下，接收配接器接收訊息的速度會快於系統其餘部分可以處理訊息的速度。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-141">There are numerous situations in which a receive adapter receives messages faster than the rate at which the rest of the system can process the messages.</span></span> <span data-ttu-id="ae3ab-142">當這種情況發生時，MessageBox 資料庫會積存訊息。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-142">When such a situation occurs, the MessageBox database becomes backlogged.</span></span> <span data-ttu-id="ae3ab-143">當發生這種情況時，整個系統的效能會大幅降低。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-143">When this happens, the performance of the whole system drops dramatically.</span></span>  
  
 <span data-ttu-id="ae3ab-144">如果您的配接器發生這種情況，您可以使用下列其中一種方法來降低接收配接器的速度：</span><span class="sxs-lookup"><span data-stu-id="ae3ab-144">If this is happening with your adapter, you can use one of the following techniques to reduce the speed of the receive adapter:</span></span>  
  
-   <span data-ttu-id="ae3ab-145">減少傳訊引擎執行緒集區的大小。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-145">Reduce the Messaging Engine thread pool size.</span></span> <span data-ttu-id="ae3ab-146">您可以控制傳訊引擎用來將訊息發佈到 MessageBox 的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-146">You can control the number of threads that the Messaging Engine uses to publish messages into the MessageBox.</span></span> <span data-ttu-id="ae3ab-147">藉由減少執行緒的數目，您就可以降低接收配接器接收訊息到 MessageBox 的速度。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-147">By reducing the number of threads, you reduce the rate at which the receive adapter receives messages into the MessageBox.</span></span> <span data-ttu-id="ae3ab-148">只有對應到配接器之接收處理常式的主控件才需要進行這項設定。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-148">This setting only needs to be done for the host corresponding to the receive handler for the adapter.</span></span> <span data-ttu-id="ae3ab-149">如果是對應到配接器之傳送處理常式的主控件，則不應該進行這項設定，除非您也想要讓傳送配接器變慢。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-149">You should not set this for the host corresponding to the send handler for the adapter, unless you want to slow down the send adapter as well.</span></span>  
  
-   <span data-ttu-id="ae3ab-150">減少配接器批次的大小。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-150">Reduce the adapter batch size.</span></span> <span data-ttu-id="ae3ab-151">大多數的快速接收配接器都會以批次方式發佈訊息至 MessageBox，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-151">Most fast receive adapters publish messages to the MessageBox in batches.</span></span> <span data-ttu-id="ae3ab-152">這些批次的大小通常可以在接收位置屬性頁中設定。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-152">The size of these batches is usually configurable in the receive location property page.</span></span> <span data-ttu-id="ae3ab-153">藉由降低批次大小，就可以減少流入系統中的整體訊息輸送量。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-153">By decreasing the batch size you can decrease the overall throughput of messages coming into the system.</span></span>  
  
-   <span data-ttu-id="ae3ab-154">變更其他配接器特有的設定。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-154">Change other adapter-specific settings.</span></span> <span data-ttu-id="ae3ab-155">當您完成前兩個步驟之後，可以嘗試調整其他配接器參數，以進一步減少輸送量。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-155">After you complete the two previous steps, you can try adjusting other adapter parameters to further decrease throughput.</span></span> <span data-ttu-id="ae3ab-156">某些配接器會公開可用來降低輸送量的內部參數。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-156">Some adapters expose internal parameters that can be used to decrease throughput.</span></span> <span data-ttu-id="ae3ab-157">例如，MQSeries 配接器有一項「排序的傳遞」設定。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-157">For example, the MQSeries adapter has a setting for “Ordered Delivery.”</span></span> <span data-ttu-id="ae3ab-158">「排序的傳遞」會指定此配接器將會發佈訊息批次、等候此批次完成，然後再發佈下一個批次。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-158">Ordered Delivery specifies that the adapter will publish a batch of messages, wait for it to complete, and then publish the next batch.</span></span> <span data-ttu-id="ae3ab-159">藉由啟用這項設定，基本上就可以從接收配接器移除所有平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-159">By enabling this setting, you essentially remove all parallelism from the receive adapter.</span></span> <span data-ttu-id="ae3ab-160">相反地，可以透過相反的方向調整參數，以提高接收配接器的接收速度。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-160">Conversely, tuning the parameters in the opposite way can be used to increase the receiving rate of a receive adapter.</span></span>  
  
 <span data-ttu-id="ae3ab-161">配接器可以盡量將所需的批次數提交給傳輸 Proxy。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-161">An adapter can submit as many batches as required to the transport proxy.</span></span> <span data-ttu-id="ae3ab-162">系統很沈重時，呼叫**完成**方法**IBTTransportBatch**介面將會封鎖訊息，直到所需的資源釋放給系統。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-162">When the system is heavily stressed, a call to the **Done** method of the **IBTTransportBatch** interface will block the message until the required resources are released to the system.</span></span>  
  
## <a name="plan-for-asynchronous-receive-and-send"></a><span data-ttu-id="ae3ab-163">非同步接收和傳送的計劃</span><span class="sxs-lookup"><span data-stu-id="ae3ab-163">Plan for Asynchronous Receive and Send</span></span>  
 <span data-ttu-id="ae3ab-164">BizTalk Server 傳訊 API 對於非同步程式設計有相當多的支援。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-164">The BizTalk Server messaging APIs have rich support for asynchronous programming.</span></span> <span data-ttu-id="ae3ab-165">如果您要撰寫可擴充的配接器，一開始請使用非同步模型來規劃，因為非同步模型提供較理想的並行處理。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-165">If you want to write a scalable adapter, plan on using the asynchronous model from the start because the asynchronous model provides better concurrency.</span></span>  
  
 <span data-ttu-id="ae3ab-166">在接收端，配接器提交給 BizTalk 傳訊引擎的訊息批次時 (藉由呼叫**ibttransportbatch:: Done**)，傳訊引擎使用其內部執行緒集區的工作排入佇列，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-166">On the receive side, when an adapter submits a batch of messages to the BizTalk Messaging Engine (by calling **IBTTransportBatch::Done**), the Messaging Engine queues up the work using its internal thread pool and returns immediately.</span></span> <span data-ttu-id="ae3ab-167">引擎會處理個別執行緒上的訊息，讓配接器可從其來源自由讀取更多的訊息並提交訊息，而不需要等候上一個訊息處理完畢。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-167">The engine processes the messages on a separate thread, leaving the adapter free to read more messages from its source and submit them without waiting for the previous message processing to complete.</span></span>  
  
 <span data-ttu-id="ae3ab-168">在傳送端，您的配接器可以是非同步，也可以是同步。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-168">On the send side, your adapter can be either asynchronous or synchronous.</span></span> <span data-ttu-id="ae3ab-169">但是，如果您的通訊協定支援非同步作業，您就應該使用這項支援來撰寫可擴充的配接器。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-169">However, if your protocol supports asynchronous operations, you should use this support to write a scalable adapter.</span></span> <span data-ttu-id="ae3ab-170">例如，檔案和 HTTP 傳送配接器是完全非同步，而且它們會執行非常少的封鎖/同步作業。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-170">For example, File and HTTP send adapters are fully asynchronous and they perform very few blocking/synchronous operations.</span></span>  
  
 <span data-ttu-id="ae3ab-171">非同步作業可確保傳訊引擎和您的配接器都將以平行方式繼續執行其各自的工作，而不會互相等候另一方來進行一般訊息處理。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-171">Asynchronous operations ensure that both the Messaging Engine and your adapter will continue to do their respective work in parallel and not wait on each other for normal message processing.</span></span>  
  
## <a name="use-batching-to-improve-performance"></a><span data-ttu-id="ae3ab-172">使用批次處理來改善效能</span><span class="sxs-lookup"><span data-stu-id="ae3ab-172">Use Batching to Improve Performance</span></span>  
 <span data-ttu-id="ae3ab-173">批次處理是撰寫可擴充之配接器的一個最佳起點，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-173">Batching is the best starting point for writing a scalable adapter.</span></span> <span data-ttu-id="ae3ab-174">傳送端和接收端配接器都是如此。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-174">This is true for both send-side and receive-side adapters.</span></span> <span data-ttu-id="ae3ab-175">每一個批次都會透過 BizTalk Server 內的資料庫交易，即使配接器為非交易式亦然。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-175">Every batch goes through a database transaction within BizTalk Server even if your adapter is nontransactional.</span></span> <span data-ttu-id="ae3ab-176">因為每一個交易都有關聯的固定延遲，所以您應該嘗試將一個以上的作業結合成單一批次，讓交易的數目減至最少。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-176">Because there is a fixed delay associated with each transaction, you should try to minimize the number of transactions by combining more than one operation into a single batch.</span></span>  
  
## <a name="do-not-starve-the-net-thread-pool"></a><span data-ttu-id="ae3ab-177">請勿讓 .NET 執行緒集區過於匱乏資源</span><span class="sxs-lookup"><span data-stu-id="ae3ab-177">Do Not Starve the .NET Thread Pool</span></span>  
 <span data-ttu-id="ae3ab-178">撰寫 BizTalk 配接器是撰寫 .NET 執行階段程式碼的一項練習；撰寫 .NET 執行階段程式碼一定是非同步程式設計的一項練習。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-178">Writing BizTalk adapters is an exercise in writing .NET runtime code; writing .NET runtime code is invariably an exercise in asynchronous programming.</span></span>  
  
 <span data-ttu-id="ae3ab-179">讓 .NET 執行緒集區過於匱乏資源對於 .NET 中的所有非同步程式設計都是一項風險，BizTalk 配接器程式設計人員尤其要避免。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-179">Starving the .NET thread pool is a risk to all asynchronous programming in .NET, and it is particularly important for the BizTalk adapter programmer to avoid.</span></span>  
  
 <span data-ttu-id="ae3ab-180">.NET 執行緒集區是一項受限但廣泛共用的資源，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-180">The .NET thread pool is a limited but widely shared resource.</span></span> <span data-ttu-id="ae3ab-181">撰寫程式碼來使用其中一個 .NET 執行緒集區執行緒並保留一段很長的時間，以阻止其他工作項目的執行，是一件很簡單的事情。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-181">It is easy to write code that uses one of the .NET thread pool threads and holds onto it for long time, blocking other work items from being executed.</span></span>  
  
 <span data-ttu-id="ae3ab-182">每當您使用**BeginInvoke**或使用計時器時，您會使用.NET 執行緒集區執行緒。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-182">Whenever you use **BeginInvoke** or use a timer, you are using a .NET thread pool thread.</span></span> <span data-ttu-id="ae3ab-183">如果您有多個工作片段来執行 （例如複製 mqseries 的訊息到 BizTalk Server 中），您應該執行一個工作項目 （一個批次的訊息到 BizTalk Server），然後重新排入佇列中的執行緒集區如果沒有更多工作來執行。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-183">If you have multiple pieces of work to do (for example copying messages out of MQSeries into BizTalk Server), you should execute one work item (one batch of messages into BizTalk Server) and then requeue in the thread pool if there is more work to do.</span></span> <span data-ttu-id="ae3ab-184">絕對不要待`while`執行緒上的迴圈。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-184">Never sit in a `while` loop on the thread.</span></span>  
  
 <span data-ttu-id="ae3ab-185">在具體來說，這表示取代`while`迴圈重複呼叫**BeginInvoke**。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-185">In concrete terms this means replacing `while` loops with repeated calls to **BeginInvoke**.</span></span> <span data-ttu-id="ae3ab-186">這項簡單的變更可大幅改善回應能力，並可擴充整個實作的能力。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-186">This simple change can dramatically improve the responsiveness and scale-out ability for the whole implementation.</span></span>  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a><span data-ttu-id="ae3ab-187">在限制批次大小時選擇正確的度量</span><span class="sxs-lookup"><span data-stu-id="ae3ab-187">Choose the Right Measurement When Limiting Batch Size</span></span>  
 <span data-ttu-id="ae3ab-188">如果您要以批次方式提交訊息給 BizTalk Server，請不要只依賴訊息計數來限制批次大小。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-188">If you are submitting messages to BizTalk Server in batches, do not limit the batch size based only on the message count.</span></span> <span data-ttu-id="ae3ab-189">會發生什麼事時已設定配接器批次作業只根據訊息計數，請考慮： 如果批次大小為二，而配接器取得四個訊息大小 4 KB、 8 KB、 1 MB 和 5 MB 分別會是第一個批次大小 12 KB而且第二個批次將成為 6 MB 的大小。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-189">Consider what happens when an adapter has been configured to batch based only on message count: If the batch size is two and the adapter gets four messages of size 4 KB, 8 KB, 1 MB, and 5MB respectively, the first batch will be of size 12 KB, and the second batch will be of size 6 MB.</span></span>  
  
 <span data-ttu-id="ae3ab-190">由於 BizTalk 傳訊引擎會循序處理單一批次中的所有訊息，所以此範例中第二個批次的處理速度要比第一個批次緩慢許多，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-190">Because the BizTalk Messaging Engine processes all messages in a single batch sequentially, the second batch in this example will be processed much more slowly than the first batch.</span></span> <span data-ttu-id="ae3ab-191">這樣實際上會減少輸送量。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-191">This is effectively reducing throughput.</span></span> <span data-ttu-id="ae3ab-192">此問題有一個更好的處理方法，就是根據訊息計數和批次中的總位元組數 (也就是以位元組計算的批次大小) 來進行批次處理。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-192">A better way to handle this problem is to batch based on both message count and total bytes in the batch (that is, batch size in bytes).</span></span> <span data-ttu-id="ae3ab-193">總位元組數並沒有識別常數，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-193">There is no magic number for total bytes.</span></span> <span data-ttu-id="ae3ab-194">但是在正常的處理案例中，如果批次大小超過 1 MB，您就會開始看到並行處理和輸送量變差。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-194">However, in a normal processing scenario, if the batch size exceeds 1 MB, you will start seeing poor concurrency and throughput.</span></span>  
  
 <span data-ttu-id="ae3ab-195">一般來說，配接器無從得知訊息，所以無法知道實際執行環境中的訊息大小。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-195">Generally adapters are message agnostic and they do not know the size of the messages in the production environment.</span></span> <span data-ttu-id="ae3ab-196">內送訊息的大小可能會有大幅的變動，</span><span class="sxs-lookup"><span data-stu-id="ae3ab-196">The sizes of the incoming messages are likely to vary significantly.</span></span> <span data-ttu-id="ae3ab-197">因此，務必要使用訊息計數和總位元組數來建置批次。</span><span class="sxs-lookup"><span data-stu-id="ae3ab-197">Because of this, always use message count and total bytes to build the batch.</span></span>