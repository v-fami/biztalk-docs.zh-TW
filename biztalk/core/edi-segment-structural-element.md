---
title: EDI 區段結構項目 |Microsoft 文件
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 1f474a3d-004a-4981-b155-b0a5775918ba
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 5b05d7a793fe515b8d0254d63b9b96994ddb35d9
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
ms.locfileid: "22242214"
---
# <a name="edi-segment-structural-element"></a><span data-ttu-id="bc18a-102">EDI 區段結構項目</span><span class="sxs-lookup"><span data-stu-id="bc18a-102">EDI Segment Structural Element</span></span>
<span data-ttu-id="bc18a-103">此區段包含一個或多個資料項目，而且是訊息中的中繼資訊單位。</span><span class="sxs-lookup"><span data-stu-id="bc18a-103">The segment contains one or more data elements, and is an intermediate unit of information in the message.</span></span> <span data-ttu-id="bc18a-104">每個區段三個字元的資料區段的識別項，以開始和結尾區段結束字元 （依預設單引號 （'））。</span><span class="sxs-lookup"><span data-stu-id="bc18a-104">Each segment starts with a three-character data segment identifier, and ends with a segment terminator (by default the apostrophe (')).</span></span> <span data-ttu-id="bc18a-105">區段中的資料項目是以資料項目分隔符號分隔。</span><span class="sxs-lookup"><span data-stu-id="bc18a-105">The data elements within the segment are separated by data element separators.</span></span> <span data-ttu-id="bc18a-106">預設的資料項目分隔符號是加號 (+)。</span><span class="sxs-lookup"><span data-stu-id="bc18a-106">The data element separator is by default the plus sign (+).</span></span> <span data-ttu-id="bc18a-107">區段可分類為強制或選用兩種。</span><span class="sxs-lookup"><span data-stu-id="bc18a-107">A segment is classified as Mandatory or Optional.</span></span> <span data-ttu-id="bc18a-108">外寄交換的分隔符號可以設定兩個交易夥伴之間，或做為後援交易夥伴協議一部分的協議中。</span><span class="sxs-lookup"><span data-stu-id="bc18a-108">Separators for outgoing interchanges can be set in the agreements between two trading partners or as part of fallback trading partner agreement.</span></span>  
  
## <a name="nesting"></a><span data-ttu-id="bc18a-109">巢狀</span><span class="sxs-lookup"><span data-stu-id="bc18a-109">Nesting</span></span>  
 <span data-ttu-id="bc18a-110">呼叫階層式關聯性來分組區段**巢狀**。</span><span class="sxs-lookup"><span data-stu-id="bc18a-110">Segments may be grouped in a hierarchical relationship called **nesting**.</span></span> <span data-ttu-id="bc18a-111">有兩個不同的巢狀類型： 明確和隱含。</span><span class="sxs-lookup"><span data-stu-id="bc18a-111">There are two distinct type of nesting: explicit and implicit.</span></span> <span data-ttu-id="bc18a-112">不過您在任何一個交換內，都只能使用一種巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="bc18a-112">Within any one interchange only one type of nesting can be used.</span></span>  
  
-   <span data-ttu-id="bc18a-113">明確巢狀使用具有巢狀迴圈的明確指示。</span><span class="sxs-lookup"><span data-stu-id="bc18a-113">Explicit nesting uses an explicit indication that the loop is nested.</span></span> <span data-ttu-id="bc18a-114">使用明確巢狀時，區段標記中的第一個元件資料項目將會是區段代碼。</span><span class="sxs-lookup"><span data-stu-id="bc18a-114">When explicit nesting is used, the first component data element in the segment tag will be the segment code.</span></span> <span data-ttu-id="bc18a-115">這個項目後面接著條件式元件資料項目，用來指出區段的層級和重複發生率。</span><span class="sxs-lookup"><span data-stu-id="bc18a-115">It will be followed by conditional component data elements indicating both the level and the incidence of repetition of the segment.</span></span> <span data-ttu-id="bc18a-116">這種用途的元件資料項目數目依據區段出現在訊息結構中的階層式層級而定。</span><span class="sxs-lookup"><span data-stu-id="bc18a-116">The number of component data elements used for this purpose depends upon the hierarchical level in which the segment appears in the message structure.</span></span> <span data-ttu-id="bc18a-117">如果區段出現在第一個層級，便會使用緊接在區段代碼後面的元件資料項目。</span><span class="sxs-lookup"><span data-stu-id="bc18a-117">If the segment is to appear at level one, the component data element immediately following the segment code will be used.</span></span> <span data-ttu-id="bc18a-118">如果區段出現在第二個層級，則會同時使用緊接在區段代碼後面的元件資料項目，以及下一個元件資料項目。</span><span class="sxs-lookup"><span data-stu-id="bc18a-118">If the segment is to appear at level two, the component data element immediately following the segment code and the next component data element will both be used.</span></span> <span data-ttu-id="bc18a-119">如果區段出現在第三個層級，將會使用接在區段代碼後面的三個元件資料項目。</span><span class="sxs-lookup"><span data-stu-id="bc18a-119">If the segment is to appear at level three, the three component data elements following the segment code will be used.</span></span> <span data-ttu-id="bc18a-120">管線無法執行比較資料與階層的結構驗證。</span><span class="sxs-lookup"><span data-stu-id="bc18a-120">Pipelines cannot perform structural verification comparing data to hierarchy.</span></span>  
  
-   <span data-ttu-id="bc18a-121">在隱含巢狀中，系統會嚴格遵守訊息結構中指定的區段順序。</span><span class="sxs-lookup"><span data-stu-id="bc18a-121">In Implicit nesting, the order of the segments specified in the message structure is strictly followed.</span></span> <span data-ttu-id="bc18a-122">區段之間具有隱含的巢狀關係，而且不需要其他任何指示就可以處理。</span><span class="sxs-lookup"><span data-stu-id="bc18a-122">The nesting relationship between the segments is implicitly evident and no further indication is required for processing.</span></span>  
  
## <a name="loops"></a><span data-ttu-id="bc18a-123">迴圈</span><span class="sxs-lookup"><span data-stu-id="bc18a-123">Loops</span></span>  
 <span data-ttu-id="bc18a-124">一或多個區段可以重複步驟，**迴圈**交易集內。</span><span class="sxs-lookup"><span data-stu-id="bc18a-124">One or more segment can repeat as a **loop** inside a transaction set.</span></span> <span data-ttu-id="bc18a-125">有兩個不同類型的迴圈： 未繫結和繫結。</span><span class="sxs-lookup"><span data-stu-id="bc18a-125">There are two distinct types of loops: unbounded and bounded.</span></span>  
  
### <a name="unbounded-loops"></a><span data-ttu-id="bc18a-126">未繫結迴圈</span><span class="sxs-lookup"><span data-stu-id="bc18a-126">Unbounded Loops</span></span>  
 <span data-ttu-id="bc18a-127">未繫結迴圈沒有用來標記迴圈開頭和結尾的唯一識別區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-127">An unbounded loop does not have a unique identifying segment to mark the beginning and end of the loop.</span></span> <span data-ttu-id="bc18a-128">未繫結迴圈會根據某個計數重複。</span><span class="sxs-lookup"><span data-stu-id="bc18a-128">An unbounded loop repeats according to a count.</span></span> <span data-ttu-id="bc18a-129">如果計數沒有值，迴圈將會重複兩次。</span><span class="sxs-lookup"><span data-stu-id="bc18a-129">If the count does not have a value, the loop will repeat twice.</span></span> <span data-ttu-id="bc18a-130">迴圈中的每個區段只能按照指定的順序出現一次。</span><span class="sxs-lookup"><span data-stu-id="bc18a-130">Each segment in the loop can occur only once in a specified order.</span></span>  
  
 <span data-ttu-id="bc18a-131">未繫結迴圈的開頭是由第一個唯一的資料項目所建立。</span><span class="sxs-lookup"><span data-stu-id="bc18a-131">The start of an unbounded loop is established by a first data element that is unique.</span></span> <span data-ttu-id="bc18a-132">第一個項目只能在每一次的迴圈中出現一次。</span><span class="sxs-lookup"><span data-stu-id="bc18a-132">The first element can appear once and only once in each occurrence.</span></span> <span data-ttu-id="bc18a-133">未繫結迴圈可按巢狀結構放在迴圈內；若是如此，內部的未繫結迴圈就不能從與任何外部迴圈相同的序數位置開始，而且開頭也不能使用與任何外部迴圈相同的區段識別碼做為開頭。</span><span class="sxs-lookup"><span data-stu-id="bc18a-133">Unbounded loops can be nested within loops; if so, the inner unbounded loop cannot start at the same ordinal position as any outer loop and cannot start with the same segment ID as any outer loop.</span></span> <span data-ttu-id="bc18a-134">巢狀迴圈包含的區段不能同時做為相同巢狀結構內任何外部迴圈的開頭區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-134">The nested loop cannot contain a segment that is also the beginning segment of any outer loop in the same nesting structure.</span></span>  
  
### <a name="bounded-loops"></a><span data-ttu-id="bc18a-135">已繫結迴圈</span><span class="sxs-lookup"><span data-stu-id="bc18a-135">Bounded Loops</span></span>  
 <span data-ttu-id="bc18a-136">已繫結迴圈開頭為預先定義的區段 LS (迴圈啟動)，而結尾則是預先定義的區段 LE (迴圈結束)。</span><span class="sxs-lookup"><span data-stu-id="bc18a-136">A bounded loop starts with the predefined segment LS (Loop Start) and ends with the predefined segment LE (Loop End).</span></span> <span data-ttu-id="bc18a-137">LS 區段的選擇性必須符合迴圈中的第一個區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-137">The optionality of the LS segment must match that of the first segment in the loop.</span></span> <span data-ttu-id="bc18a-138">繫結迴圈可以包含另一個繫結迴圈。</span><span class="sxs-lookup"><span data-stu-id="bc18a-138">A bounded loop can contain another bounded loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc18a-139">X12 中的繫結迴圈與 EDIFACT 中的明確迴圈功能相等。</span><span class="sxs-lookup"><span data-stu-id="bc18a-139">A bounded loop in X12 and an explicit loop in EDIFACT are equivalent.</span></span>  
  
 <span data-ttu-id="bc18a-140">迴圈中使用繫結來解決模稜兩可的問題。</span><span class="sxs-lookup"><span data-stu-id="bc18a-140">Binding is used in a loop to resolve ambiguity.</span></span> <span data-ttu-id="bc18a-141">LS/LE 區段上的需求指示項符合迴圈中第一個區段的需求指示項。</span><span class="sxs-lookup"><span data-stu-id="bc18a-141">The requirement designator on the LS/LE segments matches the requirement designator of the first segment of the loop.</span></span> <span data-ttu-id="bc18a-142">繫結可放寬某些經常重複之區段在用途上的結構化限制。</span><span class="sxs-lookup"><span data-stu-id="bc18a-142">Binding loosens structural restrictions imposed on the usage of certain commonly repeating segments.</span></span> <span data-ttu-id="bc18a-143">繫結區段沒有任何關於開頭區段 ID 的限制。</span><span class="sxs-lookup"><span data-stu-id="bc18a-143">Bounded segments have no restrictions with respect to the beginning segment ID.</span></span> <span data-ttu-id="bc18a-144">如此一來，同一個區段就可以啟動繫結迴圈，也可以在迴圈外使用，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="bc18a-144">This enables the same segment to start a bounded loop and be used outside of the loop, as in the following example:</span></span>  
  
```  
AA  
LS  
BB  
CC  
LE  
BB  
```  
  
 <span data-ttu-id="bc18a-145">允許有從屬迴圈 (迴圈內的迴圈)。</span><span class="sxs-lookup"><span data-stu-id="bc18a-145">Subordinate loops (loops within loops) are allowed.</span></span> <span data-ttu-id="bc18a-146">如果繫結迴圈按巢狀結構放在迴圈內，內部迴圈不能從與任何外部迴圈相同的序數位置開始。</span><span class="sxs-lookup"><span data-stu-id="bc18a-146">If bounded loops are nested within loops, the inner loop cannot start at the same ordinal position as any outer loop.</span></span> <span data-ttu-id="bc18a-147">內部繫結迴圈必須在緊接的外部迴圈之前結束。</span><span class="sxs-lookup"><span data-stu-id="bc18a-147">The inner bounded loop must end before the immediate outer loop.</span></span>  
  
 <span data-ttu-id="bc18a-148">交易集內的每個繫結迴圈都必須擁有唯一定義的 <loop_id> 值，內含一到四個大寫字母或一到四位數字。</span><span class="sxs-lookup"><span data-stu-id="bc18a-148">Each bounded loop within a transaction set must have a uniquely defined <loop_id> value of one to four uppercase letters or numeric digits.</span></span> <span data-ttu-id="bc18a-149">建議您在對應的 LS 和 LE 區段中包含相同的唯一 <loop_id> 值。</span><span class="sxs-lookup"><span data-stu-id="bc18a-149">It is recommended that the corresponding LS and LE segments contain the same unique <loop_id> value.</span></span> <span data-ttu-id="bc18a-150">< Loop_id > 資料項目將做為 「 一般 」 資料項目處理，並驗證資料型別、 最小/最大長度、 選用性等等。跨區段驗證 （跨 LS 和 LE） 將不會執行。BizTalk Server 會透過確認只有 LS 和 LE 區段而無其他內容存在，驗證模稜兩可解析。</span><span class="sxs-lookup"><span data-stu-id="bc18a-150">The <loop_id> data element will be processed as a “regular” data element and validated for data type, min/max length, optionality, etc. Cross-segment validation (across LS and LE) will not be carried out. BizTalk Server will verify ambiguity resolution via the presence of the LS and LE segment and nothing else.</span></span> <span data-ttu-id="bc18a-151">若發生違反資料項目規則的情況，將會接受交易集並產生錯誤，而且 BizTalk Server 也會在通知中傳回 AK501=E 和 AK2/AK3 的適當評估。</span><span class="sxs-lookup"><span data-stu-id="bc18a-151">In the case of data-element rule violation, the transaction set is accepted with errors, and BizTalk Server returns AK501=E and the appropriate valuation in AK2/AK3 in the ACK.</span></span>  
  
 <span data-ttu-id="bc18a-152">您也必須強制執行 LS/LE 區段的剖析作業。</span><span class="sxs-lookup"><span data-stu-id="bc18a-152">It is also required that pairing of LS/LE segments is enforced.</span></span> <span data-ttu-id="bc18a-153">如果出現不相符的情況，便會因為原有的模稜兩可解析問題而拒絕交易集，並於事件檢視器和 997 通知中傳回 AK501 = E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="bc18a-153">In case of a mismatch, the transaction set is rejected due to an inherent ambiguity resolution issue, and AK501 = E and AK502 = 5 are returned in the Event Viewer and the 997 ACK.</span></span> <span data-ttu-id="bc18a-154">當遺失 LS/LE 這兩個或其中一個區段，但交易集並未模稜兩可時，將會接受交易集並產生錯誤，而且會傳回 AK501=E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="bc18a-154">When  either or both LS/LE segments are missing, but the transaction set is not ambiguous, the transaction set will be accepted with errors, and AK501=E and AK502 = 5 returned.</span></span>  
  
 <span data-ttu-id="bc18a-155">LS/LE 配對可以是選擇性或強制性的。</span><span class="sxs-lookup"><span data-stu-id="bc18a-155">An LS/LE pair can be optional or mandatory.</span></span> <span data-ttu-id="bc18a-156">不過，除非這個配對包含在可重複的父迴圈中，否則此將永遠不可重複。</span><span class="sxs-lookup"><span data-stu-id="bc18a-156">However, unless the pair is contained in a parent loop that is repeatable, the pair can never be repeatable.</span></span> <span data-ttu-id="bc18a-157">不論是哪一種情況，LS/LE 配對的 MaxOccurs 都可以是 1，但不能大於 1。這是結構描述驗證中的強制條件。</span><span class="sxs-lookup"><span data-stu-id="bc18a-157">In either case, both MaxOccurs for an LS/LE pair can be 1, but not greater than 1.This is enforced in schema validation.</span></span>  
  
 <span data-ttu-id="bc18a-158">EDI 解譯器和 EDI 組合器會處理 LS 和 LE 區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-158">The EDI Disassembler and EDI Assembler handle LS and LE segments.</span></span> <span data-ttu-id="bc18a-159">在剖析過程中，解譯器會建立 LS 和 LE 區段的 XML 節點，並驗證區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-159">During parsing, the Disassembler created XML nodes for the LS and LE segments, and validates the segments.</span></span> <span data-ttu-id="bc18a-160">在序列化過程中，組合器則會從 XML 節點建立 LS 和 LE 區段，並驗證這兩個區段。</span><span class="sxs-lookup"><span data-stu-id="bc18a-160">During serializing, the Assembler creates the LS and LE segments from XML nodes, and validates them.</span></span> <span data-ttu-id="bc18a-161">如果預期的 LS 或 LE 區段遺失，交易就會擱置/拒絕 AK501 = E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="bc18a-161">If an expected LS or LE segment is missing, the transaction set is suspended/rejected with an AK501 = E and AK502 = 5.</span></span> <span data-ttu-id="bc18a-162">如果 LS/LE 區段存在但沒有對應的資料元素，而且已啟用 EDI 驗證，交易集已接受，發生錯誤和 AK501 = E 和 AK502 = 5 會顯示在 事件檢視器和 997 通知。</span><span class="sxs-lookup"><span data-stu-id="bc18a-162">If LS/LE segments are present without corresponding data element, and EDI validation is enabled, the transaction set is accepted with errors and AK501 = E and AK502 = 5 are reported in the Event Viewer and the 997 ACK.</span></span>