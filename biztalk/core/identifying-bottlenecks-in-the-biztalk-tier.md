---
title: 識別 BizTalk 層中的瓶頸 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: f38ade78-8af3-4485-9b2a-5e4cdba965d2
caps.latest.revision: 10
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8b53410466478ea7e493d043f42b5de86ec9921c
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/27/2018
ms.locfileid: "36996247"
---
# <a name="identifying-bottlenecks-in-the-biztalk-tier"></a><span data-ttu-id="77a8e-102">識別 BizTalk 層中的瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-102">Identifying Bottlenecks in the BizTalk Tier</span></span>
<span data-ttu-id="77a8e-103">BizTalk 層可以區分為下列功能區域：</span><span class="sxs-lookup"><span data-stu-id="77a8e-103">The BizTalk tier can be divided into the following functional areas:</span></span>  
  
- <span data-ttu-id="77a8e-104">接收</span><span class="sxs-lookup"><span data-stu-id="77a8e-104">Receiving</span></span>  
  
- <span data-ttu-id="77a8e-105">Processing</span><span class="sxs-lookup"><span data-stu-id="77a8e-105">Processing</span></span>  
  
- <span data-ttu-id="77a8e-106">傳輸</span><span class="sxs-lookup"><span data-stu-id="77a8e-106">Transmitting</span></span>  
  
- <span data-ttu-id="77a8e-107">追蹤</span><span class="sxs-lookup"><span data-stu-id="77a8e-107">Tracking</span></span>  
  
- <span data-ttu-id="77a8e-108">其他</span><span class="sxs-lookup"><span data-stu-id="77a8e-108">Other</span></span>  
  
  <span data-ttu-id="77a8e-109">對於這些區域，如果系統資源 (CPU、記憶體和磁碟) 看來已經飽和，則藉由向上擴充來升級伺服器。</span><span class="sxs-lookup"><span data-stu-id="77a8e-109">For these areas, if the system resources (CPU, memory, and disk) appear to be saturated, upgrade the server by scaling up.</span></span> <span data-ttu-id="77a8e-110">如果系統資源尚未飽和，請執行在此節中描述的步驟。</span><span class="sxs-lookup"><span data-stu-id="77a8e-110">If the system resources are not saturated, perform the steps described in this section.</span></span>  
  
## <a name="bottlenecks-in-the-receive-location"></a><span data-ttu-id="77a8e-111">接收位置中的瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-111">Bottlenecks in the Receive Location</span></span>  
 <span data-ttu-id="77a8e-112">如果訊息開始在接受位置累積 (例如，檔案接收資料夾變得很大或輸出佇列無法很快耗盡)，即代表內部的節流導致系統吸收資料的速率不夠快，無法跟上內送負荷 (如果訂閱者處理資料的速度不夠快，而導致資料庫資料表中開始累積待處理的項目，BizTalk 就會降低接收速率)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-112">If messages start building up at the receive location (for example, file receive folder grows large or outgoing queue is not being drained fast enough) this is an indication that the system is unable to absorb data at a sufficiently fast rate to keep up with the incoming load either due to internal throttling (BizTalk reduces receiving rate if the subscribers are unable to process data fast enough causing backlog buildup in the database tables).</span></span> <span data-ttu-id="77a8e-113">如果瓶頸是由於硬體限制而造成，請嘗試向上擴充硬體。</span><span class="sxs-lookup"><span data-stu-id="77a8e-113">In case the bottleneck is caused due to hardware limitations try scaling up.</span></span> <span data-ttu-id="77a8e-114">也可以藉由將「主控件執行個體」(伺服器) 新增至對應到接收處理常式的「主控件」來向外擴充。</span><span class="sxs-lookup"><span data-stu-id="77a8e-114">It is also possible to scale out by adding a Host Instance (server) to the Host mapped to the receive handler.</span></span> <span data-ttu-id="77a8e-115">使用 Perfmon 來監視系統上的資源利用。</span><span class="sxs-lookup"><span data-stu-id="77a8e-115">Use Perfmon to monitor the resource utilization on the system.</span></span> <span data-ttu-id="77a8e-116">確認外部的接收位置並非瓶頸肇因，這點很重要。</span><span class="sxs-lookup"><span data-stu-id="77a8e-116">It is important to confirm that the external receive location is not the cause of the bottleneck.</span></span> <span data-ttu-id="77a8e-117">例如，遠端的檔案共用由於高磁碟 IO 速度而飽和，或者裝載遠端外寄佇列的伺服器並未飽和，或者用來產生 HTTP/SOAP 負載的用戶端尚未用完執行緒。</span><span class="sxs-lookup"><span data-stu-id="77a8e-117">For example, remote file share is saturated due to high disk IO or the server hosting the remote outgoing queue is not saturated or the client used to generate HTTP/SOAP load is not starved on threads.</span></span>  
  
## <a name="processing-bottlenecks"></a><span data-ttu-id="77a8e-118">處理瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-118">Processing Bottlenecks</span></span>  
 <span data-ttu-id="77a8e-119">如果主控件佇列-長度計數 （請參閱以下的 Perfmon 計數器表格） 正在攀升，則表示該協調流程未完成速度不夠快。</span><span class="sxs-lookup"><span data-stu-id="77a8e-119">If the Host Queue - Length count (see the Perfmon counter table below) is climbing, it indicates that the orchestrations are not completing fast enough.</span></span> <span data-ttu-id="77a8e-120">這可能是由於記憶體爭用或 CPU 飽和而導致。</span><span class="sxs-lookup"><span data-stu-id="77a8e-120">This could be due to memory contention or CPU saturation.</span></span>  
  
 <span data-ttu-id="77a8e-121">如果協調流程伺服器是瓶頸所在，請使用 Perfmon 以識別來源。</span><span class="sxs-lookup"><span data-stu-id="77a8e-121">If the orchestration servers are the bottleneck, use Perfmon to identify the source.</span></span>  
  
 <span data-ttu-id="77a8e-122">如果伺服器受限於 CPU 處理能力，請考慮下列各項：</span><span class="sxs-lookup"><span data-stu-id="77a8e-122">If the server is CPU bound, consider the following:</span></span>  
  
-   <span data-ttu-id="77a8e-123">如果工作流程很複雜，可考慮將協調流程切割為多個較小的協調流程</span><span class="sxs-lookup"><span data-stu-id="77a8e-123">If the workflow is complex consider splitting the orchestration into multiple smaller orchestrations</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="77a8e-124">將協調流程切割為多個工作流程，可能會導致額外的延遲狀況，並增加複雜度。</span><span class="sxs-lookup"><span data-stu-id="77a8e-124">Splitting an orchestration into multiple workflows can cause additional latency and add complexity.</span></span>  
  
-   <span data-ttu-id="77a8e-125">如果有使用複雜的對應，請考慮是否可將這些對應移至接收埠/傳送埠 (請確認這些埠是否有額外的頻寬)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-125">If complex maps are used consider whether they can be moved to the Receive/Send ports (verify which ports have additional bandwidth).</span></span>  
  
-   <span data-ttu-id="77a8e-126">請考慮向上擴充硬體，或者如有可能，請考慮藉由設定額外的處理伺服器來向外擴充。</span><span class="sxs-lookup"><span data-stu-id="77a8e-126">Consider scaling up the hardware or if possible consider scaling out by configuring an additional processing server.</span></span>  
  
## <a name="transmitting-bottlenecks"></a><span data-ttu-id="77a8e-127">傳輸瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-127">Transmitting Bottlenecks</span></span>  
 <span data-ttu-id="77a8e-128">如果傳輸伺服器的資源使用已經飽和 (例如，磁碟、記憶體、CPU)，請考慮向上擴充伺服器，或者如有可能，請考慮向外擴充到其他的傳送主機伺服器。</span><span class="sxs-lookup"><span data-stu-id="77a8e-128">If the transmitting server is saturated on resources (for example, disk, memory, CPU), consider scaling-up the server or if possible consider scaling-out to additional send host servers.</span></span> <span data-ttu-id="77a8e-129">如果目的地 (在 BizTalk 外部) 無法以夠快的速率接收資料，則傳送層可能會成為瓶頸。</span><span class="sxs-lookup"><span data-stu-id="77a8e-129">The sending tier could become the bottleneck if the destination (external to BizTalk) is unable to receive data fast enough.</span></span> <span data-ttu-id="77a8e-130">這會導致訊息在 MessageBox 資料庫 (Application SendHostQ) 中累積。</span><span class="sxs-lookup"><span data-stu-id="77a8e-130">This will cause messages to buildup in the MessageBox database (Application SendHostQ).</span></span>  
  
 <span data-ttu-id="77a8e-131">如果端點位於拓撲的範圍內，請考慮在目的地導致累積的原因。</span><span class="sxs-lookup"><span data-stu-id="77a8e-131">If at all the endpoints are within the scope of the topology, consider isolating the cause at the destination.</span></span> <span data-ttu-id="77a8e-132">例如，HTTP/SOAP 位置的設定是否對接收負載進行過最佳化，或者是否可以向外擴展？</span><span class="sxs-lookup"><span data-stu-id="77a8e-132">For example, is the HTTP/SOAP location optimally configured to receive load or could it be scaled-out?</span></span> <span data-ttu-id="77a8e-133">如果目的地的成長是由於 BizTalk 傳遞的輸出訊息過多而造成？</span><span class="sxs-lookup"><span data-stu-id="77a8e-133">Is the destination growing due to excessive output messages delivered by BizTalk?</span></span> <span data-ttu-id="77a8e-134">如果答案為真，請考慮施行維護計畫，以封存及清除目的地訊息。</span><span class="sxs-lookup"><span data-stu-id="77a8e-134">If yes, consider a maintenance plan to archive and purge the destination messages.</span></span> <span data-ttu-id="77a8e-135">例如，目的資料夾中若含有大量檔案，可能會嚴重影響 BizTalk 服務將資料認可到磁碟機的能力。</span><span class="sxs-lookup"><span data-stu-id="77a8e-135">For example, large numbers of files in a destination folder can severely impact the ability of the BizTalk service to commit data to the disk drive.</span></span>  
  
## <a name="tracking-bottlenecks"></a><span data-ttu-id="77a8e-136">追蹤瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-136">Tracking Bottlenecks</span></span>  
 <span data-ttu-id="77a8e-137">追蹤主控件執行個體負責將 BAM 和追蹤的訊息事件和服務執行個體的資料從 MessageBox 資料庫 （TrackingData 資料表） 移至 BizTalkDTADb 和 （或） BAMPrimaryImport 資料庫資料表。</span><span class="sxs-lookup"><span data-stu-id="77a8e-137">The Tracking Host Instance is responsible for moving both BAM & tracked message event and service instance data from the MessageBox database (TrackingData table) to the BizTalkDTADb and/or BAMPrimaryImport database tables.</span></span> <span data-ttu-id="77a8e-138">如果設定多個 MessageBox 資料庫，則追蹤主控件執行個體會針對每個 MessageBox 使用四個執行緒。</span><span class="sxs-lookup"><span data-stu-id="77a8e-138">If multiple MessageBox databases are configured the tracking host instance uses four threads per MessageBox.</span></span>  
  
 <span data-ttu-id="77a8e-139">這個主控件執行個體有可能會變成受限於 CPU 處理能力。</span><span class="sxs-lookup"><span data-stu-id="77a8e-139">It is possible that this host instance could get CPU bound.</span></span> <span data-ttu-id="77a8e-140">如果是這種情況，請考慮向上擴充伺服器，或者設定啟用「主控件追蹤」的其他伺服器來向外擴充。</span><span class="sxs-lookup"><span data-stu-id="77a8e-140">If that is the case consider scaling-up the server or scale-out by configuring an additional server with Host Tracking enabled.</span></span> <span data-ttu-id="77a8e-141">多重主控件執行個體會自動針對設定的多個 MessageBoxes 進行平衡負載。</span><span class="sxs-lookup"><span data-stu-id="77a8e-141">The multiple host instances will automatically balance load for the multiple MessageBoxes configured.</span></span>  
  
 <span data-ttu-id="77a8e-142">如果 MessageBox 資料庫中的 TrackingData 資料表開始累積，通常是因為 BizTalkDTADb 和 (或) BAMPrimaryImport y 資料庫上的資料維護工作未依照設定執行，導致 BizTalkDTADb 和 (或) BAMPrimaryImport 資料庫成長。</span><span class="sxs-lookup"><span data-stu-id="77a8e-142">If the TrackingData table in the MessageBox database starts backing up, it is usually because the data maintenance jobs on the BizTalkDTADb and/or BAMPrimaryImport database are not running as configured causing growth of the BizTalkDTADb and/or BAMPrimaryImport database.</span></span> <span data-ttu-id="77a8e-143">資料庫一旦過度成長，就可能會對追蹤主控件將資料插入這些資料表的能力造成負面影響，導致追蹤資料在 MessageBox 資料庫資料表中累積。</span><span class="sxs-lookup"><span data-stu-id="77a8e-143">Once these databases grow too large it can have a negative impact on the ability of the tracking host to insert data into these tables causing the tracked data to backup in the MessageBox database tables.</span></span> <span data-ttu-id="77a8e-144">MessageBox->TrackingData 資料表的成長會促使節流開始作用。</span><span class="sxs-lookup"><span data-stu-id="77a8e-144">The growth of the MessageBox->TrackingData table will cause throttling to kick in.</span></span>  
  
## <a name="other"></a><span data-ttu-id="77a8e-145">其他</span><span class="sxs-lookup"><span data-stu-id="77a8e-145">Other</span></span>  
 <span data-ttu-id="77a8e-146">設定部署拓撲，使不同的功能可在專用的外掛式主控件執行個體中執行。</span><span class="sxs-lookup"><span data-stu-id="77a8e-146">Configure the deployment topology such that different functionality runs in dedicated isolated host instances.</span></span> <span data-ttu-id="77a8e-147">如此，每個主控件執行個體都可取得自己的資源集 (在 32 位元的系統上，可享有 2GB 的虛擬記憶體位址空間、控制代碼、執行緒等)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-147">This way each host instance gets its own set of resources (on a 32-bit system, 2GB virtual memory address space, handles, threads).</span></span> <span data-ttu-id="77a8e-148">如果伺服器有足夠的資源 (足夠的 CUP 空間、記憶體) 來裝載多個主控件執行個體，可以將這些執行個體設定為在相同的實體電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="77a8e-148">If the server is powerful enough (sufficient CPU headroom, memory) to host multiple host instances they can all be configured to run on the same physical machine.</span></span> <span data-ttu-id="77a8e-149">如果沒有，這麼做也可以將功能移至專用的伺服器，而簡化向外擴充的作業。</span><span class="sxs-lookup"><span data-stu-id="77a8e-149">If not, this also makes it easy to scale-out by moving the functionality to dedicated servers.</span></span> <span data-ttu-id="77a8e-150">在多個伺服器上執行相同的功能，也可以提供具有高度可用性的組態。</span><span class="sxs-lookup"><span data-stu-id="77a8e-150">Running the same functionality on multiple servers also serves to provide a highly available configuration.</span></span>  
  
## <a name="biztalk-system-performance-counters"></a><span data-ttu-id="77a8e-151">BizTalk 系統效能計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-151">BizTalk System Performance Counters</span></span>  
  
|<span data-ttu-id="77a8e-152">Object</span><span class="sxs-lookup"><span data-stu-id="77a8e-152">Object</span></span>|<span data-ttu-id="77a8e-153">執行個體</span><span class="sxs-lookup"><span data-stu-id="77a8e-153">Instance</span></span>|<span data-ttu-id="77a8e-154">計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-154">Counter</span></span>|<span data-ttu-id="77a8e-155">監控目的</span><span class="sxs-lookup"><span data-stu-id="77a8e-155">Monitoring Purpose</span></span>|  
|------------|--------------|-------------|------------------------|  
|<span data-ttu-id="77a8e-156">處理器</span><span class="sxs-lookup"><span data-stu-id="77a8e-156">Processor</span></span>|<span data-ttu-id="77a8e-157">_Total</span><span class="sxs-lookup"><span data-stu-id="77a8e-157">_Total</span></span>|<span data-ttu-id="77a8e-158">% 處理器時間</span><span class="sxs-lookup"><span data-stu-id="77a8e-158">% Processor Time</span></span>|<span data-ttu-id="77a8e-159">資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-159">Resource Contention</span></span>|  
|<span data-ttu-id="77a8e-160">處理</span><span class="sxs-lookup"><span data-stu-id="77a8e-160">Process</span></span>|<span data-ttu-id="77a8e-161">BTSNTSvc</span><span class="sxs-lookup"><span data-stu-id="77a8e-161">BTSNTSvc</span></span>|<span data-ttu-id="77a8e-162">虛擬位元組</span><span class="sxs-lookup"><span data-stu-id="77a8e-162">Virtual Bytes</span></span>|<span data-ttu-id="77a8e-163">記憶體流失/膨脹</span><span class="sxs-lookup"><span data-stu-id="77a8e-163">Memory Leak/Bloat</span></span>|  
|<span data-ttu-id="77a8e-164">處理</span><span class="sxs-lookup"><span data-stu-id="77a8e-164">Process</span></span>|<span data-ttu-id="77a8e-165">BTSNTSvc</span><span class="sxs-lookup"><span data-stu-id="77a8e-165">BTSNTSvc</span></span>|<span data-ttu-id="77a8e-166">私用位元組</span><span class="sxs-lookup"><span data-stu-id="77a8e-166">Private Bytes</span></span>|<span data-ttu-id="77a8e-167">記憶體流失/膨脹</span><span class="sxs-lookup"><span data-stu-id="77a8e-167">Memory Leak/Bloat</span></span>|  
|<span data-ttu-id="77a8e-168">處理</span><span class="sxs-lookup"><span data-stu-id="77a8e-168">Process</span></span>|<span data-ttu-id="77a8e-169">BTSNTSvc</span><span class="sxs-lookup"><span data-stu-id="77a8e-169">BTSNTSvc</span></span>|<span data-ttu-id="77a8e-170">控制碼計數</span><span class="sxs-lookup"><span data-stu-id="77a8e-170">Handle Count</span></span>|<span data-ttu-id="77a8e-171">資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-171">Resource Contention</span></span>|  
|<span data-ttu-id="77a8e-172">處理</span><span class="sxs-lookup"><span data-stu-id="77a8e-172">Process</span></span>|<span data-ttu-id="77a8e-173">BTSNTSvc</span><span class="sxs-lookup"><span data-stu-id="77a8e-173">BTSNTSvc</span></span>|<span data-ttu-id="77a8e-174">執行緒計數</span><span class="sxs-lookup"><span data-stu-id="77a8e-174">Thread Count</span></span>|<span data-ttu-id="77a8e-175">資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-175">Resource Contention</span></span>|  
|<span data-ttu-id="77a8e-176">實體磁碟</span><span class="sxs-lookup"><span data-stu-id="77a8e-176">Physical Disk</span></span>|<span data-ttu-id="77a8e-177">_Total</span><span class="sxs-lookup"><span data-stu-id="77a8e-177">_Total</span></span>|<span data-ttu-id="77a8e-178">% 閒置時間</span><span class="sxs-lookup"><span data-stu-id="77a8e-178">% Idle Time</span></span>|<span data-ttu-id="77a8e-179">資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-179">Resource Contention</span></span>|  
|<span data-ttu-id="77a8e-180">實體磁碟</span><span class="sxs-lookup"><span data-stu-id="77a8e-180">Physical Disk</span></span>|<span data-ttu-id="77a8e-181">_Total</span><span class="sxs-lookup"><span data-stu-id="77a8e-181">_Total</span></span>|<span data-ttu-id="77a8e-182">Current Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="77a8e-182">Current Disk Queue Length</span></span>|<span data-ttu-id="77a8e-183">資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-183">Resource Contention</span></span>|  
  
### <a name="cpu-contention"></a><span data-ttu-id="77a8e-184">CPU 爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-184">CPU Contention</span></span>  
 <span data-ttu-id="77a8e-185">如果處理器已飽和，請考慮將接收從傳送和協調流程分隔，以分割應用程式。</span><span class="sxs-lookup"><span data-stu-id="77a8e-185">If the processor is saturated consider fragmenting the application by separating the Receiving from the Sending and Orchestration.</span></span> <span data-ttu-id="77a8e-186">完成這項作業的方法為建立分隔的主控件、將這些主控件對應到特定的功能 (接收/傳送/協調流程/追蹤)，然後將專用的伺服器新增至這些分隔的主控件。</span><span class="sxs-lookup"><span data-stu-id="77a8e-186">The way to accomplish this is by creating separate hosts, mapping these hosts to specific functionality (Receive/Send/Orchestrations/Tracking) and adding dedicated servers to these separate hosts.</span></span> <span data-ttu-id="77a8e-187">一般而言，協調流程功能是很耗費 CPU 的，所以將系統設定為在分隔的專用伺服器上執行協調流程，有助於改善整體系統的輸送量。</span><span class="sxs-lookup"><span data-stu-id="77a8e-187">Orchestration functionality is generally known to be CPU hungry, thus configuring the system such that the orchestrations execute on a separate dedicated server helps improve overall system throughput.</span></span>  
  
 <span data-ttu-id="77a8e-188">如果要部署多個協調流程，可以將這些協調流程登錄到不同的專用協調流程主控件。</span><span class="sxs-lookup"><span data-stu-id="77a8e-188">If multiple orchestrations are deployed, it is possible to enlist them to different dedicated Orchestration-Hosts.</span></span> <span data-ttu-id="77a8e-189">將不同的實體伺服器對應到專用的協調流程主控件，可確保不同的協調流程均已隔離，而不會爭用相同實體位置空間或相同伺服器的共用資源。</span><span class="sxs-lookup"><span data-stu-id="77a8e-189">Mapping different physical servers to the dedicated Orchestration-Hosts ensures that the different orchestrations are isolated and do not contend for shared resources either in the same physical address space or on the same server.</span></span>  
  
### <a name="memory-starvation"></a><span data-ttu-id="77a8e-190">記憶體耗盡</span><span class="sxs-lookup"><span data-stu-id="77a8e-190">Memory Starvation</span></span>  
 <span data-ttu-id="77a8e-191">高輸送量實例可能增加對系統記體體的需求。</span><span class="sxs-lookup"><span data-stu-id="77a8e-191">High throughput scenarios can have increased demand on system memory.</span></span> <span data-ttu-id="77a8e-192">由於 32 位元的程序受限於它可以消耗的記憶體量，所以建議將接收/程序/傳送等功能分隔到個別的主控件執行個體中，使每個主控件都能接收自己的 2GB 位址空間。</span><span class="sxs-lookup"><span data-stu-id="77a8e-192">Since a 32-bit process is limited by the amount of memory it can consume, it is recommended to separate the Receive/Process/Send functionality into separate Host Instances such that each host receives its own 2GB address space.</span></span> <span data-ttu-id="77a8e-193">此外，如果在相同的實體伺服器上執行多個主控件執行個體，則升級到 4/8GB 記憶體可避免將資料從實際的記憶體磁碟交換到磁碟，是很有用的作法。</span><span class="sxs-lookup"><span data-stu-id="77a8e-193">In addition, if multiple Host Instances are running on the same physical server it is useful to upgrade to 4/8GB memory to avoid having to swap data to disk from real memory.</span></span> <span data-ttu-id="77a8e-194">長時間執行的協調流程可以保留已配置的記憶體，再導致記憶體膨脹，並促使節流開始作用。</span><span class="sxs-lookup"><span data-stu-id="77a8e-194">Long running orchestrations can hold onto allocated memory longer causing memory bloat and thus throttling to kick in.</span></span> <span data-ttu-id="77a8e-195">大型訊息也可能導致高記憶體耗用量。</span><span class="sxs-lookup"><span data-stu-id="77a8e-195">Large messages can also cause high memory consumption.</span></span>  
  
 <span data-ttu-id="77a8e-196">可由降低處理大型訊息時，克服這個記憶體膨脹問題**內部的訊息佇列大小**並**每一 CPU 的內含式訊息**特定主控件的值。</span><span class="sxs-lookup"><span data-stu-id="77a8e-196">It is possible to overcome this memory bloat problem when large messages are being processed by lowering the **Internal Message Queue Size** and **In-process Messages per CPU** values for the specific host.</span></span>  
  
### <a name="disk-contention"></a><span data-ttu-id="77a8e-197">磁碟爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-197">Disk Contention</span></span>  
 <span data-ttu-id="77a8e-198">如果磁碟已飽和 （例如，檔案 /MSMQ 傳輸） 請考慮升級為多磁針和分割磁碟使用 RAID 1 + 0。</span><span class="sxs-lookup"><span data-stu-id="77a8e-198">If the disks are saturated (for example, File/MSMQ transports) consider upgrading to multiple spindles and striping the disks with RAID 1+0.</span></span> <span data-ttu-id="77a8e-199">此外每當使用 FILE 傳輸務必要確保的資料夾 （接收和傳送） 不會變得太大 (> 50,000 檔案)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-199">In addition whenever using the FILE transport it is important to ensure that the folders (both Receive and Send) do not grow too large (>50,000 files).</span></span>  
  
 <span data-ttu-id="77a8e-200">如果由於下面所述的各種原因，BizTalk Server 選擇對內送到系統中的資料進行節流，接收資料夾就可能變得很大。</span><span class="sxs-lookup"><span data-stu-id="77a8e-200">The Receive folder can grow large if BizTalk Server chooses to throttle incoming data into the system due to various reasons mentioned below.</span></span> <span data-ttu-id="77a8e-201">從傳送資料夾移動資料很重要，因為這麼做這個資料夾的成長就不會影響 BizTalk Server 寫入其他資料的能力。</span><span class="sxs-lookup"><span data-stu-id="77a8e-201">It is also important to move data from the send folder so that growth in this folder does not impact the ability of BizTalk Server to write additional data.</span></span> <span data-ttu-id="77a8e-202">對於非交易式的 MSMQ 佇列而言，則建議在遠端建立接收佇列，以減輕 BizTalk Server 上的磁碟爭用情況。</span><span class="sxs-lookup"><span data-stu-id="77a8e-202">For non-transactional MSMQ queues, it is recommended to remotely create the receive queues so that disk contention is reduced on the BizTalk server.</span></span>  
  
 <span data-ttu-id="77a8e-203">這項組態 (遠端非交易式佇列) 也提供高可用性的額外優點，因為裝載佇列的遠端伺服器可以叢集化。</span><span class="sxs-lookup"><span data-stu-id="77a8e-203">This configuration (remote non-transactional queues) also provides the added benefit of high availability as the remote server hosting the queue can be clustered.</span></span>  
  
### <a name="other-system-resource-contention"></a><span data-ttu-id="77a8e-204">其他系統資源爭用</span><span class="sxs-lookup"><span data-stu-id="77a8e-204">Other System Resource Contention</span></span>  
 <span data-ttu-id="77a8e-205">根據所設定的傳輸本質，可能有必要針對 HTTP/SOAP 設定 IIS 之類的系統資源 (例如，MaxIOThreads、MaxWorkerThreads)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-205">Depending on the nature of the transport configured it may be necessary to configure system resources like IIS for HTTP/SOAP (for example, MaxIOThreads, MaxWorkerThreads).</span></span>  
  
### <a name="downstream-bottlenecks"></a><span data-ttu-id="77a8e-206">下游瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-206">Downstream Bottlenecks</span></span>  
 <span data-ttu-id="77a8e-207">如果下游系統無法以夠快的速度從 BizTalk 接收資料，這些輸出資料就會在 BizTalk 資料庫中累積而導致膨脹，促使節流開始作用，使接收管道壓縮，因此對 BizTalk 系統的整體輸送量造成衝擊。</span><span class="sxs-lookup"><span data-stu-id="77a8e-207">If the downstream system is unable to receive data fast enough from BizTalk this output data will back up within the BizTalk databases resulting in bloat causing throttling to kick in shrinking the receive pipe thereby impacting the overall throughput of the BizTalk system.</span></span> <span data-ttu-id="77a8e-208">這種現象的直接代表就是多工緩衝成長。</span><span class="sxs-lookup"><span data-stu-id="77a8e-208">A direct indication of this would be Spool growth.</span></span>  
  
### <a name="throttling-impact"></a><span data-ttu-id="77a8e-209">節流衝擊</span><span class="sxs-lookup"><span data-stu-id="77a8e-209">Throttling Impact</span></span>  
 <span data-ttu-id="77a8e-210">節流最終會開始作用，以保護系統不致達到不可復原的狀態。</span><span class="sxs-lookup"><span data-stu-id="77a8e-210">Throttling will ultimately kick in to protect the system from reaching an unrecoverable state.</span></span> <span data-ttu-id="77a8e-211">因此，節流是驗證系統是否正常運作並探索問題來源的好方法。</span><span class="sxs-lookup"><span data-stu-id="77a8e-211">Thus throttling is a good place to verify whether the system is functioning normally and discover the source of the problem.</span></span> <span data-ttu-id="77a8e-212">從節流狀態識別出瓶頸的原因後，可分析其他的效能計數器以向下切入問題的來源。</span><span class="sxs-lookup"><span data-stu-id="77a8e-212">After the cause of the bottleneck has been identified from the throttling state, analyze the other performance counters to drill down into the source of the problem.</span></span>  
  
 <span data-ttu-id="77a8e-213">例如，在 MessageBox 資料庫上的高爭用情況可能是由於高 CPU 使用量造成，高 CPU 使用量可能是由於磁碟過度分頁造成，過度分頁又可能是由於記憶體不足的情況而導致。</span><span class="sxs-lookup"><span data-stu-id="77a8e-213">For example, high contention on the MessageBox database could be due to high CPU usage, which could be caused due to excessively paging to disk which could be caused due to low memory conditions.</span></span> <span data-ttu-id="77a8e-214">在 MessageBox 資料庫上的高度爭用情況也可能是由於高度鎖定爭用而造成，鎖定爭用則可能是由於磁碟機飽和而導致。</span><span class="sxs-lookup"><span data-stu-id="77a8e-214">High contention on the MessageBox could also be caused due to high lock contention which could be due to saturated disk drives.</span></span>  
  
## <a name="biztalk-application-counters"></a><span data-ttu-id="77a8e-215">BizTalk 應用程式計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-215">BizTalk Application Counters</span></span>  
  
|<span data-ttu-id="77a8e-216">Object</span><span class="sxs-lookup"><span data-stu-id="77a8e-216">Object</span></span>|<span data-ttu-id="77a8e-217">執行個體</span><span class="sxs-lookup"><span data-stu-id="77a8e-217">Instance</span></span>|<span data-ttu-id="77a8e-218">計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-218">Counter</span></span>|<span data-ttu-id="77a8e-219">描述</span><span class="sxs-lookup"><span data-stu-id="77a8e-219">Description</span></span>|  
|------------|--------------|-------------|-----------------|  
|<span data-ttu-id="77a8e-220">BizTalk 傳訊</span><span class="sxs-lookup"><span data-stu-id="77a8e-220">BizTalk Messaging</span></span>|<span data-ttu-id="77a8e-221">RxHost</span><span class="sxs-lookup"><span data-stu-id="77a8e-221">RxHost</span></span>|<span data-ttu-id="77a8e-222">每秒接收文件數</span><span class="sxs-lookup"><span data-stu-id="77a8e-222">Documents Received/Sec</span></span>|<span data-ttu-id="77a8e-223">內送速率</span><span class="sxs-lookup"><span data-stu-id="77a8e-223">Incoming Rate</span></span>|  
|<span data-ttu-id="77a8e-224">BizTalk 傳訊</span><span class="sxs-lookup"><span data-stu-id="77a8e-224">BizTalk Messaging</span></span>|<span data-ttu-id="77a8e-225">TxHost</span><span class="sxs-lookup"><span data-stu-id="77a8e-225">TxHost</span></span>|<span data-ttu-id="77a8e-226">每秒處理文件數</span><span class="sxs-lookup"><span data-stu-id="77a8e-226">Documents Processed/Sec</span></span>|<span data-ttu-id="77a8e-227">外寄速率</span><span class="sxs-lookup"><span data-stu-id="77a8e-227">Outgoing Rate</span></span>|  
|<span data-ttu-id="77a8e-228">XLANG/s 協調流程</span><span class="sxs-lookup"><span data-stu-id="77a8e-228">XLANG/s Orchestrations</span></span>|<span data-ttu-id="77a8e-229">PxHost</span><span class="sxs-lookup"><span data-stu-id="77a8e-229">PxHost</span></span>|<span data-ttu-id="77a8e-230">每秒完成的協調流程數</span><span class="sxs-lookup"><span data-stu-id="77a8e-230">Orchestrations Completed/Sec.</span></span>|<span data-ttu-id="77a8e-231">處理速率</span><span class="sxs-lookup"><span data-stu-id="77a8e-231">Processing Rate</span></span>|  
|<span data-ttu-id="77a8e-232">BizTalk: MessageBox： 一般計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-232">BizTalk : MessageBox: General Counters</span></span>|<span data-ttu-id="77a8e-233">MsgBoxName</span><span class="sxs-lookup"><span data-stu-id="77a8e-233">MsgBoxName</span></span>|<span data-ttu-id="77a8e-234">多工緩衝處理大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-234">Spool Size</span></span>|<span data-ttu-id="77a8e-235">所有主控件佇列總計大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-235">Cumulative size of all Host Queues</span></span>|  
|<span data-ttu-id="77a8e-236">BizTalk: MessageBox： 一般計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-236">BizTalk : MessageBox: General Counters</span></span>|<span data-ttu-id="77a8e-237">MsgBoxName</span><span class="sxs-lookup"><span data-stu-id="77a8e-237">MsgBoxName</span></span>|<span data-ttu-id="77a8e-238">追蹤資料大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-238">Tracking Data Size</span></span>|<span data-ttu-id="77a8e-239">MessageBox 上的 TrackingData 資料表大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-239">Size of TrackingData table on the MessageBox</span></span>|  
|<span data-ttu-id="77a8e-240">BizTalk：MessageBox：主控件計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-240">BizTalk:MessageBox:Host Counters</span></span>|<span data-ttu-id="77a8e-241">PxHost:MsgBoxName</span><span class="sxs-lookup"><span data-stu-id="77a8e-241">PxHost:MsgBoxName</span></span>|<span data-ttu-id="77a8e-242">主控件佇列 - 長度</span><span class="sxs-lookup"><span data-stu-id="77a8e-242">Host Queue - Length</span></span>|<span data-ttu-id="77a8e-243">指定主控件佇列中的訊息數</span><span class="sxs-lookup"><span data-stu-id="77a8e-243">Number of messages in the specific Host Queue</span></span>|  
|<span data-ttu-id="77a8e-244">BizTalk：MessageBox：主控件計數器</span><span class="sxs-lookup"><span data-stu-id="77a8e-244">BizTalk:MessageBox:Host Counters</span></span>|<span data-ttu-id="77a8e-245">TxHost:MsgBoxName</span><span class="sxs-lookup"><span data-stu-id="77a8e-245">TxHost:MsgBoxName</span></span>|<span data-ttu-id="77a8e-246">主控件佇列 - 長度</span><span class="sxs-lookup"><span data-stu-id="77a8e-246">Host Queue - Length</span></span>|<span data-ttu-id="77a8e-247">指定主控件佇列中的訊息數</span><span class="sxs-lookup"><span data-stu-id="77a8e-247">Number of messages in the specific Host Queue</span></span>|  
|<span data-ttu-id="77a8e-248">BizTalk：訊息代理程式</span><span class="sxs-lookup"><span data-stu-id="77a8e-248">BizTalk:Message Agent</span></span>|<span data-ttu-id="77a8e-249">RxHost</span><span class="sxs-lookup"><span data-stu-id="77a8e-249">RxHost</span></span>|<span data-ttu-id="77a8e-250">資料庫大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-250">Database Size</span></span>|<span data-ttu-id="77a8e-251">發佈 (PxHost) 佇列的大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-251">Size of publishing (PxHost) Queue</span></span>|  
|<span data-ttu-id="77a8e-252">BizTalk：訊息代理程式</span><span class="sxs-lookup"><span data-stu-id="77a8e-252">BizTalk:Message Agent</span></span>|<span data-ttu-id="77a8e-253">PxHost</span><span class="sxs-lookup"><span data-stu-id="77a8e-253">PxHost</span></span>|<span data-ttu-id="77a8e-254">資料庫大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-254">Database Size</span></span>|<span data-ttu-id="77a8e-255">發佈 (TxHost) 佇列的大小</span><span class="sxs-lookup"><span data-stu-id="77a8e-255">Size of publishing (TxHost) Queue</span></span>|  
|<span data-ttu-id="77a8e-256">BizTalk：訊息代理程式</span><span class="sxs-lookup"><span data-stu-id="77a8e-256">BizTalk:Message Agent</span></span>|<span data-ttu-id="77a8e-257">HostName</span><span class="sxs-lookup"><span data-stu-id="77a8e-257">HostName</span></span>|<span data-ttu-id="77a8e-258">訊息傳遞節流狀態</span><span class="sxs-lookup"><span data-stu-id="77a8e-258">Message Delivery Throttling State</span></span>|<span data-ttu-id="77a8e-259">影響 XLANG 和輸出傳輸</span><span class="sxs-lookup"><span data-stu-id="77a8e-259">Affects XLANG and Outbound transports</span></span>|  
|<span data-ttu-id="77a8e-260">BizTalk：訊息代理程式</span><span class="sxs-lookup"><span data-stu-id="77a8e-260">BizTalk:Message Agent</span></span>|<span data-ttu-id="77a8e-261">HostName</span><span class="sxs-lookup"><span data-stu-id="77a8e-261">HostName</span></span>|<span data-ttu-id="77a8e-262">訊息發佈節流狀態</span><span class="sxs-lookup"><span data-stu-id="77a8e-262">Message Publishing Throttling State</span></span>|<span data-ttu-id="77a8e-263">影響 XLANG 和輸入傳輸</span><span class="sxs-lookup"><span data-stu-id="77a8e-263">Affects XLANG and Inbound transports</span></span>|  
  
### <a name="where-do-i-start"></a><span data-ttu-id="77a8e-264">要從何處著手？</span><span class="sxs-lookup"><span data-stu-id="77a8e-264">Where do I start?</span></span>  
 <span data-ttu-id="77a8e-265">監視**訊息傳遞節流狀態**並**訊息發佈節流狀態**每個主控件執行個體通常會是不錯的起點。</span><span class="sxs-lookup"><span data-stu-id="77a8e-265">Monitoring the **Message Delivery Throttling State** and the **Message Publishing Throttling State** for each host instance is usually a good place to start.</span></span> <span data-ttu-id="77a8e-266">如果這些計數器的值並非零，則代表節流正在 BizTalk 系統中進行，有可能可以進一步分析瓶頸的原因。</span><span class="sxs-lookup"><span data-stu-id="77a8e-266">If the value of these counters is not zero it is indicative that throttling is happening within the BizTalk system and it is possible to further analyze the cause of the bottleneck.</span></span> <span data-ttu-id="77a8e-267">如需有關其他效能計數器的描述，請參閱[資料庫層中的識別瓶頸](http://msdn.microsoft.com/library/f1dc58b5-73b0-41b5-9a1e-c0698485c732)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-267">For descriptions on the other performance counters, see [Identifying Bottlenecks in the Database Tier](http://msdn.microsoft.com/library/f1dc58b5-73b0-41b5-9a1e-c0698485c732).</span></span>  
  
## <a name="backlog-buildup"></a><span data-ttu-id="77a8e-268">待處理項目積存</span><span class="sxs-lookup"><span data-stu-id="77a8e-268">Backlog Buildup</span></span>  
 <span data-ttu-id="77a8e-269">在 1 對 1 的部署實例中 (也就是接收 1 個訊息會導致處理及傳輸 1 個訊息)，如果外寄速率不等於內送速率，則會在系統中的某一處積存待處理的項目。</span><span class="sxs-lookup"><span data-stu-id="77a8e-269">For a 1-1 deployment scenario where 1 message received results in 1 message processed and transmitted, if the Outgoing Rate does not equal the Incoming Rate, a backlog is building up somewhere in the system.</span></span> <span data-ttu-id="77a8e-270">在發生這種情況時，可以監控多工緩衝處理大小。</span><span class="sxs-lookup"><span data-stu-id="77a8e-270">For such a situation it is possible to monitor the Spool Size.</span></span>  
  
 <span data-ttu-id="77a8e-271">如果多工緩衝處理是以線性成長，則可以藉由確認負責多工緩衝處理成長的應用程式佇列來進一步向下切入。</span><span class="sxs-lookup"><span data-stu-id="77a8e-271">If the Spool is growing linearly, it is possible to further drill down by verifying which Application Queue is responsible for the Spool growth.</span></span>  
  
 <span data-ttu-id="77a8e-272">如果沒有任何應用程式佇列有成長，多工緩衝處理卻持續成長，就可能代表由於代理程式未在執行或者 SQL 伺服器上有其他的系統資源爭用情況，而導致清除工作無法跟上成長速度。</span><span class="sxs-lookup"><span data-stu-id="77a8e-272">If none of the application queues are growing and the Spool continues to grow it could mean that the purge jobs are unable to keep up either due to the agent not running or other system resource contention on the SQL server.</span></span>  
  
 <span data-ttu-id="77a8e-273">如果其中有一個應用程式佇列在成長，則診斷這項成長的原因很重要。</span><span class="sxs-lookup"><span data-stu-id="77a8e-273">If one of the application queues are growing, it is important to diagnose the cause of this growth.</span></span> <span data-ttu-id="77a8e-274">請在無法清空特定應用程式佇列的系統上監控系統資源 (例如，Orchestration Host-Q 會由於伺服器上的 CPU 耗盡而成長)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-274">Monitor the system resources on the system that is unable to drain the specific application queue (for example, Orchestration Host-Q is growing due to CPU starvation on the server).</span></span> <span data-ttu-id="77a8e-275">此外，請針對特定主控件執行個體而確認節流計數器的值。</span><span class="sxs-lookup"><span data-stu-id="77a8e-275">In addition verify the values of the throttling counter for the specific host instance.</span></span>  
  
 <span data-ttu-id="77a8e-276">如果傳遞/發佈狀態並非零，請檢查該值以確認節流的原因 (例如，已超過記憶體閾值、傳遞訊息計數過高等等)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-276">If the Delivery/Publishing State is not zero, check the value to confirm the reason for throttling (for example, memory threshold exceeded, in-flight message count too high etc.).</span></span>  
  
## <a name="f1-profiler"></a><span data-ttu-id="77a8e-277">F1 Profiler</span><span class="sxs-lookup"><span data-stu-id="77a8e-277">F1 Profiler</span></span>  
 <span data-ttu-id="77a8e-278">藉由使用效能計數器，可以快速地在高層級偵測到瓶頸的位置。</span><span class="sxs-lookup"><span data-stu-id="77a8e-278">By using performance counters, it is possible to quickly detect at a high level the location of the bottleneck.</span></span> <span data-ttu-id="77a8e-279">不過，一旦將範圍縮小，就可能必須進一步向下切入到節點中，才有助於減輕問題。</span><span class="sxs-lookup"><span data-stu-id="77a8e-279">However, once narrowed down, it may be necessary to drill down further into the code to help alleviate the problem.</span></span> <span data-ttu-id="77a8e-280">附隨於 Visual Studio 的 F1 Profiler 可能是一項非常有用的工具，有助於診斷程式碼將大多數的循環花在何處。</span><span class="sxs-lookup"><span data-stu-id="77a8e-280">The F1 Profiler that ships with Visual Studio can be a very helpful tool to help diagnose where the code is spending most of its cycles.</span></span>  
  
 <span data-ttu-id="77a8e-281">若要建立更有意義的堆疊，則符號很重要 (特別對於 Unmanaged 程式碼而言)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-281">Symbols are important to help with creating a more meaningful stack (especially for unmanaged code).</span></span> <span data-ttu-id="77a8e-282">例如，F1-Profiler 有助於找出叫用的次數，以及傳回 API 呼叫的時間量。</span><span class="sxs-lookup"><span data-stu-id="77a8e-282">For example, the F1-Profiler can help pinpoint the number of invocations and the amount of time an API call takes to return.</span></span> <span data-ttu-id="77a8e-283">在堆疊中更向下切入，就可能可以偵測到高延遲狀況的原因。</span><span class="sxs-lookup"><span data-stu-id="77a8e-283">Drilling further down the stack, it may be possible to detect the underlying cause of the high latency.</span></span> <span data-ttu-id="77a8e-284">這可能是對資料庫查詢的封鎖呼叫，或只是等候事件的呼叫。</span><span class="sxs-lookup"><span data-stu-id="77a8e-284">It could be a blocking call to a database query or simply a call to wait on an event.</span></span>  
  
## <a name="l2l3-cache"></a><span data-ttu-id="77a8e-285">L2/L3 快取</span><span class="sxs-lookup"><span data-stu-id="77a8e-285">L2/L3 Cache</span></span>  
 <span data-ttu-id="77a8e-286">最大的優點 (從硬體觀點來看)，是可以利用內建的 CPU 快取。</span><span class="sxs-lookup"><span data-stu-id="77a8e-286">The biggest benefits (from a hardware perspective) that can be gained is by utilizing onboard CPU cache.</span></span> <span data-ttu-id="77a8e-287">較高的 CPU 快取有助於增加快取命中率，減少系統從記憶體對磁碟進行來回資料分頁的需求。</span><span class="sxs-lookup"><span data-stu-id="77a8e-287">Higher CPU cache helps increase cache hit rate reducing the need for the system to page data in and out of memory to disk.</span></span>  
  
## <a name="64-bit-performance-bottlenecks"></a><span data-ttu-id="77a8e-288">64 位元效能瓶頸</span><span class="sxs-lookup"><span data-stu-id="77a8e-288">64-Bit Performance Bottlenecks</span></span>  
 <span data-ttu-id="77a8e-289">64 位元系統上的效能可能看來會低於在 32 位元系統上所能達到的效能。</span><span class="sxs-lookup"><span data-stu-id="77a8e-289">Performance on 64-bit systems may appear lower than what can be achieved on 32-bit systems.</span></span> <span data-ttu-id="77a8e-290">這種現象可能會因為數項原因而造成，其中最主要的原因就是記憶體。</span><span class="sxs-lookup"><span data-stu-id="77a8e-290">This is possible due to a couple of reasons, the most important one being memory.</span></span>  
  
 <span data-ttu-id="77a8e-291">評估具有 2GB 記憶體的 32 位元系統效能，然後將結果與具有 2GB 記憶體的 64 位元系統所能達到的效能進行比較，並不是一項公平的的比較。</span><span class="sxs-lookup"><span data-stu-id="77a8e-291">Measuring performance on a 32-bit system with 2-GB of memory and comparing the results to what can be achieved on a similar 64-bit system with 2-GB of memory is not a true apples to apples comparison.</span></span> <span data-ttu-id="77a8e-292">64 位元的系統看起來較受限於磁碟 IO 的處理能力 (低 % 磁碟閒置時間 & 高磁碟佇列長度) 和 CPU 的處理能力 (CPU 上限 & 高內容切換)。</span><span class="sxs-lookup"><span data-stu-id="77a8e-292">The 64-bit system will appear to be disk-IO bound (low % Disk Idle time & high Disk Queue Length) and CPU bound (max CPU & high Context Switching).</span></span> <span data-ttu-id="77a8e-293">不過，這並不是因為在 64 位元系統上執行檔案 IO 較耗費資源。</span><span class="sxs-lookup"><span data-stu-id="77a8e-293">However, this is not because performing file IO on a 64-bit system is more expensive.</span></span>  
  
 <span data-ttu-id="77a8e-294">64 位元系統較耗費記憶體 (64 位元定位)，這會導致 OS 耗用大部分的 2GB 可用記憶體。</span><span class="sxs-lookup"><span data-stu-id="77a8e-294">The 64-bit system is more memory hungry (64-bit addressing) which results in the OS consuming most of the 2-GB available memory.</span></span> <span data-ttu-id="77a8e-295">一旦發生這種情況其他大部分的作業會導致浮現檔案子系統磁碟中的分頁。</span><span class="sxs-lookup"><span data-stu-id="77a8e-295">Once this happens most other operations cause paging to disk which stresses the file subsystem.</span></span> <span data-ttu-id="77a8e-296">現在系統不單會將 CPU 循環花在將資料和程式碼來回分頁到記憶體上，也會受到高磁碟延遲的影響。</span><span class="sxs-lookup"><span data-stu-id="77a8e-296">The system now not only spends CPU cycles paging in/out of memory both data and code but is also impacted by the high disk latency cost.</span></span> <span data-ttu-id="77a8e-297">這會造成系統呈現較高磁碟爭用和較高 CPU 耗用的情況。</span><span class="sxs-lookup"><span data-stu-id="77a8e-297">This manifests itself as both higher disk contention and higher CPU consumption.</span></span>  
  
 <span data-ttu-id="77a8e-298">減輕這項問題的方式是升級記憶體 (理想狀況下 8GB)，以向上擴充伺服器。</span><span class="sxs-lookup"><span data-stu-id="77a8e-298">The way to alleviate this problem is to scale-up the server by upgrading the memory (ideally 8-GB).</span></span> <span data-ttu-id="77a8e-299">不過，加入更多的記憶體對改善輸送量並無助益，除非問題的來源是因為記憶體不足而導致 CPU 耗盡。</span><span class="sxs-lookup"><span data-stu-id="77a8e-299">However, adding more memory will not help improve throughput unless the source of the problem is CPU starvation due to low memory conditions.</span></span>  
  
## <a name="using-bam-to-identify-bottlenecks-and-high-latency-issues"></a><span data-ttu-id="77a8e-300">使用 BAM 識別瓶頸和高延遲問題</span><span class="sxs-lookup"><span data-stu-id="77a8e-300">Using BAM to identify bottlenecks and high latency issues</span></span>  
 <span data-ttu-id="77a8e-301">如果是在很需要低延遲的情況中，可以使用 BAM 來評估系統完成 BizTalk 系統內每個階段所需的時間。</span><span class="sxs-lookup"><span data-stu-id="77a8e-301">In situations where low latency is important, you can use BAM to measure the time the system takes to complete each stage within the BizTalk system.</span></span> <span data-ttu-id="77a8e-302">雖然追蹤的訊息事件和服務執行個體的資料可以用來偵錯之訊息的狀態並診斷路由訊息中的問題的來源，BAM 可用來追蹤透過訊息流程的各個端點。</span><span class="sxs-lookup"><span data-stu-id="77a8e-302">Although  tracked message event and service instance data can be used to debug the state of messages and diagnose the source of problems in routing messages, BAM can be used to track various points through the message flow.</span></span> <span data-ttu-id="77a8e-303">藉由建立 BAM 追蹤設定檔 (以接續來定義活動)，您可以評估系統不同部分之間的延遲，以協助追蹤工作流程程序內最耗費資源的階段。</span><span class="sxs-lookup"><span data-stu-id="77a8e-303">By creating a BAM tracking profile (defining an activity with continuations), you can measure latency between different parts of the system to help track the most expensive stages within the workflow process.</span></span>