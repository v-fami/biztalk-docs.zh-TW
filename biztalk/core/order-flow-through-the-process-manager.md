---
title: "訂單流程程序管理員透過 |Microsoft 文件"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- process management solution tutorial, processing
- processing, processing logic
ms.assetid: e2b51eff-44b5-440f-a7d1-0872543e5f27
caps.latest.revision: "30"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8556bce43ba4a951d0045d22f76d4bd222fcd8f2
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
---
# <a name="order-flow-through-the-process-manager"></a><span data-ttu-id="a2960-102">透過處理序管理員的訂單流程</span><span class="sxs-lookup"><span data-stu-id="a2960-102">Order Flow through the Process Manager</span></span>
<span data-ttu-id="a2960-103">本章節描述如何 Southridge Video 訂單程序管理員**OrderManager**協調流程、 處理訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-103">This section describes how the Southridge Video order process manager, the **OrderManager** orchestration, processes orders.</span></span> <span data-ttu-id="a2960-104">本節會透過協調流程來產生新訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-104">This section follows a new order through the orchestration.</span></span> <span data-ttu-id="a2960-105">本節也討論協調流程如何處理訂單的更新。</span><span class="sxs-lookup"><span data-stu-id="a2960-105">The section also discusses how the orchestration handles updates to orders.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2960-106">商務程序管理員解決方案只包含一個程序管理員，即使該程序管理員是已寫入的，這樣它才能使用一種以上的管理員。</span><span class="sxs-lookup"><span data-stu-id="a2960-106">The business process manager solution includes only one process manager although it is written so that it can use more than one type of manager.</span></span>  
  
 <span data-ttu-id="a2960-107">**OrderManager**協調流程會協調實作商務程序以處理訂單的附屬協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-107">The **OrderManager** orchestration coordinates subordinate orchestrations that implement the business process to handle the order.</span></span> <span data-ttu-id="a2960-108">**OrderManager**傳送的順序透過兩個階段，結合，驗證訂單、 傳送資訊到功能群組、 傳送訂單到訂單系統，透過遠端元件和更新訂單歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="a2960-108">The **OrderManager** sends the order through two stages which, combined, validate the order, send the information to the facilities group, send the order to the order system through remoting components, and update the order history.</span></span> <span data-ttu-id="a2960-109">您可以新增、 刪除或修改這些階段，而不必變更**OrderManager**。</span><span class="sxs-lookup"><span data-stu-id="a2960-109">You can add, delete, or modify these stages without having to change the **OrderManager**.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2960-110">由於大小和範圍**OrderManager**協調流程中，您可以閱讀此節與 Microsoft Visual Studio 中開啟協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-110">Because of the size and scope of the **OrderManager** orchestration, you may want to read this section with the orchestration open in Microsoft Visual Studio.</span></span>  
  
## <a name="order-manager-structure"></a><span data-ttu-id="a2960-111">訂單管理員結構</span><span class="sxs-lookup"><span data-stu-id="a2960-111">Order Manager Structure</span></span>  
 <span data-ttu-id="a2960-112">**OrderManager**啟動協調流程的接收圖形開始協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-112">The **OrderManager** orchestration begins with a receive shape that activates the orchestration.</span></span> <span data-ttu-id="a2960-113">下圖顯示的一般結構**OrderManager**協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-113">The following diagram shows the general structure of the **OrderManager** orchestration.</span></span>  
  
 <span data-ttu-id="a2960-114">![封鎖圖表的訂單管理員](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")</span><span class="sxs-lookup"><span data-stu-id="a2960-114">![Block Diagram of Order Manager](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")</span></span>  
  
 <span data-ttu-id="a2960-115">第一個接收圖形會分成兩個主要分支。</span><span class="sxs-lookup"><span data-stu-id="a2960-115">The first receive shape leads to two main branches.</span></span> <span data-ttu-id="a2960-116">右邊的分支會處理新的訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-116">One branch, the right one, processes new orders.</span></span> <span data-ttu-id="a2960-117">左邊的分支會處理訂單取消作業。</span><span class="sxs-lookup"><span data-stu-id="a2960-117">The left branch, handles order cancellations.</span></span> <span data-ttu-id="a2960-118">它可接受使用者輸入，因為它有可能**OrderManager**訂單已完成之後，接收訂單取消作業。</span><span class="sxs-lookup"><span data-stu-id="a2960-118">Because it accepts user input, it is possible for the **OrderManager** to receive an order cancellation after an order has already completed.</span></span> <span data-ttu-id="a2960-119">這就是左邊主要分支處理的狀況。</span><span class="sxs-lookup"><span data-stu-id="a2960-119">This is the case the left main branch handles.</span></span> <span data-ttu-id="a2960-120">分支藉由設定終止處理的旗標並將警告新增到事件日誌，來處理外掛式取消作業。</span><span class="sxs-lookup"><span data-stu-id="a2960-120">The branch handles the isolated cancellation by setting flags for terminating processing and by adding a warning to the event log.</span></span> <span data-ttu-id="a2960-121">當右邊的分支內正在處理訂單時，協調流程會處理抵達的訂單取消作業。</span><span class="sxs-lookup"><span data-stu-id="a2960-121">The orchestration handles order cancellations that arrive while an order is being processed inside the right-hand branch.</span></span>  
  
 <span data-ttu-id="a2960-122">訂單處理分支會進行部分初始化，然後進入兩個巢狀迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-122">The order processing branch does some initialization and then enters two nested loops.</span></span> <span data-ttu-id="a2960-123">在訂單處理過程中，每個階段都會執行一次外部迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-123">The outer loop runs once for each stage in the order processing.</span></span> <span data-ttu-id="a2960-124">當階段正在處理時會執行內部迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-124">The inner loop runs while the stage is processing.</span></span> <span data-ttu-id="a2960-125">訂單管理員也會接聽內部迴圈中訂單的可能更新。</span><span class="sxs-lookup"><span data-stu-id="a2960-125">The order manager also listens for possible updates to the order inside the inner loop.</span></span> <span data-ttu-id="a2960-126">在迴圈終止後，訂單管理員會傳送一個完成訊息。</span><span class="sxs-lookup"><span data-stu-id="a2960-126">After the loops terminate, the order manager sends a completion message.</span></span>  
  
 <span data-ttu-id="a2960-127">訂單處理階段使用動態、 自我相互關聯的連接埠可通訊回到**OrderManager**協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-127">The order processing stages use dynamic, self-correlating ports to communicate back to the **OrderManager** orchestration.</span></span> <span data-ttu-id="a2960-128">這樣可簡化的相互關聯**OrderManager**與階段執行個體，因為它不需要使用相互關聯集。</span><span class="sxs-lookup"><span data-stu-id="a2960-128">This simplifies correlation of the **OrderManager** with the stage instances because it eliminates the need to use a correlation set.</span></span> <span data-ttu-id="a2960-129">如需自我相互關聯連接埠的詳細資訊，請參閱[連接埠繫結](../core/port-bindings.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-129">For more information about self-correlating ports, see [Port Bindings](../core/port-bindings.md).</span></span>  
  
## <a name="receiving-orders"></a><span data-ttu-id="a2960-130">接收訂單</span><span class="sxs-lookup"><span data-stu-id="a2960-130">Receiving Orders</span></span>  
 <span data-ttu-id="a2960-131">**OrderManager**接收訂單訊息從**OrderBroker**協調流程透過**FromBrokerPort**連接埠。</span><span class="sxs-lookup"><span data-stu-id="a2960-131">The **OrderManager** receives order messages from the **OrderBroker** orchestration through the **FromBrokerPort** port.</span></span> <span data-ttu-id="a2960-132">這個連接埠直接繫結至 MessageBox 資料庫。</span><span class="sxs-lookup"><span data-stu-id="a2960-132">This port is bound directly to the MessageBox database.</span></span> <span data-ttu-id="a2960-133">協調流程有兩個**接收**圖形連接至連接埠： 一個用於新訂單，一個用於更新訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-133">The orchestration has two **Receive** shapes connected to the port: one for new orders and one for updated orders.</span></span>  
  
 <span data-ttu-id="a2960-134">**OrderManger**決定哪些訊息篩選條件運算式為基礎的程序。</span><span class="sxs-lookup"><span data-stu-id="a2960-134">The **OrderManger** determines which messages to process based on a filter expression.</span></span> <span data-ttu-id="a2960-135">篩選條件運算式中，訊息狀態欄位與訂單管理員類型欄位中，測試值**OrderMgrType**。</span><span class="sxs-lookup"><span data-stu-id="a2960-135">The filter expression tests the value in the message status field and the order manager type field, **OrderMgrType**.</span></span> <span data-ttu-id="a2960-136">如果 [狀態] 欄位等於 ACCEPTED，而**OrderMgrType**是 cableorder，那麼順序是新和預期的這個程序管理員。</span><span class="sxs-lookup"><span data-stu-id="a2960-136">If the status field is equal to ACCEPTED, and the **OrderMgrType** is CABLEORDER, the order is new and intended for this process manager.</span></span>  
  
 <span data-ttu-id="a2960-137">新訂單會啟動協調流程的一個新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a2960-137">The new order activates a new instance of the orchestration.</span></span> <span data-ttu-id="a2960-138">**OrderManager**接下來會檢查要求中的類型**決策**圖形。</span><span class="sxs-lookup"><span data-stu-id="a2960-138">The **OrderManager** next checks the type of the request in a **Decision** shape.</span></span> <span data-ttu-id="a2960-139">如果類型是「終止」，協調流程會執行左邊的分支並終止訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-139">If the type is Terminate, the orchestration executes the left-hand branch and terminates the order.</span></span> <span data-ttu-id="a2960-140">否則，協調流程會繼續處理訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-140">Otherwise, the orchestration proceeds with processing the order.</span></span> <span data-ttu-id="a2960-141">請注意，這包含接聽與此特定訂單相關的後續訊息。</span><span class="sxs-lookup"><span data-stu-id="a2960-141">Notice that this includes listening for subsequent messages related to this particular order.</span></span>  
  
## <a name="initialization-for-new-orders"></a><span data-ttu-id="a2960-142">新訂單的初始化</span><span class="sxs-lookup"><span data-stu-id="a2960-142">Initialization for New Orders</span></span>  
 <span data-ttu-id="a2960-143">之後**OrderManager**協調流程接收初始訊息，並開始主要右邊分支，它會取得從其組態資訊**SSOConfigStore**。</span><span class="sxs-lookup"><span data-stu-id="a2960-143">After the **OrderManager** orchestration receives an initial message and begins the main right-hand branch, it gets its configuration information from the **SSOConfigStore**.</span></span> <span data-ttu-id="a2960-144">它會透過定義中的單一物件**公用程式**組件。</span><span class="sxs-lookup"><span data-stu-id="a2960-144">It does this through a singleton object defined in the **Utilities** assembly.</span></span> <span data-ttu-id="a2960-145">組態值是物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="a2960-145">The configuration values are properties of the object.</span></span> <span data-ttu-id="a2960-146">物件會管理組態值的本機快取，與服務導向架構解決方案相似。</span><span class="sxs-lookup"><span data-stu-id="a2960-146">The object manages a local cache of the configuration values similar to the Service Oriented Architecture solution.</span></span> <span data-ttu-id="a2960-147">如需單一物件的詳細資訊，請參閱[使用 SSO 有效率地在商務程序管理解決方案中](../core/using-sso-efficiently-in-the-business-process-management-solution.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-147">For more information about the singleton object, see [Using SSO Efficiently in the Business Process Management Solution](../core/using-sso-efficiently-in-the-business-process-management-solution.md).</span></span>  
  
 <span data-ttu-id="a2960-148">如同服務導向解決方案，商務程序管理解決方案會使用密碼存放區，因為它在安裝了 BizTalk 就會出現，SSO 會快取組態資訊，如此一來這些值便能使用，並可保護資料庫連接字串和密碼這類的資訊。</span><span class="sxs-lookup"><span data-stu-id="a2960-148">Like the Service Oriented solution, the Business Process Management solution uses the secret store because it is present whenever BizTalk is installed, SSO caches the configuration information so that the values are readily available, and it can protect information such as database connection strings and passwords.</span></span> <span data-ttu-id="a2960-149">基於上述所有原因，密碼存放區是非常適合放置組態資訊的位置，即使單一登入不是用於管理與後端應用程式的連線。</span><span class="sxs-lookup"><span data-stu-id="a2960-149">For all of these reasons, the secret store would be a good place for the configuration information even if Single Sign-On weren't being used for managing connections to the backend applications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2960-150">協調流程會在開始處理之前，先擷取組態資訊。</span><span class="sxs-lookup"><span data-stu-id="a2960-150">The orchestration retrieves configuration information before starting processing.</span></span> <span data-ttu-id="a2960-151">這可確保協調流程在凍結及稍後解除凍結時會使用相同的組態。</span><span class="sxs-lookup"><span data-stu-id="a2960-151">This ensures the orchestration uses the same configuration if it is dehydrated and, later, rehydrated.</span></span> <span data-ttu-id="a2960-152">如需凍結的詳細資訊，請參閱[協調流程凍結和解除凍結](../core/orchestration-dehydration-and-rehydration.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-152">For more information about dehydration, see [Orchestration Dehydration and Rehydration](../core/orchestration-dehydration-and-rehydration.md).</span></span>  
  
 <span data-ttu-id="a2960-153">訂單管理員會使用從組態資料的一個值： **TotalStages**，訂單處理程序的階段總數。</span><span class="sxs-lookup"><span data-stu-id="a2960-153">The order manager uses one value from the configuration data: **TotalStages**, the total number of stages in the order handling process.</span></span> <span data-ttu-id="a2960-154">管理員會將此值指派給區域變數， **numStages**。</span><span class="sxs-lookup"><span data-stu-id="a2960-154">The manager assigns this value to a local variable, **numStages**.</span></span> <span data-ttu-id="a2960-155">它也會設定連接到外部迴圈中，兩個變數**階段**和**停止**。</span><span class="sxs-lookup"><span data-stu-id="a2960-155">It also sets two more variables connected to the outer loop, **stage** and **stop**.</span></span> <span data-ttu-id="a2960-156">**階段**指出目前的階段，而且是外部迴圈; 計數器**停止**停止值。</span><span class="sxs-lookup"><span data-stu-id="a2960-156">The **stage** indicates the current stage and is the counter for the outer loop; **stop** the stopping value.</span></span>  
  
 <span data-ttu-id="a2960-157">最後，管理員會將設定**orderStatus**變數為 「 已啟動並進入外部處理迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-157">Finally, the manager sets the **orderStatus** variable to STARTED and enters the outer processing loop.</span></span>  
  
## <a name="new-order-processing-loops"></a><span data-ttu-id="a2960-158">新的訂單處理迴圈</span><span class="sxs-lookup"><span data-stu-id="a2960-158">New Order Processing Loops</span></span>  
 <span data-ttu-id="a2960-159">外部迴圈的值為長時間執行**階段**變數是的值小於**numStages**變數。</span><span class="sxs-lookup"><span data-stu-id="a2960-159">The outer loop runs as long as the value of the **stage** variable is less than the value of the **numStages** variable.</span></span> <span data-ttu-id="a2960-160">外部迴圈會驅動每個階段的處理。</span><span class="sxs-lookup"><span data-stu-id="a2960-160">The outer loops drives the processing for each stage.</span></span> <span data-ttu-id="a2960-161">只要階段仍在處理中，內部迴圈就會執行。</span><span class="sxs-lookup"><span data-stu-id="a2960-161">The inner loop runs so long as a stage is still being processed.</span></span> <span data-ttu-id="a2960-162">它也會接聽訂單的可能變更。</span><span class="sxs-lookup"><span data-stu-id="a2960-162">It also listens for possible changes to the order.</span></span>  
  
### <a name="outer-loop"></a><span data-ttu-id="a2960-163">外部迴圈</span><span class="sxs-lookup"><span data-stu-id="a2960-163">Outer Loop</span></span>  
 <span data-ttu-id="a2960-164">協調流程會藉由指派所接收的訊息開始外部迴圈 (**NewOrderMgrMsg**) 給變數， **OrderMgrMsg**。</span><span class="sxs-lookup"><span data-stu-id="a2960-164">The orchestration begins the outer loop by assigning the received message (**NewOrderMgrMsg**) to a variable, **OrderMgrMsg**.</span></span> <span data-ttu-id="a2960-165">接著它會將階段和狀態複製到訊息的路由部分。</span><span class="sxs-lookup"><span data-stu-id="a2960-165">It then copies the stage and status to the routing part of the message.</span></span> <span data-ttu-id="a2960-166">協調流程也會傳回位址設定位址的訊息中**StageCompletionPort**:</span><span class="sxs-lookup"><span data-stu-id="a2960-166">The orchestration also sets the return address in the message to the address of the **StageCompletionPort**:</span></span>  
  
```  
OrderMgrMsg.RoutingPart.OrderMgrReturnAddress =   
       StageCompletionPort(Microsoft.XLANGs.BaseTypes.Address);  
```  
  
 <span data-ttu-id="a2960-167">然後協調流程傳送的順序**StagePort**，請求-回應連接埠。</span><span class="sxs-lookup"><span data-stu-id="a2960-167">The orchestration then sends the order to the **StagePort**, a solicit-response port.</span></span> <span data-ttu-id="a2960-168">然後協調流程會等候來自已開始訂單處理之階段的通知。</span><span class="sxs-lookup"><span data-stu-id="a2960-168">The orchestration then waits for an acknowledgement from the stage that order processing has started.</span></span> <span data-ttu-id="a2960-169">階段傳送**OrderAck**時就會開始處理訂單訊息。</span><span class="sxs-lookup"><span data-stu-id="a2960-169">The stage sends an **OrderAck** message when it starts processing the order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2960-170">**OrderAck**訊息是一種.NET 類別，而不是結構描述所定義的方案中。</span><span class="sxs-lookup"><span data-stu-id="a2960-170">The **OrderAck** message is one of several in the solution defined by .NET classes rather than a schema.</span></span> <span data-ttu-id="a2960-171">如需有關使用.NET 類別來定義訊息的詳細資訊，請參閱[使用者程式碼中的 建構訊息](../core/constructing-messages-in-user-code.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-171">For more information about using .NET classes to define messages, see [Constructing Messages in User Code](../core/constructing-messages-in-user-code.md).</span></span>  
  
 <span data-ttu-id="a2960-172">當協調流程收到通知時，它會將指派到階段**currentStage**變數並進入內部迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-172">When the orchestration receives the acknowledgement, it assigns the stage to the **currentStage** variable and enters the inner loop.</span></span>  
  
### <a name="inner-loop"></a><span data-ttu-id="a2960-173">內部迴圈</span><span class="sxs-lookup"><span data-stu-id="a2960-173">Inner Loop</span></span>  
 <span data-ttu-id="a2960-174">只要在內部迴圈執行**currentStage**變數等於**階段**變數; 也就是說，只要目前階段正在處理。</span><span class="sxs-lookup"><span data-stu-id="a2960-174">The inner loop runs as long as the **currentStage** variable is equal to the **stage** variable; that is, as long as the current stage is being processed.</span></span> <span data-ttu-id="a2960-175">迴圈的主體是**接聽**圖形使用三個**接收**圖形。</span><span class="sxs-lookup"><span data-stu-id="a2960-175">The body of the loop is a **Listen** shape with three **Receive** shapes.</span></span> <span data-ttu-id="a2960-176">在協調流程中，最左邊圖形**訂單要求**，是訂單更新機制下, 一節中所述的一部分。</span><span class="sxs-lookup"><span data-stu-id="a2960-176">The leftmost shape in the orchestration, **Order Request**, is part of the order update mechanism, described in the next section.</span></span>  
  
 <span data-ttu-id="a2960-177">當訂單處理階段完成時，它會傳送訊息至**StageCompletion**連接埠**OrderManager**協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-177">When an order processing stage finishes, it sends a message to the **StageCompletion** port of the **OrderManager** orchestration.</span></span> <span data-ttu-id="a2960-178">如果因錯誤而突然終止階段，它會傳送**TerminatedMessage**。</span><span class="sxs-lookup"><span data-stu-id="a2960-178">If the stage abruptly terminates due to an error, it sends a **TerminatedMessage**.</span></span> <span data-ttu-id="a2960-179">在此情況下， **OrderManager**擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a2960-179">In this case, the **OrderManager** throws an exception.</span></span> <span data-ttu-id="a2960-180">最外層的例外狀況處理常式攔截例外狀況，並傳送錯誤訊息， **OperatorPort**。</span><span class="sxs-lookup"><span data-stu-id="a2960-180">The outermost exception handler catches the exception and sends an error message to the **OperatorPort**.</span></span>  
  
 <span data-ttu-id="a2960-181">若階段傳送**OrderMgrMsg**、 **OrderManager**遞增**階段**變數。</span><span class="sxs-lookup"><span data-stu-id="a2960-181">If the stage sends an **OrderMgrMsg**, the **OrderManager** increments the **stage** variable.</span></span> <span data-ttu-id="a2960-182">如果有多個階段 （階段少於或等於 numstages），則協調流程會將訂單狀態**OrderMgrMsg**設為 STAGE_n_COMPLETED，其中 n 是目前階段的數目。</span><span class="sxs-lookup"><span data-stu-id="a2960-182">If there are more stages (stage less than or equal to numStages), the orchestrations sets the order status in **OrderMgrMsg** to STAGE_n_COMPLETED where n is the number of the current stage.</span></span> <span data-ttu-id="a2960-183">如果沒有更多的階段，它會將訂單狀態設為 COMPLETED 並結束這兩個迴圈。</span><span class="sxs-lookup"><span data-stu-id="a2960-183">If there are no more stages, it sets the order status to COMPLETED and exits both loops.</span></span>  
  
## <a name="order-updates"></a><span data-ttu-id="a2960-184">訂單更新</span><span class="sxs-lookup"><span data-stu-id="a2960-184">Order Updates</span></span>  
 <span data-ttu-id="a2960-185">**OrderManager**協調流程會接聽內部處理迴圈內部的訂單更新。</span><span class="sxs-lookup"><span data-stu-id="a2960-185">The **OrderManager** orchestration listens for order updates inside the inner processing loop.</span></span> <span data-ttu-id="a2960-186">請注意，**接收**圖形它會使用為此， **OrderRequest**，也會使用**FromBrokerPort**。</span><span class="sxs-lookup"><span data-stu-id="a2960-186">Notice that the **Receive** shape it uses for this, **OrderRequest**, also uses the **FromBrokerPort**.</span></span> <span data-ttu-id="a2960-187">在迴圈內部的相同連接埠上使用第二個接收圖形，來結合相互關聯集，會形成通用 BizTalk Server 模式，也就是群組模式。</span><span class="sxs-lookup"><span data-stu-id="a2960-187">The use of a second receive shape on the same port inside a loop, combined with correlation sets, forms a common BizTalk Server pattern, the convoy pattern.</span></span> <span data-ttu-id="a2960-188">您可以使用群組模式，來確保協調流程的相同執行個體會處理第一個及後續與特定作業連接的訊息。</span><span class="sxs-lookup"><span data-stu-id="a2960-188">You use the convoy pattern to ensure that the same instance of an orchestration processes the first and subsequent messages connected with a particular operation.</span></span>  
  
 <span data-ttu-id="a2960-189">當訂單管理員接收到第一個與訂單連接的訊息時，它會初始化兩個相互關聯集。</span><span class="sxs-lookup"><span data-stu-id="a2960-189">When the order manager receives the first message connected to an order, it initializes two correlation sets.</span></span> <span data-ttu-id="a2960-190">首先， **OrderCorrelation**，會使用客戶識別碼 (**CustID**) 以及訂單識別碼 (**OrderID**)。</span><span class="sxs-lookup"><span data-stu-id="a2960-190">The first, **OrderCorrelation**, uses the customer ID (**CustID**) and order ID (**OrderID**).</span></span> <span data-ttu-id="a2960-191">訂單管理員會與訂單處理階段共用這個相互關聯。</span><span class="sxs-lookup"><span data-stu-id="a2960-191">The order manager shares this correlation with the order processing stages.</span></span> <span data-ttu-id="a2960-192">第二個相互關聯是群組相互關聯， **OrderConvoyCorrelation**，它會使用訂單狀態 (**狀態**) 除了客戶識別碼與訂單識別碼。</span><span class="sxs-lookup"><span data-stu-id="a2960-192">The second correlation is the convoy correlation, **OrderConvoyCorrelation**, which uses the order status (**Status**) in addition to the customer ID and order ID.</span></span> <span data-ttu-id="a2960-193">**OrderRequestReceive**圖形會使用**OrderConvoyCorrelation**為沿用相互關聯集。</span><span class="sxs-lookup"><span data-stu-id="a2960-193">The **OrderRequestReceive** shape uses **OrderConvoyCorrelation** as a Following Correlation Set.</span></span> <span data-ttu-id="a2960-194">使用這個方式來設定相互關聯集，可以確保負責特定訂單的訂單管理員執行個體能夠接收到任何的變更。</span><span class="sxs-lookup"><span data-stu-id="a2960-194">Setting the correlation set up this way ensures that the instance of the order manager working on a particular order receives any changes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2960-195">請記住，相互關聯集是一個訊息屬性的群組，可用於判斷訊息是否屬於協調流程的特定執行個體。</span><span class="sxs-lookup"><span data-stu-id="a2960-195">Recall that a correlation set is a grouping of message properties used to determine whether or not a message belongs to a given instance of an orchestration.</span></span> <span data-ttu-id="a2960-196">如需詳細資訊，請參閱[使用協調流程中的相互關聯](../core/using-correlations-in-orchestrations.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-196">For more information, see [Using Correlations in Orchestrations](../core/using-correlations-in-orchestrations.md).</span></span>  
  
 <span data-ttu-id="a2960-197">當**OrderManager**收到後續訊息的訂單，它會先測試要求的類型。</span><span class="sxs-lookup"><span data-stu-id="a2960-197">When the **OrderManager** receives a subsequent message for an order, it first tests the type of request.</span></span> <span data-ttu-id="a2960-198">若要求類型是 TERMINATE，「決策」圖形就會執行終止分支。</span><span class="sxs-lookup"><span data-stu-id="a2960-198">If the request type is TERMINATE, the Decision shape executes the terminate branch.</span></span> <span data-ttu-id="a2960-199">否則，協調流程會測試新的訊息，以查看它是否為更新。</span><span class="sxs-lookup"><span data-stu-id="a2960-199">Otherwise, the orchestration tests the new message to see if it is an update.</span></span> <span data-ttu-id="a2960-200">更新訊息具有更高的序號 (**SeqNum**) 比原始要求。</span><span class="sxs-lookup"><span data-stu-id="a2960-200">An update message has a higher sequence number (**SeqNum**) than the original request.</span></span> <span data-ttu-id="a2960-201">若新訊息的序號更高，協調流程會以新訊息重新啟動訂單處理。</span><span class="sxs-lookup"><span data-stu-id="a2960-201">If the new message's sequence number is higher, the orchestration starts the order processing over with the new message.</span></span> <span data-ttu-id="a2960-202">若原始和更新訊息具有相同或更低的序號，就會發生順序錯誤。</span><span class="sxs-lookup"><span data-stu-id="a2960-202">If the original and update message have the same or a lower sequence number, there is a sequence error.</span></span> <span data-ttu-id="a2960-203">若序號相等，則其為重複的訂單，並標示為重複的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a2960-203">If the sequence numbers are equal, it is a duplicate order and flagged as a duplicate error.</span></span>  
  
 <span data-ttu-id="a2960-204">如需有關**SeqNum**，請參閱[金鑰訊息和欄位](../core/key-messages-and-fields.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-204">For more information about **SeqNum**, see [Key Messages and Fields](../core/key-messages-and-fields.md).</span></span>  
  
## <a name="final-steps"></a><span data-ttu-id="a2960-205">最後步驟</span><span class="sxs-lookup"><span data-stu-id="a2960-205">Final Steps</span></span>  
 <span data-ttu-id="a2960-206">之後結束迴圈，訂單管理員將回覆位址指派給動態連接埠**CSRCompletionPort**。</span><span class="sxs-lookup"><span data-stu-id="a2960-206">After exiting the loops, the order manager assigns the reply address to the dynamic port **CSRCompletionPort**.</span></span> <span data-ttu-id="a2960-207">接著管理員會建構完成狀態訊息、傳送它，然後測試是否有錯誤。</span><span class="sxs-lookup"><span data-stu-id="a2960-207">The manager then constructs the completion status message, sends it, and then tests if there was an error.</span></span> <span data-ttu-id="a2960-208">若有錯誤，協調流程會執行「終止」圖形，否則它就會停止。</span><span class="sxs-lookup"><span data-stu-id="a2960-208">If there was an error, the orchestration exectues a Terminate shape; otherwise, it simply ends.</span></span>  
  
## <a name="coordinating-with-the-stages"></a><span data-ttu-id="a2960-209">與階段進行協調</span><span class="sxs-lookup"><span data-stu-id="a2960-209">Coordinating with the Stages</span></span>  
 <span data-ttu-id="a2960-210">這兩個**OrderBroker**協調流程與第二個處理階段協調流程 (**CableOrder2**) 歷程記錄資料庫中建立項目。</span><span class="sxs-lookup"><span data-stu-id="a2960-210">Both the **OrderBroker** orchestration and the second processing stage orchestration (**CableOrder2**) make entries in the history database.</span></span> <span data-ttu-id="a2960-211">CableOrder2 協調流程會更新所輸入的歷程記錄資訊**OrderBroker**協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-211">The CableOrder2 orchestration updates the history information entered by the **OrderBroker** orchestration.</span></span> <span data-ttu-id="a2960-212">為了確保在更新之後，資料庫中沒有項目**OrderBroker**會使用傳遞通知，它會使用資料庫的連接埠上。</span><span class="sxs-lookup"><span data-stu-id="a2960-212">In order to ensure there is an entry in the database to update, the **OrderBroker** uses delivery notification on the port it uses for the database.</span></span>  
  
 <span data-ttu-id="a2960-213">組態對應**OrderBroker**將歷程記錄資料庫的連接埠傳送至包含兩個連接埠的傳送埠群組，有一個測試組態的連接埠 (**HISTORYINSERT-SP-測試**)，另一個用於一般組態 (**HISTORYINSERT-SP**)。</span><span class="sxs-lookup"><span data-stu-id="a2960-213">Configuration maps the **OrderBroker** send port for the history database to a send port group containing two ports—one port for the test configuration (**HistoryInsert-Test-SP**), one for the regular configuration (**HistoryInsert-SP**).</span></span> <span data-ttu-id="a2960-214">若您讓群組中的兩個連接埠皆為作用中，那麼解決方案會在這兩個連接埠上傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="a2960-214">If you leave both ports in the group active, the solution sends messages on both ports.</span></span> <span data-ttu-id="a2960-215">因此它會要求兩個傳遞通知，但只會處理其中一個。</span><span class="sxs-lookup"><span data-stu-id="a2960-215">It thus requests two delivery notifications but processes only one.</span></span>  
  
 <span data-ttu-id="a2960-216">若要避免這種情況下，取消登錄測試連接埠 (**測試-HISTORYINSERT-SP**)，或停止應用程式測試版本。</span><span class="sxs-lookup"><span data-stu-id="a2960-216">To avoid this situation, unenlist the test port (**HistoryInsert-Test-SP**), or stop the test version of the application.</span></span> <span data-ttu-id="a2960-217">如需傳遞通知的詳細資訊，請參閱[使用通知](../core/using-acknowledgments.md)。</span><span class="sxs-lookup"><span data-stu-id="a2960-217">For more information about delivery notification, see [Using Acknowledgments](../core/using-acknowledgments.md).</span></span>  
  
## <a name="errors-and-routing-repaired-messagesdesign-choices"></a><span data-ttu-id="a2960-218">錯誤與路由修復訊息—設計選擇</span><span class="sxs-lookup"><span data-stu-id="a2960-218">Errors and Routing Repaired Messages—Design Choices</span></span>  
 <span data-ttu-id="a2960-219">例外狀況處理常式協調流程和訂單處理階段所使用的協調流程使用錯誤處理協調流程 (**ErrorHandlerOrch**) 來路由損壞修復的訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-219">The exception handler orchestration and orchestrations used by the order processing stages use an error handling orchestration (**ErrorHandlerOrch**) to route bad orders for repair.</span></span> <span data-ttu-id="a2960-220">此設計會假設有一個部門或群組將需要在表單中修復訂單。</span><span class="sxs-lookup"><span data-stu-id="a2960-220">The design supposes that there is a department or group that will fix the order in the form needed.</span></span> <span data-ttu-id="a2960-221">修復的訂單不重新送出訂單仲介協調流程透過 (**OrderBroker**)。</span><span class="sxs-lookup"><span data-stu-id="a2960-221">The repaired order is not resubmitted through the order broker orchestration (**OrderBroker**).</span></span> <span data-ttu-id="a2960-222">當然，標準化訂單會在其標準化表單中修復。</span><span class="sxs-lookup"><span data-stu-id="a2960-222">Rather, the normalized order is repaired in its normalized form.</span></span> <span data-ttu-id="a2960-223">解決方案的目前設計會讓處理常式協調流程將錯誤訊息路由回到原始訂單的來源。</span><span class="sxs-lookup"><span data-stu-id="a2960-223">The current design of the solution has the handler orchestration route the error message back to the source of the original order.</span></span> <span data-ttu-id="a2960-224">不過，修復的訂單必須路由到錯誤處理常式協調流程上的 MSMQ 連接埠。</span><span class="sxs-lookup"><span data-stu-id="a2960-224">Repaired orders, however, have to be routed to an MSMQ port on the error handler orchestration.</span></span> <span data-ttu-id="a2960-225">(解決方案測試版本會使用檔案資料夾。)接著錯誤處理常式會將已修復的訊息傳回呼叫協調流程。</span><span class="sxs-lookup"><span data-stu-id="a2960-225">(The test version of the solution uses a file folder.) The error handler then returns the repaired message to the calling orchestration.</span></span>  
  
 <span data-ttu-id="a2960-226">這個解決方案使用這個設計，是因為訂單仲介會對訂單訊息進行重要的驗證和標準化。</span><span class="sxs-lookup"><span data-stu-id="a2960-226">This solution uses this design, because the order broker does significant validation and normalization of the order message.</span></span> <span data-ttu-id="a2960-227">接著，要求修復的訂單訊息也會在標準化表單中。</span><span class="sxs-lookup"><span data-stu-id="a2960-227">In turn, the order message requiring repair is also in the normalized form.</span></span> <span data-ttu-id="a2960-228">維護訊息的標準化表單，可避免必須處理訊息之已提交表單與標準化表單之間的差異性。</span><span class="sxs-lookup"><span data-stu-id="a2960-228">Maintaining the normalized form of the message prevents having to work around the difference between the submitted and normalized forms of the messages.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2960-229">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a2960-229">See Also</span></span>  
 <span data-ttu-id="a2960-230">[程序管理員邏輯](../core/process-manager-logic.md) </span><span class="sxs-lookup"><span data-stu-id="a2960-230">[Process Manager Logic](../core/process-manager-logic.md) </span></span>  
 [<span data-ttu-id="a2960-231">關鍵訊息和欄位</span><span class="sxs-lookup"><span data-stu-id="a2960-231">Key Messages and Fields</span></span>](../core/key-messages-and-fields.md)