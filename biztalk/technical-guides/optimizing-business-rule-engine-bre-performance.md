---
title: 商務規則引擎 (BRE) 效能最佳化 |Microsoft 文件
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c271b059-174d-4e8b-88b5-c3f408a97f1f
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 14c3adf32ac06d80c1aab8f870d82156470097a5
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/20/2017
ms.locfileid: "22298926"
---
# <a name="optimizing-business-rule-engine-bre-performance"></a><span data-ttu-id="c4a85-102">商務規則引擎 (BRE) 效能最佳化</span><span class="sxs-lookup"><span data-stu-id="c4a85-102">Optimizing Business Rule Engine (BRE) Performance</span></span>
<span data-ttu-id="c4a85-103">BizTalk Server 解決方案中實作商務規則引擎 (BRE) 時，應該考慮下列因素：</span><span class="sxs-lookup"><span data-stu-id="c4a85-103">The following factors should be considered when implementing the Business Rule Engine (BRE) in a BizTalk Server solution:</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="c4a85-104">事實類型</span><span class="sxs-lookup"><span data-stu-id="c4a85-104">Fact types</span></span>  
 <span data-ttu-id="c4a85-105">規則引擎存取.NET 事實的時間比較所需的存取 XML 和資料庫事實會較少的時間。</span><span class="sxs-lookup"><span data-stu-id="c4a85-105">The rule engine takes less time to access .NET facts compared to the time it takes to access XML and database facts.</span></span> <span data-ttu-id="c4a85-106">如果您選擇在原則中使用.NET 或 XML 或資料庫事實，您應該考慮使用.NET 事實，以改善效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-106">If you have a choice of using either .NET or XML or database facts in a policy, you should consider using .NET facts for improved performance.</span></span>  
  
## <a name="data-table-vs-data-connection"></a><span data-ttu-id="c4a85-107">資料表與資料連接</span><span class="sxs-lookup"><span data-stu-id="c4a85-107">Data table vs. data connection</span></span>  
 <span data-ttu-id="c4a85-108">當資料集的大小很小 （< 10 左右）， **TypedDataTable**繫結會提供更佳的效能比**DataConnection**繫結。</span><span class="sxs-lookup"><span data-stu-id="c4a85-108">When the size of the data set is small (< 10 or so), the **TypedDataTable** binding provides better performance than the **DataConnection** binding.</span></span> <span data-ttu-id="c4a85-109">不過， **DataConnection**繫結的執行效能比**TypedDataTable**繫結時的資料集很大 （大於或等於 10 個資料列大約）。</span><span class="sxs-lookup"><span data-stu-id="c4a85-109">However, the **DataConnection** binding performs better than the **TypedDataTable** binding when the data set is large (greater than or equal to 10 rows approximately).</span></span> <span data-ttu-id="c4a85-110">因此，您應該決定是否要使用**DataConnection**繫結或**TypedDataTable**繫結會根據資料集的估計大小。</span><span class="sxs-lookup"><span data-stu-id="c4a85-110">Therefore, you should decide whether to use the **DataConnection** binding or **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="c4a85-111">事實擷取器</span><span class="sxs-lookup"><span data-stu-id="c4a85-111">Fact retrievers</span></span>  
 <span data-ttu-id="c4a85-112">事實擷取器實作通常會用來提供長期和緩時變更的事實到規則引擎執行原則之前的標準方法。</span><span class="sxs-lookup"><span data-stu-id="c4a85-112">A fact retriever implements standard methods which are typically used to supply long-term and slowly changing facts to the rule engine before a policy is executed.</span></span> <span data-ttu-id="c4a85-113">此引擎會快取這些事實，並透過多個執行循環來使用這些事實。</span><span class="sxs-lookup"><span data-stu-id="c4a85-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="c4a85-114">而非提交靜態或相當靜態事實每次叫用規則引擎，您應該建立事實擷取器的第一次，提交事實，然後更新 只在必要時，記憶體中的事實。</span><span class="sxs-lookup"><span data-stu-id="c4a85-114">Instead of submitting a static or fairly static fact each time that you invoke the rule engine, you should create a fact retriever that submits the fact for the first time, and then updates the fact in memory only when necessary.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="c4a85-115">規則優先順序</span><span class="sxs-lookup"><span data-stu-id="c4a85-115">Rule priority</span></span>  
 <span data-ttu-id="c4a85-116">優先順序設定規則的任一端的範圍可以**0**，數目越大則優先順序愈高。</span><span class="sxs-lookup"><span data-stu-id="c4a85-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="c4a85-117">從最高的優先順序到最低優先順序的順序會執行動作。</span><span class="sxs-lookup"><span data-stu-id="c4a85-117">Actions are executed in order from the highest priority to lowest priority.</span></span> <span data-ttu-id="c4a85-118">當原則正向鏈結行為會藉由實作使用**Assert/Update**呼叫，鏈結 可最佳化使用的優先權設定。</span><span class="sxs-lookup"><span data-stu-id="c4a85-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="c4a85-119">例如，假設**Rule2**具有相依性所設定的值**Rule1**。</span><span class="sxs-lookup"><span data-stu-id="c4a85-119">For example, assume that **Rule2** has a dependency on a value set by **Rule1**.</span></span> <span data-ttu-id="c4a85-120">提供**Rule1**較高的優先順序表示**Rule2**之後不會只執行**Rule1**引發及更新的值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-120">Giving **Rule1** a higher priority means that **Rule2** will only execute after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="c4a85-121">相反地，如果**Rule2**已提供更高的優先權，它無法引發一次，並再一次之後，會引發**Rule1**引發及更新事實的**Rule2**使用的條件。</span><span class="sxs-lookup"><span data-stu-id="c4a85-121">Conversely, if **Rule2** were given a higher priority, it could fire once, and then fire again after **Rule1** fires and update the fact that **Rule2** is using a condition.</span></span> <span data-ttu-id="c4a85-122">雖然這可能會提供正確的結果，讓**Rule1**較高的優先順序，在此案例中會提供更佳的效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-122">While this may provide a correct result, giving **Rule1** a higher priority in this scenario will provide better performance.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="c4a85-123">Update 呼叫</span><span class="sxs-lookup"><span data-stu-id="c4a85-123">Update calls</span></span>  
 <span data-ttu-id="c4a85-124">Update 函式會導致重新評估使用更新的事實的所有規則。</span><span class="sxs-lookup"><span data-stu-id="c4a85-124">The Update function causes all the rules using the updated facts to be reevaluated.</span></span> <span data-ttu-id="c4a85-125">更新函式呼叫可以是高度耗費資源，尤其是更新事實時，會重新評估規則的大型集合。</span><span class="sxs-lookup"><span data-stu-id="c4a85-125">Update function calls can be expensive especially if a large set of rules is reevaluated when updating facts.</span></span> <span data-ttu-id="c4a85-126">有很多情況下可以避免發生這種行為。</span><span class="sxs-lookup"><span data-stu-id="c4a85-126">There are situations where this behavior can be avoided.</span></span> <span data-ttu-id="c4a85-127">例如，假設下列規則。</span><span class="sxs-lookup"><span data-stu-id="c4a85-127">For example, consider the following rules.</span></span>  
  
 <span data-ttu-id="c4a85-128">**Rule1:**</span><span class="sxs-lookup"><span data-stu-id="c4a85-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="c4a85-129">**Rule2:**</span><span class="sxs-lookup"><span data-stu-id="c4a85-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="c4a85-130">原則使用的所有其餘規則**StatusObj.Flag**在其條件中。</span><span class="sxs-lookup"><span data-stu-id="c4a85-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="c4a85-131">因此，當**更新**上呼叫**StatusObj**物件，將會重新評估所有規則。</span><span class="sxs-lookup"><span data-stu-id="c4a85-131">Therefore, when **Update** is called on the **StatusObj** object, all rules will be reevaluated.</span></span> <span data-ttu-id="c4a85-132">任何值**量**欄位時，所有規則都**Rule1**或**Rule2**會評估兩次，一次之前**更新**呼叫和一次之後**更新**呼叫。</span><span class="sxs-lookup"><span data-stu-id="c4a85-132">Whatever the value of the **Amount** field is, all rules except **Rule1** or **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="c4a85-133">若要減輕相關聯額外負荷，您可以設定的值**旗標**欄位設為**false**再叫用原則，然後使用僅**Rule1**中的原則設定的旗標.</span><span class="sxs-lookup"><span data-stu-id="c4a85-133">To mitigate the associated overhead, you could set the value of the **flag** field to **false** prior to invoking the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="c4a85-134">在此情況下，**更新**，才會呼叫的值**量**欄位值大於 5，而**更新**如果不呼叫函式的值**數量**小於或等於 5。</span><span class="sxs-lookup"><span data-stu-id="c4a85-134">In this case, **Update** would be called only if the value of the **Amount** field is greater than 5, and the **Update** function is not called if the value of **Amount** is less than or equal to 5.</span></span> <span data-ttu-id="c4a85-135">因此，所有的規則都**Rule1**或**Rule2**會評估兩次才值**量**欄位值大於 5。</span><span class="sxs-lookup"><span data-stu-id="c4a85-135">Therefore, all the rules except **Rule1** or **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="usage-of-logical-or-operators"></a><span data-ttu-id="c4a85-136">邏輯 OR 運算子的使用方式</span><span class="sxs-lookup"><span data-stu-id="c4a85-136">Usage of logical OR operators</span></span>  
 <span data-ttu-id="c4a85-137">在條件中使用的邏輯 OR 運算子會建立其他的排列，以擴充規則引擎的分析網路。</span><span class="sxs-lookup"><span data-stu-id="c4a85-137">Using an increasing number of logical OR operators in conditions creates additional permutations that expand the analysis network of the rule engine.</span></span> <span data-ttu-id="c4a85-138">從效能觀點來看，您最好是將條件分割成不包含邏輯 OR 運算子的不可部分完成規則。</span><span class="sxs-lookup"><span data-stu-id="c4a85-138">From a performance standpoint, you are better off splitting the conditions into atomic rules that do not contain logical OR operators.</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="c4a85-139">快取設定</span><span class="sxs-lookup"><span data-stu-id="c4a85-139">Caching settings</span></span>  
 <span data-ttu-id="c4a85-140">規則引擎會使用兩個快取。</span><span class="sxs-lookup"><span data-stu-id="c4a85-140">The Rule Engine uses two caches.</span></span> <span data-ttu-id="c4a85-141">更新服務會使用第一個和第二個由每個 BizTalk 處理序。</span><span class="sxs-lookup"><span data-stu-id="c4a85-141">The first one is used by the update service and the second one is used by each BizTalk process.</span></span> <span data-ttu-id="c4a85-142">第一次使用原則時，BizTalk 處理序會從更新服務要求的原則資訊。</span><span class="sxs-lookup"><span data-stu-id="c4a85-142">The first time a policy is used, the BizTalk process requests the policy information from the update service.</span></span> <span data-ttu-id="c4a85-143">更新服務會從規則引擎資料庫擷取原則資訊、 快取和將資訊傳回給 BizTalk 處理序。</span><span class="sxs-lookup"><span data-stu-id="c4a85-143">The update service retrieves the policy information from the rule engine database, caches it and returns the information to the BizTalk process.</span></span> <span data-ttu-id="c4a85-144">BizTalk 處理序建立根據該資訊的原則物件，並將 [原則] 物件儲存在快取中，相關聯的規則引擎執行個體完成執行原則時。</span><span class="sxs-lookup"><span data-stu-id="c4a85-144">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes execution of the policy.</span></span> <span data-ttu-id="c4a85-145">當再次叫用相同的原則時，BizTalk 處理序重複使用 [原則] 物件從快取，如果有的話。</span><span class="sxs-lookup"><span data-stu-id="c4a85-145">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available.</span></span> <span data-ttu-id="c4a85-146">同樣地，如果 BizTalk 處理序從更新服務要求原則的相關資訊，請更新服務會尋找其快取中的原則資訊是否可用。</span><span class="sxs-lookup"><span data-stu-id="c4a85-146">Similarly, if the BizTalk process requests information about a policy from update service, the update service looks for the policy information in its cache if it is available.</span></span> <span data-ttu-id="c4a85-147">每隔 60 秒，更新服務也會檢查是否有任何更新資料庫中的原則。</span><span class="sxs-lookup"><span data-stu-id="c4a85-147">Every 60 seconds, the update service also checks if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="c4a85-148">如果有任何更新，更新服務擷取的資訊，並快取更新的資訊。</span><span class="sxs-lookup"><span data-stu-id="c4a85-148">If there are any updates, the update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="c4a85-149">有三個調整參數，與這些快取相關的規則引擎： **CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="c4a85-149">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="c4a85-150">您可以在登錄或組態檔中，為這些參數指定值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-150">You can specify the values for these parameters either in the registry or in a configuration file.</span></span> <span data-ttu-id="c4a85-151">值**CacheEntries**參數是快取中的項目數目上限，並且預設設定為 32 的值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-151">The value of the **CacheEntries** parameter is the maximum number of entries in the cache and is set to a value of 32 by default.</span></span> <span data-ttu-id="c4a85-152">您可能想要增加的值**CacheEntries**參數，在某些情況下改善效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-152">You may want to increase the value of the **CacheEntries** parameter to improve performance in certain scenarios.</span></span> <span data-ttu-id="c4a85-153">例如，假設您使用 40 個原則重複。您可以增加值的**CacheEntries**參數到 40，以改善效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-153">For example, say you are using 40 policies repeatedly; you could to increase the value of the **CacheEntries** parameter to 40 to improve performance.</span></span> <span data-ttu-id="c4a85-154">這樣可讓更新服務維持的最多 40 個原則在記憶體中的快取詳細資料。</span><span class="sxs-lookup"><span data-stu-id="c4a85-154">This would allow the update service to maintain cache details of up to 40 policies in memory.</span></span>  
  
 <span data-ttu-id="c4a85-155">值**CacheTimeout**是以秒為單位的一個項目會保存在更新服務快取中的時間。</span><span class="sxs-lookup"><span data-stu-id="c4a85-155">The value of **CacheTimeout** is the time in seconds that an entry is maintained in the update service cache.</span></span> <span data-ttu-id="c4a85-156">換句話說， **CacheTimeout**值指的是時間的快取的原則會維護快取中，而不被參考。</span><span class="sxs-lookup"><span data-stu-id="c4a85-156">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is maintained in the cache without being referenced.</span></span> <span data-ttu-id="c4a85-157">預設值**CacheTimeout**參數為 3600 秒或 1 小時。</span><span class="sxs-lookup"><span data-stu-id="c4a85-157">The default value of **CacheTimeout** parameter is 3600 seconds, or 1 hour.</span></span> <span data-ttu-id="c4a85-158">這表示如果在一小時內未參考快取項目，會刪除項目。</span><span class="sxs-lookup"><span data-stu-id="c4a85-158">It means that if the cache entry is not referenced within an hour, the entry is deleted.</span></span> <span data-ttu-id="c4a85-159">在某些情況下，可能會增加的值有幫助**CacheTimeout**參數，以改善效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-159">In some cases, it may be beneficial to increase the value of the **CacheTimeout** parameter to improve performance.</span></span> <span data-ttu-id="c4a85-160">例如，如果原則會叫用每隔兩小時，原則執行的效能會改善藉由增加**CacheTimeout**高於兩小時的值的參數。</span><span class="sxs-lookup"><span data-stu-id="c4a85-160">For example, if a policy is invoked every two hours, performance of the policy execution would be improved by increasing the **CacheTimeout** parameter to a value higher than two hours.</span></span>  
  
 <span data-ttu-id="c4a85-161">**PollingInterval**規則引擎的參數定義的時間，以秒為單位的更新服務檢查規則引擎資料庫更新。</span><span class="sxs-lookup"><span data-stu-id="c4a85-161">The **PollingInterval** parameter of the rule engine defines the time in seconds for the update service to check the rule engine database for updates.</span></span> <span data-ttu-id="c4a85-162">預設值為**PollingInterval**參數為 60 秒。</span><span class="sxs-lookup"><span data-stu-id="c4a85-162">The default value for the **PollingInterval** parameter is 60 seconds.</span></span> <span data-ttu-id="c4a85-163">如果您知道原則根本沒有未取得更新，或很少會更新，您可以變更此參數為較高的值，以改善效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-163">If you know that the policies do not get updated at all or are updated rarely, you could change this parameter to a higher value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="c4a85-164">SideEffects 屬性</span><span class="sxs-lookup"><span data-stu-id="c4a85-164">SideEffects property</span></span>  
 <span data-ttu-id="c4a85-165">**ClassMemberBinding**， **Xmldocumentfieldbinding**，和**XmlDocumentFieldBinding**類別有一個名為屬性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="c4a85-165">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="c4a85-166">這個屬性可決定是否會快取繫結欄位、成員或資料行的值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-166">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="c4a85-167">預設值**SideEffects**屬性**Xmldocumentfieldbinding**和**XmlDocumentFieldBinding**類別**false**.</span><span class="sxs-lookup"><span data-stu-id="c4a85-167">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="c4a85-168">預設值**SideEffects**屬性**ClassMemberBinding**類別是**true**。</span><span class="sxs-lookup"><span data-stu-id="c4a85-168">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="c4a85-169">因此，當第二次以後在原則中存取 XML 文件的欄位或資料庫資料表的資料行時，則會從快取中擷取其值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-169">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="c4a85-170">但是，當第二次以後存取 .NET 物件的成員時，就會從此 .NET 物件擷取該值，而不是從快取中擷取。</span><span class="sxs-lookup"><span data-stu-id="c4a85-170">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="c4a85-171">設定**SideEffects** .NET 屬性**ClassMemberBinding**至**false**會改善效能，因為從快取中擷取欄位的值第二次以後。</span><span class="sxs-lookup"><span data-stu-id="c4a85-171">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="c4a85-172">您只能透過程式設計的方式進行這項處理。</span><span class="sxs-lookup"><span data-stu-id="c4a85-172">You can only do this programmatically.</span></span> <span data-ttu-id="c4a85-173">「 商務規則編輯器 」 工具不會公開**SideEffects**屬性。</span><span class="sxs-lookup"><span data-stu-id="c4a85-173">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="c4a85-174">執行個體與選擇性</span><span class="sxs-lookup"><span data-stu-id="c4a85-174">Instances and selectivity</span></span>  
 <span data-ttu-id="c4a85-175">**XmlDocumentBinding**， **ClassBinding**，和**DatabaseBinding**類別有兩個屬性：**執行個體**和**選擇性**。</span><span class="sxs-lookup"><span data-stu-id="c4a85-175">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="c4a85-176">執行個體的值是預期的工作記憶體中類別的執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="c4a85-176">The value of Instances is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="c4a85-177">值**選擇性**是將會成功通過規則條件的類別執行個體的百分比。</span><span class="sxs-lookup"><span data-stu-id="c4a85-177">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="c4a85-178">規則引擎會使用這些值來最佳化條件評估，以便先在條件評估中使用可能的最少執行個體，然後再使用剩餘的執行個體。</span><span class="sxs-lookup"><span data-stu-id="c4a85-178">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="c4a85-179">如果您事先知道物件的執行個體的數目，設定**執行個體**屬性設為該值將會提升效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-179">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="c4a85-180">同樣地，如果您事先知道這些物件通過條件的百分比，設定**選擇性**屬性設為該值將會提升效能。</span><span class="sxs-lookup"><span data-stu-id="c4a85-180">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="c4a85-181">您只能以程式設計方式設定這些參數的值。</span><span class="sxs-lookup"><span data-stu-id="c4a85-181">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="c4a85-182">「商務規則編輯器」工具不會公開這些參數。</span><span class="sxs-lookup"><span data-stu-id="c4a85-182">The Business Rule Composer tool does not expose them.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c4a85-183">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c4a85-183">See Also</span></span>  
 [<span data-ttu-id="c4a85-184">BizTalk Server 效能最佳化</span><span class="sxs-lookup"><span data-stu-id="c4a85-184">Optimizing BizTalk Server Performance</span></span>](../technical-guides/optimizing-biztalk-server-performance.md)